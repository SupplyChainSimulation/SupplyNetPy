{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SupplyNetPy Documentation SupplyNetPy is a Python library specifically designed and developed to model and simulate different supply chain problems with ease. It provides configurable components such as suppliers, manufacturers, distributors, and demand points for creating arbitrary supply chain networks, along with configurable policies for inventory management and replenishment. With SupplyNetPy, we can quickly assemble a supply chain, specify demand and supply behaviors, and run simulations to evaluate performance metrics like throughput and profit. Table of Contents SupplyNetPy in 10 minutes Installation Creating a supply chain network Simulating supply chains Examples API references About","title":"Home"},{"location":"#supplynetpy-documentation","text":"SupplyNetPy is a Python library specifically designed and developed to model and simulate different supply chain problems with ease. It provides configurable components such as suppliers, manufacturers, distributors, and demand points for creating arbitrary supply chain networks, along with configurable policies for inventory management and replenishment. With SupplyNetPy, we can quickly assemble a supply chain, specify demand and supply behaviors, and run simulations to evaluate performance metrics like throughput and profit.","title":"SupplyNetPy Documentation"},{"location":"#table-of-contents","text":"SupplyNetPy in 10 minutes Installation Creating a supply chain network Simulating supply chains Examples API references About","title":"Table of Contents"},{"location":"EOQ_est/","text":"img{ width:75%; } This example is from the textbook Supply Chain Management: Strategy, Planning, and Operation, (Chopra and Meindl) Find the Google Colab notebook for this example here . Estimating Economic Order Quantity (EOQ) System Description As Best Buy sells its current inventory of HP computers, the purchasing manager places a replenishment order for a new lot of Q computers. Including the cost of transportation, Best Buy incurs a fixed cost of $S per order. The purchasing manager must decide on the number of computers to order from HP in a lot. For this decision, we assume the following inputs: D Annual demand of the product S Fixed cost incurred per order C Cost per unit h Holding cost per year as a fraction of product cost Assume that HP does not offer any discounts, and each unit costs $C no matter how large an order is. The holding cost is thus given by H = hC. The model is developed using the following basic assumptions: Demand is steady at D units per unit time. No shortages are allowed, that is, all demand must be supplied from stock. Replenishment lead time is fixed (initially assumed to be zero). The purchasing manager makes the lot-sizing decision to minimize the total cost the store incurs. He or she must consider three costs when deciding on the lot size: Annual material cost Annual ordering cost Annual holding cost Because purchase price is independent of lot size, we have Annual material cost = \\(CD\\) The number of orders must suffice to meet the annual demand D. Given a lot size of Q, we thus have Number of orders per year = \\(\\frac{D}{Q}\\) Because an order cost of S is incurred for each order placed, we infer that Annual ordering cost = \\((\\frac{D}{Q}){S}\\) Given a lot size of Q, we have an average inventory of Q/2. The annual holding cost is thus the cost of holding Q/2 units in inventory for one year and is given as Annual holding cost = \\((\\frac{Q}{2})H = (\\frac{Q}{2})hC\\) The total annual cost, TC, is the sum of all three costs and is given as Total annual cost, \\(TC = CD + (\\frac{D}{Q})S + (\\frac{Q}{2})hC\\) Image source: [Textbook] Supply Chain Management: Strategy, Planning, and Operation, (Chopra and Meindl) Above figure shows the variation in different costs as the lot size is changed. Observe that the annual holding cost increases with an increase in lot size. In contrast, the annual ordering cost declines with an increase in lot size. The material cost is independent of lot size because we have assumed the price to be fixed. The total annual cost thus first declines and then increases with an increase in lot size. From the perspective of the manager at Best Buy, the optimal lot size is one that minimizes the total cost to Best Buy. It is obtained by taking the first derivative of the total cost with respect to Q and setting it equal to 0. The optimum lot size is referred to as the economic order quantity (EOQ). It is denoted by Q* and is given by the following equation: Optimal lot size, \\(Q* = \\sqrt{\\frac{2DS}{hC}}\\) Numerical Example Demand for the Deskpro computer at Best Buy is 1,000 units per month. Best Buy incurs a fixed order placement, transportation, and receiving cost of $4,000 each time an order is placed. Each computer costs Best Buy $500 and the retailer has a holding cost of 20 percent. Evaluate the number of computers that the store manager should order in each replenishment lot. Analysis: In this case, the store manager has the following inputs: Annual demand, \\(D = 1,000 * 12 = 12,000\\) units Order cost per lot, \\(S = 4,000\\) Unit cost per computer, \\(C = 500\\) Holding cost per year as a fraction of unit cost, \\(h = 0.2\\) Using the EOQ formula, the optimal lot size is Optimal order size = Q* = \\(\\sqrt{\\frac{2 * 12,000 * 4,000}{0.2 * 500}} = 980\\) To minimize the total cost at Best Buy, the store manager orders a lot size of 980 computers for each replenishment order. The cycle inventory is the average resulting inventory and is given by Cycle inventory = \\(\\frac{Q*}{2} = 490\\) For a lot size of Q* = 980, the store manager evaluates Number of orders per year = \\(\\frac{D} {Q*} = \\frac{12,000} {980} = 12.24\\) Annual ordering and holding cost = \\(\\frac{D} {Q*} S + (\\frac{Q*} {2}) hC = 97,980\\) Average flow time = \\(\\frac{Q*} {2D} = \\frac{490} {12,000} = 0.041\\) year \\(= 0.49\\) month Each computer thus spends 0.49 month, on average, at Best Buy before it is sold because it was purchased in a batch of 980. Implementation import simpy import numpy as np import matplotlib.pyplot as plt import SupplyNetPy.Components as scm \"\"\" Demand for the Deskpro computer at Best Buy is 1,000 units per month. Best Buy incurs a fixed order placement, transportation, and receiving cost of $4,000 each time an order is placed. Each computer costs Best Buy $500 and the retailer has a holding cost of 20 percent. Evaluate the number of computers that the store manager should order in each replenishment lot. Analysis: In this case, the store manager has the following inputs: - Annual demand, D = 1,000 * 12 = 12,000 units (approx 34 units per day) - Order cost per lot, S = 4,000 - Unit cost per computer, C = 500 - Holding cost per year as a fraction of unit cost, h = 0.2 (500*0.2 = 100 per year => 100/365 = 0.273 per day) Assumptions: - Demand is constant and deterministic - Lead time is zero Optimum Economic Order Quantity (EOQ) is determined to minimize the total cost. Total cost = Annual material cost + Annual ordering cost + Annual holding cost This is same as -> Total cost = total transportation cost + inventory cost (we'll ignore material cost since it is constant) \"\"\" D = 12000 # annual demand d = 34 # daily demand order_cost = 4000 # order cost unit_cost = 500 # unit cost holding_cost = 0.273 # holding cost per day lead_time = 0 # lead time simlen = 3650 # simulation length in days total_cost_arr = [] unsat_arr = [] print(f\"lot size \\t Inv holding cost \\t Order cost \\t Average cost(per day) \\t Unmet demand\") for lot_size in range(800,1600,10): order_interval = 365*lot_size/D env = simpy.Environment() hp_supplier = scm.Supplier(env=env, ID=\"S1\", name=\"HPComputers\", node_type=\"infinite_supplier\") bestbuy = scm.InventoryNode(env=env, ID=\"D1\", name=\"Best Buy\", node_type=\"distributor\", capacity=lot_size, initial_level=lot_size, inventory_holding_cost=holding_cost, replenishment_policy=scm.PeriodicReplenishment, product_buy_price=450, policy_param={'T':order_interval,'Q':lot_size}, product_sell_price=unit_cost) link1 = scm.Link(env=env,ID=\"l1\", source=hp_supplier, sink=bestbuy, cost=order_cost, lead_time=lambda: lead_time) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, order_quantity_model=lambda: d, demand_node=bestbuy, consume_available=True) scm.global_logger.disable_logging() # disable logging for all components env.run(until=simlen) bb_invlevels = np.array(bestbuy.inventory.instantaneous_levels) hp_sup_transportation_cost = bestbuy.stats.transportation_cost total_cost = bestbuy.stats.inventory_carry_cost + bestbuy.stats.transportation_cost total_cost_arr.append([lot_size, total_cost/simlen]) unsat_demand = demand1.stats.demand_placed[1]-demand1.stats.fulfillment_received[1] unsat_arr.append([lot_size,unsat_demand]) print(f\"{lot_size} \\t\\t {bestbuy.stats.inventory_carry_cost:.2f}\\t\\t{bestbuy.stats.transportation_cost}\\t\\t{total_cost/simlen:.2f}\\t\\t{unsat_demand:.2f}\") total_cost_arr = np.array(total_cost_arr) unsat_arr = np.array(unsat_arr) EOQ = np.argmin(total_cost_arr[:,1]) plt.figure() plt.plot(total_cost_arr[:,0], total_cost_arr[:,1],marker='.',linestyle='-') plt.plot(total_cost_arr[EOQ,0], total_cost_arr[EOQ,1],marker='o',color='red',label=f'EOQ = {total_cost_arr[EOQ,0]:.2f} with cost = {total_cost_arr[EOQ,1]:.2f}') plt.xlabel(\"lot size\") plt.ylabel(\"Average cost per day\") plt.title(\"Average cost vs lot size\") plt.legend() plt.grid() plt.show() lot size Inv holding cost Order cost Average cost(per day) Unmet demand 800 386458.80 596000 269.17 4100.00 810 390557.96 592000 269.19 4118.00 820 395049.18 584000 268.23 4140.00 830 400188.24 576000 267.45 4104.00 840 405223.18 568000 266.64 4106.00 850 409730.10 564000 266.78 4114.00 860 414937.16 556000 266.01 4118.00 870 419476.82 548000 265.06 4094.00 880 424411.62 544000 265.32 4114.00 890 429494.01 536000 264.52 4092.00 900 436224.38 532000 265.27 4094.00 910 438638.31 524000 263.74 4074.00 920 442904.09 520000 263.81 4096.00 930 448040.50 516000 264.12 4130.00 940 453707.25 508000 263.48 4108.00 950 458159.42 504000 263.61 4094.00 960 462991.62 500000 263.83 4100.00 970 468226.74 492000 263.08 4110.00 980 472987.11 488000 263.28 4098.00 990 477960.52 484000 263.55 4106.00 1000 481626.60 480000 263.46 4100.00 1010 487159.07 472000 262.78 4104.00 1020 492760.50 468000 263.22 4080.00 1030 496374.95 464000 263.12 4110.00 1040 502052.28 460000 263.58 4092.00 1050 507372.65 456000 263.94 4094.00 1060 511096.54 452000 263.86 4116.00 1070 516617.65 448000 264.28 4124.00 1080 519820.94 444000 264.06 4118.00 1090 525820.83 440000 264.61 4098.00 1100 530125.28 436000 264.69 4098.00 1110 534894.02 432000 264.90 4118.00 1120 539837.84 428000 265.16 4124.00 1130 544889.08 424000 265.45 4116.00 1140 550465.87 420000 265.88 4094.00 1150 554073.29 416000 265.77 4092.00 1160 559606.68 412000 266.19 4110.00 1170 564940.50 408000 266.56 4080.00 1180 569711.55 404000 266.77 4104.00 1190 573919.60 400000 266.83 4080.00 1200 586076.40 396000 269.06 4100.00 1210 583497.57 396000 268.36 4106.00 1220 589075.99 392000 268.79 4098.00 1230 593807.38 388000 268.99 4110.00 1240 598836.42 384000 269.27 4074.00 1250 601944.80 380000 269.03 4100.00 1260 607432.10 380000 270.53 4094.00 1270 613174.10 376000 271.01 4108.00 1280 617805.01 372000 271.18 4074.00 1290 621160.11 372000 272.10 4130.00 1300 627485.86 368000 272.74 4092.00 1310 631953.94 364000 272.86 4074.00 1320 637026.39 360000 273.16 4076.00 1330 640737.93 360000 274.17 4094.00 1340 646993.21 356000 274.79 4092.00 1350 652581.25 352000 275.23 4076.00 1360 655767.11 352000 276.10 4114.00 1370 661892.46 348000 276.68 4094.00 1380 663762.51 344000 276.10 4060.00 1390 671198.93 344000 278.14 4118.00 1400 676112.71 340000 278.39 4080.00 1410 679131.28 340000 279.21 4114.00 1420 685778.46 336000 279.94 4106.00 1430 687048.38 332000 279.19 4084.00 1440 695202.14 332000 281.43 4104.00 1450 700610.60 328000 281.81 4078.00 1460 704462.53 328000 282.87 4108.00 1470 710215.40 324000 283.35 4078.00 1480 716061.53 324000 284.95 4118.00 1490 720095.10 320000 284.96 4084.00 1500 724323.60 316000 285.02 4100.00 1510 729269.91 316000 286.38 4096.00 1520 732658.29 312000 286.21 4078.00 1530 739202.82 312000 288.00 4080.00 1540 742057.54 308000 287.69 4058.00 1550 749044.53 308000 289.60 4104.00 1560 752204.00 304000 289.37 4078.00 1570 759076.52 304000 291.25 4100.00 1580 762089.05 300000 290.98 4070.00 1590 768415.08 300000 292.72 4102.00 Results We conducted multiple simulations with varying lengths (1000, 2000, 3000, 4000, 5000, and 6000). Our findings indicated that when the simulation length is less than 4000, the Economic Order Quantity (EOQ) is approximately 1010. Additionally, we found that the results improve as the simulation length increases.","title":"Estimating EOQ"},{"location":"EOQ_est/#estimating-economic-order-quantity-eoq","text":"","title":"Estimating Economic Order Quantity (EOQ)"},{"location":"EOQ_est/#system-description","text":"As Best Buy sells its current inventory of HP computers, the purchasing manager places a replenishment order for a new lot of Q computers. Including the cost of transportation, Best Buy incurs a fixed cost of $S per order. The purchasing manager must decide on the number of computers to order from HP in a lot. For this decision, we assume the following inputs: D Annual demand of the product S Fixed cost incurred per order C Cost per unit h Holding cost per year as a fraction of product cost Assume that HP does not offer any discounts, and each unit costs $C no matter how large an order is. The holding cost is thus given by H = hC. The model is developed using the following basic assumptions: Demand is steady at D units per unit time. No shortages are allowed, that is, all demand must be supplied from stock. Replenishment lead time is fixed (initially assumed to be zero). The purchasing manager makes the lot-sizing decision to minimize the total cost the store incurs. He or she must consider three costs when deciding on the lot size: Annual material cost Annual ordering cost Annual holding cost Because purchase price is independent of lot size, we have Annual material cost = \\(CD\\) The number of orders must suffice to meet the annual demand D. Given a lot size of Q, we thus have Number of orders per year = \\(\\frac{D}{Q}\\) Because an order cost of S is incurred for each order placed, we infer that Annual ordering cost = \\((\\frac{D}{Q}){S}\\) Given a lot size of Q, we have an average inventory of Q/2. The annual holding cost is thus the cost of holding Q/2 units in inventory for one year and is given as Annual holding cost = \\((\\frac{Q}{2})H = (\\frac{Q}{2})hC\\) The total annual cost, TC, is the sum of all three costs and is given as Total annual cost, \\(TC = CD + (\\frac{D}{Q})S + (\\frac{Q}{2})hC\\) Image source: [Textbook] Supply Chain Management: Strategy, Planning, and Operation, (Chopra and Meindl) Above figure shows the variation in different costs as the lot size is changed. Observe that the annual holding cost increases with an increase in lot size. In contrast, the annual ordering cost declines with an increase in lot size. The material cost is independent of lot size because we have assumed the price to be fixed. The total annual cost thus first declines and then increases with an increase in lot size. From the perspective of the manager at Best Buy, the optimal lot size is one that minimizes the total cost to Best Buy. It is obtained by taking the first derivative of the total cost with respect to Q and setting it equal to 0. The optimum lot size is referred to as the economic order quantity (EOQ). It is denoted by Q* and is given by the following equation: Optimal lot size, \\(Q* = \\sqrt{\\frac{2DS}{hC}}\\)","title":"System Description"},{"location":"EOQ_est/#numerical-example","text":"Demand for the Deskpro computer at Best Buy is 1,000 units per month. Best Buy incurs a fixed order placement, transportation, and receiving cost of $4,000 each time an order is placed. Each computer costs Best Buy $500 and the retailer has a holding cost of 20 percent. Evaluate the number of computers that the store manager should order in each replenishment lot. Analysis: In this case, the store manager has the following inputs: Annual demand, \\(D = 1,000 * 12 = 12,000\\) units Order cost per lot, \\(S = 4,000\\) Unit cost per computer, \\(C = 500\\) Holding cost per year as a fraction of unit cost, \\(h = 0.2\\) Using the EOQ formula, the optimal lot size is Optimal order size = Q* = \\(\\sqrt{\\frac{2 * 12,000 * 4,000}{0.2 * 500}} = 980\\) To minimize the total cost at Best Buy, the store manager orders a lot size of 980 computers for each replenishment order. The cycle inventory is the average resulting inventory and is given by Cycle inventory = \\(\\frac{Q*}{2} = 490\\) For a lot size of Q* = 980, the store manager evaluates Number of orders per year = \\(\\frac{D} {Q*} = \\frac{12,000} {980} = 12.24\\) Annual ordering and holding cost = \\(\\frac{D} {Q*} S + (\\frac{Q*} {2}) hC = 97,980\\) Average flow time = \\(\\frac{Q*} {2D} = \\frac{490} {12,000} = 0.041\\) year \\(= 0.49\\) month Each computer thus spends 0.49 month, on average, at Best Buy before it is sold because it was purchased in a batch of 980.","title":"Numerical Example"},{"location":"EOQ_est/#implementation","text":"import simpy import numpy as np import matplotlib.pyplot as plt import SupplyNetPy.Components as scm \"\"\" Demand for the Deskpro computer at Best Buy is 1,000 units per month. Best Buy incurs a fixed order placement, transportation, and receiving cost of $4,000 each time an order is placed. Each computer costs Best Buy $500 and the retailer has a holding cost of 20 percent. Evaluate the number of computers that the store manager should order in each replenishment lot. Analysis: In this case, the store manager has the following inputs: - Annual demand, D = 1,000 * 12 = 12,000 units (approx 34 units per day) - Order cost per lot, S = 4,000 - Unit cost per computer, C = 500 - Holding cost per year as a fraction of unit cost, h = 0.2 (500*0.2 = 100 per year => 100/365 = 0.273 per day) Assumptions: - Demand is constant and deterministic - Lead time is zero Optimum Economic Order Quantity (EOQ) is determined to minimize the total cost. Total cost = Annual material cost + Annual ordering cost + Annual holding cost This is same as -> Total cost = total transportation cost + inventory cost (we'll ignore material cost since it is constant) \"\"\" D = 12000 # annual demand d = 34 # daily demand order_cost = 4000 # order cost unit_cost = 500 # unit cost holding_cost = 0.273 # holding cost per day lead_time = 0 # lead time simlen = 3650 # simulation length in days total_cost_arr = [] unsat_arr = [] print(f\"lot size \\t Inv holding cost \\t Order cost \\t Average cost(per day) \\t Unmet demand\") for lot_size in range(800,1600,10): order_interval = 365*lot_size/D env = simpy.Environment() hp_supplier = scm.Supplier(env=env, ID=\"S1\", name=\"HPComputers\", node_type=\"infinite_supplier\") bestbuy = scm.InventoryNode(env=env, ID=\"D1\", name=\"Best Buy\", node_type=\"distributor\", capacity=lot_size, initial_level=lot_size, inventory_holding_cost=holding_cost, replenishment_policy=scm.PeriodicReplenishment, product_buy_price=450, policy_param={'T':order_interval,'Q':lot_size}, product_sell_price=unit_cost) link1 = scm.Link(env=env,ID=\"l1\", source=hp_supplier, sink=bestbuy, cost=order_cost, lead_time=lambda: lead_time) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, order_quantity_model=lambda: d, demand_node=bestbuy, consume_available=True) scm.global_logger.disable_logging() # disable logging for all components env.run(until=simlen) bb_invlevels = np.array(bestbuy.inventory.instantaneous_levels) hp_sup_transportation_cost = bestbuy.stats.transportation_cost total_cost = bestbuy.stats.inventory_carry_cost + bestbuy.stats.transportation_cost total_cost_arr.append([lot_size, total_cost/simlen]) unsat_demand = demand1.stats.demand_placed[1]-demand1.stats.fulfillment_received[1] unsat_arr.append([lot_size,unsat_demand]) print(f\"{lot_size} \\t\\t {bestbuy.stats.inventory_carry_cost:.2f}\\t\\t{bestbuy.stats.transportation_cost}\\t\\t{total_cost/simlen:.2f}\\t\\t{unsat_demand:.2f}\") total_cost_arr = np.array(total_cost_arr) unsat_arr = np.array(unsat_arr) EOQ = np.argmin(total_cost_arr[:,1]) plt.figure() plt.plot(total_cost_arr[:,0], total_cost_arr[:,1],marker='.',linestyle='-') plt.plot(total_cost_arr[EOQ,0], total_cost_arr[EOQ,1],marker='o',color='red',label=f'EOQ = {total_cost_arr[EOQ,0]:.2f} with cost = {total_cost_arr[EOQ,1]:.2f}') plt.xlabel(\"lot size\") plt.ylabel(\"Average cost per day\") plt.title(\"Average cost vs lot size\") plt.legend() plt.grid() plt.show() lot size Inv holding cost Order cost Average cost(per day) Unmet demand 800 386458.80 596000 269.17 4100.00 810 390557.96 592000 269.19 4118.00 820 395049.18 584000 268.23 4140.00 830 400188.24 576000 267.45 4104.00 840 405223.18 568000 266.64 4106.00 850 409730.10 564000 266.78 4114.00 860 414937.16 556000 266.01 4118.00 870 419476.82 548000 265.06 4094.00 880 424411.62 544000 265.32 4114.00 890 429494.01 536000 264.52 4092.00 900 436224.38 532000 265.27 4094.00 910 438638.31 524000 263.74 4074.00 920 442904.09 520000 263.81 4096.00 930 448040.50 516000 264.12 4130.00 940 453707.25 508000 263.48 4108.00 950 458159.42 504000 263.61 4094.00 960 462991.62 500000 263.83 4100.00 970 468226.74 492000 263.08 4110.00 980 472987.11 488000 263.28 4098.00 990 477960.52 484000 263.55 4106.00 1000 481626.60 480000 263.46 4100.00 1010 487159.07 472000 262.78 4104.00 1020 492760.50 468000 263.22 4080.00 1030 496374.95 464000 263.12 4110.00 1040 502052.28 460000 263.58 4092.00 1050 507372.65 456000 263.94 4094.00 1060 511096.54 452000 263.86 4116.00 1070 516617.65 448000 264.28 4124.00 1080 519820.94 444000 264.06 4118.00 1090 525820.83 440000 264.61 4098.00 1100 530125.28 436000 264.69 4098.00 1110 534894.02 432000 264.90 4118.00 1120 539837.84 428000 265.16 4124.00 1130 544889.08 424000 265.45 4116.00 1140 550465.87 420000 265.88 4094.00 1150 554073.29 416000 265.77 4092.00 1160 559606.68 412000 266.19 4110.00 1170 564940.50 408000 266.56 4080.00 1180 569711.55 404000 266.77 4104.00 1190 573919.60 400000 266.83 4080.00 1200 586076.40 396000 269.06 4100.00 1210 583497.57 396000 268.36 4106.00 1220 589075.99 392000 268.79 4098.00 1230 593807.38 388000 268.99 4110.00 1240 598836.42 384000 269.27 4074.00 1250 601944.80 380000 269.03 4100.00 1260 607432.10 380000 270.53 4094.00 1270 613174.10 376000 271.01 4108.00 1280 617805.01 372000 271.18 4074.00 1290 621160.11 372000 272.10 4130.00 1300 627485.86 368000 272.74 4092.00 1310 631953.94 364000 272.86 4074.00 1320 637026.39 360000 273.16 4076.00 1330 640737.93 360000 274.17 4094.00 1340 646993.21 356000 274.79 4092.00 1350 652581.25 352000 275.23 4076.00 1360 655767.11 352000 276.10 4114.00 1370 661892.46 348000 276.68 4094.00 1380 663762.51 344000 276.10 4060.00 1390 671198.93 344000 278.14 4118.00 1400 676112.71 340000 278.39 4080.00 1410 679131.28 340000 279.21 4114.00 1420 685778.46 336000 279.94 4106.00 1430 687048.38 332000 279.19 4084.00 1440 695202.14 332000 281.43 4104.00 1450 700610.60 328000 281.81 4078.00 1460 704462.53 328000 282.87 4108.00 1470 710215.40 324000 283.35 4078.00 1480 716061.53 324000 284.95 4118.00 1490 720095.10 320000 284.96 4084.00 1500 724323.60 316000 285.02 4100.00 1510 729269.91 316000 286.38 4096.00 1520 732658.29 312000 286.21 4078.00 1530 739202.82 312000 288.00 4080.00 1540 742057.54 308000 287.69 4058.00 1550 749044.53 308000 289.60 4104.00 1560 752204.00 304000 289.37 4078.00 1570 759076.52 304000 291.25 4100.00 1580 762089.05 300000 290.98 4070.00 1590 768415.08 300000 292.72 4102.00","title":"Implementation"},{"location":"EOQ_est/#results","text":"We conducted multiple simulations with varying lengths (1000, 2000, 3000, 4000, 5000, and 6000). Our findings indicated that when the simulation length is less than 4000, the Economic Order Quantity (EOQ) is approximately 1010. Additionally, we found that the results improve as the simulation length increases.","title":"Results"},{"location":"about/","text":"About SupplyNetPy SupplyNetPy is an open-source Python library designed specifically for modeling, simulating, and analyzing supply chain networks and inventory systems. The library features supply chain-specific components to model arbitrary supply chain networks easily. It is built on Python\u2019s SimPy discrete-event simulation framework and provides a flexible and extensible toolkit for researchers, engineers, and practitioners in operations, logistics, and supply chain management. Purpose Construct detailed supply chain models, including suppliers, manufacturers, distributors, retailers, and demand points. Simulate inventory dynamics by modeling stock levels, replenishment cycles, lead times, supplier selection, costs, and disruptions. Test and compare inventory replenishment policies and supplier selection strategies. Analyze performance through generated logs and computed metrics such as throughput, revenue, stockouts, costs, and profit. Features Modular architecture : Build arbitrarily complex, multi-echelon supply chain networks by assembling built-in components. Discrete-event simulation : High-fidelity event-driven simulation powered by SimPy. Inventory models : Support for multiple replenishment policies: (s, S) replenishment (s, S) with safety stock Reorder point\u2013quantity (RQ) Reorder point\u2013quantity (RQ) with safety stock Periodic review (Q, T) Periodic review (Q, T) with safety stock Flexible lead times : Define deterministic or stochastic lead times and transportation costs. Simple API : Build and simulate supply chain models using clear Python code. Performance tracking : Automatically generate logs and compute supply chain performance indicators. Architecture SupplyNetPy provides core components for supply chain modeling: Node classes : Node , Supplier , Manufacturer , InventoryNode , Demand . Link : Represents transportation connections between nodes, with configurable cost and lead time Inventory : Tracks stock levels and related operations at each node. Product and RawMaterial : Define supply chain items. InventoryReplenishment : Abstract base for implementing replenishment policies: SSReplenishment : order up to max when stock drops below s. RQReplenishment : fixed quantity reorder when stock drops below a threshold. PeriodicReplenishment : replenish at regular time intervals. SupplierSelectionPolicy : Abstract base for implementing supplier selection strategies: SelectFirst : Selects the first supplier. SelectAvailable : Selects the first available supplier. SelectCheapest : Selects the supplier with the lowest transportation cost. SelectFastest : Selects the supplier with the shortest lead time. Statistics and InfoMixin : Provide built-in tools for summarizing and reporting system behavior and object-specific metrics. Why SupplyNetPy? Open-source and extensible : Designed for researchers, students, and professionals; easy to extend or integrate into larger systems. Specialized for supply chain dynamics : Specifically designed and built for supply chain simulation. Reproducible and customizable : Enables experimentation with fully configurable models, suppliers behaviours and stochastic elements. Authors Tushar Lone Neha Karanjkar Lekshmi P License License","title":"About"},{"location":"about/#about-supplynetpy","text":"SupplyNetPy is an open-source Python library designed specifically for modeling, simulating, and analyzing supply chain networks and inventory systems. The library features supply chain-specific components to model arbitrary supply chain networks easily. It is built on Python\u2019s SimPy discrete-event simulation framework and provides a flexible and extensible toolkit for researchers, engineers, and practitioners in operations, logistics, and supply chain management.","title":"About SupplyNetPy"},{"location":"about/#purpose","text":"Construct detailed supply chain models, including suppliers, manufacturers, distributors, retailers, and demand points. Simulate inventory dynamics by modeling stock levels, replenishment cycles, lead times, supplier selection, costs, and disruptions. Test and compare inventory replenishment policies and supplier selection strategies. Analyze performance through generated logs and computed metrics such as throughput, revenue, stockouts, costs, and profit.","title":"Purpose"},{"location":"about/#features","text":"Modular architecture : Build arbitrarily complex, multi-echelon supply chain networks by assembling built-in components. Discrete-event simulation : High-fidelity event-driven simulation powered by SimPy. Inventory models : Support for multiple replenishment policies: (s, S) replenishment (s, S) with safety stock Reorder point\u2013quantity (RQ) Reorder point\u2013quantity (RQ) with safety stock Periodic review (Q, T) Periodic review (Q, T) with safety stock Flexible lead times : Define deterministic or stochastic lead times and transportation costs. Simple API : Build and simulate supply chain models using clear Python code. Performance tracking : Automatically generate logs and compute supply chain performance indicators.","title":"Features"},{"location":"about/#architecture","text":"SupplyNetPy provides core components for supply chain modeling: Node classes : Node , Supplier , Manufacturer , InventoryNode , Demand . Link : Represents transportation connections between nodes, with configurable cost and lead time Inventory : Tracks stock levels and related operations at each node. Product and RawMaterial : Define supply chain items. InventoryReplenishment : Abstract base for implementing replenishment policies: SSReplenishment : order up to max when stock drops below s. RQReplenishment : fixed quantity reorder when stock drops below a threshold. PeriodicReplenishment : replenish at regular time intervals. SupplierSelectionPolicy : Abstract base for implementing supplier selection strategies: SelectFirst : Selects the first supplier. SelectAvailable : Selects the first available supplier. SelectCheapest : Selects the supplier with the lowest transportation cost. SelectFastest : Selects the supplier with the shortest lead time. Statistics and InfoMixin : Provide built-in tools for summarizing and reporting system behavior and object-specific metrics.","title":"Architecture"},{"location":"about/#why-supplynetpy","text":"Open-source and extensible : Designed for researchers, students, and professionals; easy to extend or integrate into larger systems. Specialized for supply chain dynamics : Specifically designed and built for supply chain simulation. Reproducible and customizable : Enables experimentation with fully configurable models, suppliers behaviours and stochastic elements.","title":"Why SupplyNetPy?"},{"location":"about/#authors","text":"Tushar Lone Neha Karanjkar Lekshmi P","title":"Authors"},{"location":"about/#license","text":"License","title":"License"},{"location":"case_study_pharma/","text":"Find the Google Colab notebook for this example here . Pharmacy Supply Chain This study is from a publication 'Improving Simulation Optimization Run Time When Solving For Periodic Review Inventory Policies in A Pharmacy' , read it here . This study uses the simulation-based optimization (SBO) method to find the optimum values of replenishment policy parameters (s, S) to minimize the overall cost of the pharmacy supply chain. In this example, we aim to understand the supply chain network system described by the authors and to use SupplyNetPy to implement it and replicate the results. This exercise allows us to evaluate the complexity of reconstructing a specific system with SupplyNetPy and to validate the library. System Description It is a single echelon supply chain: (A distributor: Hospital Pharmacy, and a supplier: Pharmaceutical Manufacturing Facility) A distributor facing stochastic demand is connected to an infinite supplier. The supplier can be disrupted with probability = 0.001 at given day t. The distributor replenishment policy: (s,S) The product is perishable with shelf life of 90 days. The authors model and simulate the system to find optimum values of policy parameters (s,S) that minimizes total expected cost per day Inventory Type: Perishable Inventory position (level at given time t) = inventory on hand + inventory en route Replenishment Policy: (s,S) When level falls below s, order is placed for (S - current inventory position) units Review period = 1 day (monitor inventory everyday) H = Inventory at hand H' = Inventory at hand that expires at the end of the day t P = Inventory position = H + inventory en route This flowchart illustrates the order and sequence of events that take place at the pharmacy. ( Image source ) Algorithm: Process flow of Perishable Inventory Begin day t 1. Order arrive at the Pharmacy 2. Update Inventory Levels (H) 3. Satisfy demand based on Inventory Levels 3.1. If (d>H): - demand Satisfied = H - Shortage = d-H - Waste = 0 3.2. Else: - demand Satisfied = d - Shortage = 0 - Waste = max{0,H'-d} 4. Discard Expired Drugs 5. Update Inventory Levels (H) 5.1. Is (s>P) and (Supplier not Disrupted): - Place order for (S-P) 5.2. Else: - Do not place order 6. End of the day t Optimization Objective: Minimize Expected Cost per day Costs of interest are shortage, waste, holding and ordering Assumptions All drugs that arrive in the same month come from the same production batch and have same end of the month expiration date. Hence drugs are only discarded at the end of the month. The inventory on-hand is know each day. Estimated days until inventory expires is known each day. Lead time is deterministic and +ve. The Order placed at the end of the day (t-1), and arrives at the begining of the day t. Demand is stochastic. Supply uncertainty is due to disruptions (these two are independent of each other) All demand that is not met is lost. First in first out protocol is followed when serving orders. System Configuration T = number of days (360 days) l = deterministic lead time (6 days) e = shelf life of the drugs (months) (3 months) R = number of simulation replication (5000) b = shortage cost (5 units) z = waste cost (1 units) h = holding cost (0.001 units) o = ordering cost (0.5 units) dt = demand on day t (stochastic) (Poission 25/day) yt = binary variable for supply disruption status on day t (yt=0 disrupted, yt=1 available) (stochastic) (p=0.01) disrupt_time ~ Geom(p=0.01) recovery_time ~ Geom(p=1/30) Implementation import simpy import numpy as np import matplotlib.pyplot as plt from matplotlib.pyplot import figure import SupplyNetPy.Components as scm class Distributions: \"\"\" Class to generate random numbers for demand (order quantity) and order arrival arrival times. Parameters: mu (float): Mean of the exponential distribution for order arrival times. lam (float): Lambda parameter of the Poisson distribution for demand (order quantity). \"\"\" def __init__(self,mu=1,lam=1,p=0.01): self.mu = mu self.lam = lam self.p = p def poisson_demand(self): return np.random.poisson(self.lam) def expo_arrival(self): return np.random.exponential(self.mu) def geometric(self): return np.random.geometric(self.p,1)[0] def manufacturer_date_cal(time_now): \"\"\"Calculate manufacturing date rounded down to the nearest month.\"\"\" return time_now - (time_now % 30) # Global parameters T = 360 #number of days (360 days) l = 6 #deterministic lead time (6 days) e = 90 #shelf life of the drugs (months) (3 months) R = 5000 #number of simulation replication (5000) b = 5 #shortage cost (5 units) z = 1 #waste cost (1 units) h = 0.001 #holding cost (0.001 units) o = 0.5 #ordering cost (0.5 units) dt = 25 #demand on day t (stochastic) (Poission 25/day) # yt = binary variable for supply disruption status on day t (yt=0 disrupted, yt=1 available) (stochastic) (p=0.01) yt_p = 0.01 # ~ Geometric(p=0.01), sampled from Geometric distribution with probability p = 0.01 yt_r = 1/30 # node recovery time ~ Geometric(p=1/30), sampled from Geometric distribution with probability p = 1/30 = 0.033 price = 7 # unit cost of drug def setup_simulation(env, s, S, ini_level, st, disrupt_time, recovery_time): \"\"\"Setup environment, supplier, distributor, link, and demand process.\"\"\" supplier = scm.Supplier(env, \"S1\", \"Supplier 1\", \"infinite_supplier\", node_disrupt_time=disrupt_time.geometric, node_recovery_time=recovery_time.geometric) distributor = scm.InventoryNode(env, \"D1\", \"Distributor 1\", \"distributor\", capacity=float('inf'), initial_level=ini_level, inventory_holding_cost=h, inventory_type=\"perishable\", manufacture_date=manufacturer_date_cal, shelf_life=e, replenishment_policy=scm.SSReplenishment, policy_param={'s': s, 'S': S}, product_buy_price=0, product_sell_price=price) link = scm.Link(env, \"l1\", supplier, distributor, cost=o, lead_time=lambda: l) demand = scm.Demand(env, \"d1\", \"demand 1\", order_arrival_model=lambda: 1, order_quantity_model=st.poisson_demand, demand_node=distributor) return supplier, distributor, demand, link def single_sim_run(S, s, ini_level, logging=True): \"\"\"Run a single simulation instance and return expected cost.\"\"\" env = simpy.Environment() st = Distributions(mu=1, lam=dt) disrupt_time = Distributions(p=yt_p) recovery_time = Distributions(p=yt_r) supplier, distributor, demand, link = setup_simulation(env, s, S, ini_level, st, disrupt_time, recovery_time) pharma_chain = scm.create_sc_net(env=env, nodes=[supplier, distributor], links=[link], demands=[demand]) pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=30,logging=logging) supplier.stats.reset() distributor.stats.reset() demand.stats.reset() pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=T,logging=logging) shortage = distributor.stats.orders_shortage[1] waste = distributor.stats.inventory_waste holding = distributor.stats.inventory_carry_cost transport = distributor.stats.transportation_cost total_cost = (shortage * b + waste * z + holding + transport) norm_cost = total_cost / ((T - 30) * (b + z + h + o)) * price if logging: print(\"Shortage cost:\", shortage * b) print(\"Waste cost:\", waste * z) print(\"Holding cost:\", holding) print(\"Transportation cost:\", transport) return norm_cost def run_for_s(s_low, s_high, s_step, capacity, ini_level, num_replications): \"\"\"Run simulations across reorder point values and report results.\"\"\" results = [] st = Distributions(mu=1, lam=dt) disrupt_time = Distributions(p=yt_p) recovery_time = Distributions(p=yt_r) #print(\"reorder_point, exp_cost_per_day, std, std_err\") for s in range(s_low, s_high, s_step): costs = [] for _ in range(num_replications): env = simpy.Environment() supplier, distributor, demand, link = setup_simulation(env, s, capacity, ini_level, st, disrupt_time, recovery_time) pharma_chain = scm.create_sc_net(env=env, nodes=[supplier, distributor], links=[link], demands=[demand]) pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=30,logging=False) supplier.stats.reset() distributor.stats.reset() demand.stats.reset() pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=T,logging=False) shortage = distributor.stats.orders_shortage[1] waste = distributor.stats.inventory_waste holding = distributor.stats.inventory_carry_cost transport = distributor.stats.transportation_cost total_cost = (shortage * b + waste * z + holding + transport) norm_cost = total_cost / ((T - 30) * (b + z + h + o)) * price costs.append(norm_cost) mean_cost = np.mean(costs) std_dev = np.std(costs) std_err = std_dev / np.sqrt(num_replications) #print(f\"[{s}, {mean_cost}, {std_dev}, {std_err}]\") results.append((s, mean_cost, std_dev, std_err)) return results # Parameters for the simulation s_low = 100 s_high = 5000 s_step = 100 capacity = 5000 ini_level = 5000 num_rep = 1000 Assessing Time Complexity First, let's evaluate the time complexity in relation to the number of simulation runs (replications) (R) in order to estimate the expected costs. The code estimates the execution time for R simulations, where R takes on the values of 1000, 2000, 3000, 4000, and 5000. import time stats = [] scm.global_logger.disable_logging() # enable logging for replications in [1000, 2000, 3000, 4000, 5000]: exp_cost_arr = [] start_time = time.time() for rep in range(0, replications): exp_cost_arr.append(single_sim_run(s=2000,S=5000,ini_level=5000,logging=False)) exp_cost_arr = np.array(exp_cost_arr) exe_time = time.time() - start_time print(f\"R ={replications}, exe_time:{exe_time} sec, mean:{np.mean(exp_cost_arr)}, std:{np.std(exp_cost_arr)}, std_err:{np.std(exp_cost_arr)/np.sqrt(R)}\") stats.append((replications, exe_time, np.mean(exp_cost_arr), np.std(exp_cost_arr), np.std(exp_cost_arr)/np.sqrt(replications))) R =1000, exe_time:22.119476795196533 sec, mean:51.75029532053344, std:23.668711396825312, std_err:0.33472612661285 R =2000, exe_time:45.451146602630615 sec, mean:51.80183997566808, std:23.633314688276155, std_err:0.33422554155991413 R =3000, exe_time:68.95947742462158 sec, mean:51.01044921449537, std:23.62288667057547, std_err:0.3340780671193043 R =4000, exe_time:86.83561849594116 sec, mean:51.584926030610674, std:23.706247962166834, std_err:0.3352569738107588 R =5000, exe_time:106.06455659866333 sec, mean:52.27106894743466, std:23.863645906143574, std_err:0.3374829168813743 Estimating Confidence Interval To ensure the estimation error is reasonable, we estimate the expected costs for the replenishment policy setting \\(S = 5000\\) and variable \\(s\\) with \\(R = 1000\\) simulation runs and plot the confidence intervals. exp_cost_per_day = run_for_s(s_low=s_low,s_high=s_high,s_step=s_step,capacity=capacity,ini_level=ini_level,num_replications=num_rep) exp_cost_per_day = np.array(exp_cost_per_day) figure(figsize=(25, 10), dpi=60) plt.plot(exp_cost_per_day[:,0], exp_cost_per_day[:,1],marker='o', linestyle='-', color='b', label='S=5000') plt.fill_between(exp_cost_per_day[:,0], exp_cost_per_day[:,1]-2*exp_cost_per_day[:,3], exp_cost_per_day[:,1]+2*exp_cost_per_day[:,3],alpha=0.2, color='b', label='95% CI') plt.xlabel('Reorder Point (s)') plt.ylabel('Expected Cost per Day') plt.xticks(np.arange(s_low, s_high, 200)) plt.title('Expected Cost per Day vs Reorder Point (s)') plt.legend() plt.grid() plt.show() Running the Model with Varying (S, s) To determine the optimal values of the parameters \\(S\\) and \\(s\\) , we run the model with different settings for both parameters. The parameter \\(S\\) takes on values of 1000, 2000, 3000, 4000, and 5000. For each value of \\(S\\) , the parameter \\(s\\) is set to values ranging from 100 up to \\(S\\) . The results obtained from these runs are then plotted and compared with the findings reported by the authors. Below, we present both sets of plots for comparison. exp_cost_per_day = run_for_s(s_low=s_low, s_high=5000, s_step=s_step, capacity=5000, ini_level=5000, num_replications=num_rep) exp_cost_per_day = np.array(exp_cost_per_day) exp_cost_per_day2 = run_for_s(s_low=s_low,s_high=4000,s_step=s_step,capacity=4000,ini_level=4000,num_replications=num_rep) exp_cost_per_day2 = np.array(exp_cost_per_day2) exp_cost_per_day3 = run_for_s(s_low=s_low,s_high=3000,s_step=s_step,capacity=3000,ini_level=3000,num_replications=num_rep) exp_cost_per_day3 = np.array(exp_cost_per_day3) exp_cost_per_day4 = run_for_s(s_low=s_low,s_high=2000,s_step=s_step,capacity=2000,ini_level=2000,num_replications=num_rep) exp_cost_per_day4 = np.array(exp_cost_per_day4) exp_cost_per_day5 = run_for_s(s_low=s_low,s_high=1000,s_step=s_step,capacity=1000,ini_level=1000,num_replications=num_rep) exp_cost_per_day5 = np.array(exp_cost_per_day5) figure(figsize=(25, 10), dpi=60) plt.plot(exp_cost_per_day[:,0], exp_cost_per_day[:,1],marker='o', linestyle='-', color='m', label='S=5000') plt.plot(exp_cost_per_day2[:,0], exp_cost_per_day2[:,1],marker='o', linestyle='-', color='b', label='S=4000') plt.plot(exp_cost_per_day3[:,0], exp_cost_per_day3[:,1],marker='o', linestyle='-', color='g', label='S=3000') plt.plot(exp_cost_per_day4[:,0], exp_cost_per_day4[:,1],marker='o', linestyle='-', color='c', label='S=2000') plt.plot(exp_cost_per_day5[:,0], exp_cost_per_day5[:,1],marker='o', linestyle='-', color='r', label='S=1000') plt.xticks(np.arange(s_low, s_high, 200)) plt.xlabel('Reorder Point (s)') plt.ylabel('Expected Cost per Day') plt.title('Expected Cost per Day vs Reorder Point (s)') plt.legend() plt.grid() plt.show() The following plot displays the results obtained by the authors. Image source: link .","title":"Pharmacy Supply Chain"},{"location":"case_study_pharma/#pharmacy-supply-chain","text":"This study is from a publication 'Improving Simulation Optimization Run Time When Solving For Periodic Review Inventory Policies in A Pharmacy' , read it here . This study uses the simulation-based optimization (SBO) method to find the optimum values of replenishment policy parameters (s, S) to minimize the overall cost of the pharmacy supply chain. In this example, we aim to understand the supply chain network system described by the authors and to use SupplyNetPy to implement it and replicate the results. This exercise allows us to evaluate the complexity of reconstructing a specific system with SupplyNetPy and to validate the library.","title":"Pharmacy Supply Chain"},{"location":"case_study_pharma/#system-description","text":"It is a single echelon supply chain: (A distributor: Hospital Pharmacy, and a supplier: Pharmaceutical Manufacturing Facility) A distributor facing stochastic demand is connected to an infinite supplier. The supplier can be disrupted with probability = 0.001 at given day t. The distributor replenishment policy: (s,S) The product is perishable with shelf life of 90 days. The authors model and simulate the system to find optimum values of policy parameters (s,S) that minimizes total expected cost per day Inventory Type: Perishable Inventory position (level at given time t) = inventory on hand + inventory en route Replenishment Policy: (s,S) When level falls below s, order is placed for (S - current inventory position) units Review period = 1 day (monitor inventory everyday) H = Inventory at hand H' = Inventory at hand that expires at the end of the day t P = Inventory position = H + inventory en route This flowchart illustrates the order and sequence of events that take place at the pharmacy. ( Image source )","title":"System Description"},{"location":"case_study_pharma/#algorithm-process-flow-of-perishable-inventory","text":"Begin day t 1. Order arrive at the Pharmacy 2. Update Inventory Levels (H) 3. Satisfy demand based on Inventory Levels 3.1. If (d>H): - demand Satisfied = H - Shortage = d-H - Waste = 0 3.2. Else: - demand Satisfied = d - Shortage = 0 - Waste = max{0,H'-d} 4. Discard Expired Drugs 5. Update Inventory Levels (H) 5.1. Is (s>P) and (Supplier not Disrupted): - Place order for (S-P) 5.2. Else: - Do not place order 6. End of the day t Optimization Objective: Minimize Expected Cost per day Costs of interest are shortage, waste, holding and ordering","title":"Algorithm: Process flow of Perishable Inventory"},{"location":"case_study_pharma/#assumptions","text":"All drugs that arrive in the same month come from the same production batch and have same end of the month expiration date. Hence drugs are only discarded at the end of the month. The inventory on-hand is know each day. Estimated days until inventory expires is known each day. Lead time is deterministic and +ve. The Order placed at the end of the day (t-1), and arrives at the begining of the day t. Demand is stochastic. Supply uncertainty is due to disruptions (these two are independent of each other) All demand that is not met is lost. First in first out protocol is followed when serving orders.","title":"Assumptions"},{"location":"case_study_pharma/#system-configuration","text":"T = number of days (360 days) l = deterministic lead time (6 days) e = shelf life of the drugs (months) (3 months) R = number of simulation replication (5000) b = shortage cost (5 units) z = waste cost (1 units) h = holding cost (0.001 units) o = ordering cost (0.5 units) dt = demand on day t (stochastic) (Poission 25/day) yt = binary variable for supply disruption status on day t (yt=0 disrupted, yt=1 available) (stochastic) (p=0.01) disrupt_time ~ Geom(p=0.01) recovery_time ~ Geom(p=1/30)","title":"System Configuration"},{"location":"case_study_pharma/#implementation","text":"import simpy import numpy as np import matplotlib.pyplot as plt from matplotlib.pyplot import figure import SupplyNetPy.Components as scm class Distributions: \"\"\" Class to generate random numbers for demand (order quantity) and order arrival arrival times. Parameters: mu (float): Mean of the exponential distribution for order arrival times. lam (float): Lambda parameter of the Poisson distribution for demand (order quantity). \"\"\" def __init__(self,mu=1,lam=1,p=0.01): self.mu = mu self.lam = lam self.p = p def poisson_demand(self): return np.random.poisson(self.lam) def expo_arrival(self): return np.random.exponential(self.mu) def geometric(self): return np.random.geometric(self.p,1)[0] def manufacturer_date_cal(time_now): \"\"\"Calculate manufacturing date rounded down to the nearest month.\"\"\" return time_now - (time_now % 30) # Global parameters T = 360 #number of days (360 days) l = 6 #deterministic lead time (6 days) e = 90 #shelf life of the drugs (months) (3 months) R = 5000 #number of simulation replication (5000) b = 5 #shortage cost (5 units) z = 1 #waste cost (1 units) h = 0.001 #holding cost (0.001 units) o = 0.5 #ordering cost (0.5 units) dt = 25 #demand on day t (stochastic) (Poission 25/day) # yt = binary variable for supply disruption status on day t (yt=0 disrupted, yt=1 available) (stochastic) (p=0.01) yt_p = 0.01 # ~ Geometric(p=0.01), sampled from Geometric distribution with probability p = 0.01 yt_r = 1/30 # node recovery time ~ Geometric(p=1/30), sampled from Geometric distribution with probability p = 1/30 = 0.033 price = 7 # unit cost of drug def setup_simulation(env, s, S, ini_level, st, disrupt_time, recovery_time): \"\"\"Setup environment, supplier, distributor, link, and demand process.\"\"\" supplier = scm.Supplier(env, \"S1\", \"Supplier 1\", \"infinite_supplier\", node_disrupt_time=disrupt_time.geometric, node_recovery_time=recovery_time.geometric) distributor = scm.InventoryNode(env, \"D1\", \"Distributor 1\", \"distributor\", capacity=float('inf'), initial_level=ini_level, inventory_holding_cost=h, inventory_type=\"perishable\", manufacture_date=manufacturer_date_cal, shelf_life=e, replenishment_policy=scm.SSReplenishment, policy_param={'s': s, 'S': S}, product_buy_price=0, product_sell_price=price) link = scm.Link(env, \"l1\", supplier, distributor, cost=o, lead_time=lambda: l) demand = scm.Demand(env, \"d1\", \"demand 1\", order_arrival_model=lambda: 1, order_quantity_model=st.poisson_demand, demand_node=distributor) return supplier, distributor, demand, link def single_sim_run(S, s, ini_level, logging=True): \"\"\"Run a single simulation instance and return expected cost.\"\"\" env = simpy.Environment() st = Distributions(mu=1, lam=dt) disrupt_time = Distributions(p=yt_p) recovery_time = Distributions(p=yt_r) supplier, distributor, demand, link = setup_simulation(env, s, S, ini_level, st, disrupt_time, recovery_time) pharma_chain = scm.create_sc_net(env=env, nodes=[supplier, distributor], links=[link], demands=[demand]) pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=30,logging=logging) supplier.stats.reset() distributor.stats.reset() demand.stats.reset() pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=T,logging=logging) shortage = distributor.stats.orders_shortage[1] waste = distributor.stats.inventory_waste holding = distributor.stats.inventory_carry_cost transport = distributor.stats.transportation_cost total_cost = (shortage * b + waste * z + holding + transport) norm_cost = total_cost / ((T - 30) * (b + z + h + o)) * price if logging: print(\"Shortage cost:\", shortage * b) print(\"Waste cost:\", waste * z) print(\"Holding cost:\", holding) print(\"Transportation cost:\", transport) return norm_cost def run_for_s(s_low, s_high, s_step, capacity, ini_level, num_replications): \"\"\"Run simulations across reorder point values and report results.\"\"\" results = [] st = Distributions(mu=1, lam=dt) disrupt_time = Distributions(p=yt_p) recovery_time = Distributions(p=yt_r) #print(\"reorder_point, exp_cost_per_day, std, std_err\") for s in range(s_low, s_high, s_step): costs = [] for _ in range(num_replications): env = simpy.Environment() supplier, distributor, demand, link = setup_simulation(env, s, capacity, ini_level, st, disrupt_time, recovery_time) pharma_chain = scm.create_sc_net(env=env, nodes=[supplier, distributor], links=[link], demands=[demand]) pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=30,logging=False) supplier.stats.reset() distributor.stats.reset() demand.stats.reset() pharma_chain = scm.simulate_sc_net(pharma_chain,sim_time=T,logging=False) shortage = distributor.stats.orders_shortage[1] waste = distributor.stats.inventory_waste holding = distributor.stats.inventory_carry_cost transport = distributor.stats.transportation_cost total_cost = (shortage * b + waste * z + holding + transport) norm_cost = total_cost / ((T - 30) * (b + z + h + o)) * price costs.append(norm_cost) mean_cost = np.mean(costs) std_dev = np.std(costs) std_err = std_dev / np.sqrt(num_replications) #print(f\"[{s}, {mean_cost}, {std_dev}, {std_err}]\") results.append((s, mean_cost, std_dev, std_err)) return results # Parameters for the simulation s_low = 100 s_high = 5000 s_step = 100 capacity = 5000 ini_level = 5000 num_rep = 1000","title":"Implementation"},{"location":"case_study_pharma/#assessing-time-complexity","text":"First, let's evaluate the time complexity in relation to the number of simulation runs (replications) (R) in order to estimate the expected costs. The code estimates the execution time for R simulations, where R takes on the values of 1000, 2000, 3000, 4000, and 5000. import time stats = [] scm.global_logger.disable_logging() # enable logging for replications in [1000, 2000, 3000, 4000, 5000]: exp_cost_arr = [] start_time = time.time() for rep in range(0, replications): exp_cost_arr.append(single_sim_run(s=2000,S=5000,ini_level=5000,logging=False)) exp_cost_arr = np.array(exp_cost_arr) exe_time = time.time() - start_time print(f\"R ={replications}, exe_time:{exe_time} sec, mean:{np.mean(exp_cost_arr)}, std:{np.std(exp_cost_arr)}, std_err:{np.std(exp_cost_arr)/np.sqrt(R)}\") stats.append((replications, exe_time, np.mean(exp_cost_arr), np.std(exp_cost_arr), np.std(exp_cost_arr)/np.sqrt(replications))) R =1000, exe_time:22.119476795196533 sec, mean:51.75029532053344, std:23.668711396825312, std_err:0.33472612661285 R =2000, exe_time:45.451146602630615 sec, mean:51.80183997566808, std:23.633314688276155, std_err:0.33422554155991413 R =3000, exe_time:68.95947742462158 sec, mean:51.01044921449537, std:23.62288667057547, std_err:0.3340780671193043 R =4000, exe_time:86.83561849594116 sec, mean:51.584926030610674, std:23.706247962166834, std_err:0.3352569738107588 R =5000, exe_time:106.06455659866333 sec, mean:52.27106894743466, std:23.863645906143574, std_err:0.3374829168813743","title":"Assessing Time Complexity"},{"location":"case_study_pharma/#estimating-confidence-interval","text":"To ensure the estimation error is reasonable, we estimate the expected costs for the replenishment policy setting \\(S = 5000\\) and variable \\(s\\) with \\(R = 1000\\) simulation runs and plot the confidence intervals. exp_cost_per_day = run_for_s(s_low=s_low,s_high=s_high,s_step=s_step,capacity=capacity,ini_level=ini_level,num_replications=num_rep) exp_cost_per_day = np.array(exp_cost_per_day) figure(figsize=(25, 10), dpi=60) plt.plot(exp_cost_per_day[:,0], exp_cost_per_day[:,1],marker='o', linestyle='-', color='b', label='S=5000') plt.fill_between(exp_cost_per_day[:,0], exp_cost_per_day[:,1]-2*exp_cost_per_day[:,3], exp_cost_per_day[:,1]+2*exp_cost_per_day[:,3],alpha=0.2, color='b', label='95% CI') plt.xlabel('Reorder Point (s)') plt.ylabel('Expected Cost per Day') plt.xticks(np.arange(s_low, s_high, 200)) plt.title('Expected Cost per Day vs Reorder Point (s)') plt.legend() plt.grid() plt.show()","title":"Estimating Confidence Interval"},{"location":"case_study_pharma/#running-the-model-with-varying-s-s","text":"To determine the optimal values of the parameters \\(S\\) and \\(s\\) , we run the model with different settings for both parameters. The parameter \\(S\\) takes on values of 1000, 2000, 3000, 4000, and 5000. For each value of \\(S\\) , the parameter \\(s\\) is set to values ranging from 100 up to \\(S\\) . The results obtained from these runs are then plotted and compared with the findings reported by the authors. Below, we present both sets of plots for comparison. exp_cost_per_day = run_for_s(s_low=s_low, s_high=5000, s_step=s_step, capacity=5000, ini_level=5000, num_replications=num_rep) exp_cost_per_day = np.array(exp_cost_per_day) exp_cost_per_day2 = run_for_s(s_low=s_low,s_high=4000,s_step=s_step,capacity=4000,ini_level=4000,num_replications=num_rep) exp_cost_per_day2 = np.array(exp_cost_per_day2) exp_cost_per_day3 = run_for_s(s_low=s_low,s_high=3000,s_step=s_step,capacity=3000,ini_level=3000,num_replications=num_rep) exp_cost_per_day3 = np.array(exp_cost_per_day3) exp_cost_per_day4 = run_for_s(s_low=s_low,s_high=2000,s_step=s_step,capacity=2000,ini_level=2000,num_replications=num_rep) exp_cost_per_day4 = np.array(exp_cost_per_day4) exp_cost_per_day5 = run_for_s(s_low=s_low,s_high=1000,s_step=s_step,capacity=1000,ini_level=1000,num_replications=num_rep) exp_cost_per_day5 = np.array(exp_cost_per_day5) figure(figsize=(25, 10), dpi=60) plt.plot(exp_cost_per_day[:,0], exp_cost_per_day[:,1],marker='o', linestyle='-', color='m', label='S=5000') plt.plot(exp_cost_per_day2[:,0], exp_cost_per_day2[:,1],marker='o', linestyle='-', color='b', label='S=4000') plt.plot(exp_cost_per_day3[:,0], exp_cost_per_day3[:,1],marker='o', linestyle='-', color='g', label='S=3000') plt.plot(exp_cost_per_day4[:,0], exp_cost_per_day4[:,1],marker='o', linestyle='-', color='c', label='S=2000') plt.plot(exp_cost_per_day5[:,0], exp_cost_per_day5[:,1],marker='o', linestyle='-', color='r', label='S=1000') plt.xticks(np.arange(s_low, s_high, 200)) plt.xlabel('Reorder Point (s)') plt.ylabel('Expected Cost per Day') plt.title('Expected Cost per Day vs Reorder Point (s)') plt.legend() plt.grid() plt.show() The following plot displays the results obtained by the authors. Image source: link .","title":"Running the Model with Varying (S, s)"},{"location":"example-complex/","text":"Complex Supply Chain Network This example demonstrates how to build and simulate a multi\u2011echelon, hybrid supply chain with different replenishment policies in SupplyNetPy . Goals Creating a network with multiple raw materials, suppliers, a manufacturer, two distributors, and several retailers. Mix replenishment policies (`SS`, `RQ`, `Periodic`). Include hybrid connections (ordering from multiple distributors). Key Concepts Used Products, Raw Materials : Class Product used to create a product, Bread, with some shelf life, RawMaterial is used to create raw materials (dough, sugar, yeast) Nodes : Clasees Supplier , Manufacturer , InventoryNode are used to create suppliers, bakery (factory), distributors, and retailers (cake shops). Links : Class Link is used to link different nodes in the network Policies : SSReplenishment : order up to S when inventory <= s RQReplenishment : reorder point R , fixed order quantity Q PeriodicReplenishment : review every T , order Q . Perishability : inventory_type for all nodes is perishable , and parameter shelf_life is passed. Full Example This script constructs a hybrid network with two distributors and five retailers, then runs a short simulation. import SupplyNetPy.Components as scm import simpy import numpy as np class Distributions: def __init__(self, lam=5, mu=5, low=1, high=10): self.lam = lam self.mu = mu self.low = low self.high = high def poisson_arrival(self): return np.random.exponential(scale=1/self.lam) def uniform_quantity(self): return int(np.random.uniform(low=self.low, high=self.high)) env = simpy.Environment() # ------------------- Raw Materials ------------------- flour = scm.RawMaterial(ID='flourk11', name='Flour', extraction_quantity=50, extraction_time=1, mining_cost=10, cost=2.5) sugar = scm.RawMaterial(ID='sugark21', name='Sugar', extraction_quantity=30, extraction_time=1, mining_cost=8, cost=1.4) yeast = scm.RawMaterial(ID='yeast31', name='Yeast', extraction_quantity=20, extraction_time=1, mining_cost=3, cost=0.2) # ------------------- Suppliers ------------------- flour_mill = scm.Supplier(env=env, ID='fmill', name='Flour Mill', node_type='infinite_supplier', raw_material=flour, logging=False) sugar_factory = scm.Supplier(env=env, ID='sfact', name='Sugar Factory', node_type='infinite_supplier', raw_material=sugar, logging=False) yeast_factory = scm.Supplier(env=env, ID='yfact', name='Yeast Factory', node_type='infinite_supplier', raw_material=yeast, logging=False) # ------------------- Manufacturer ------------------- bread = scm.Product(ID='soft_regular11', name='Bread', manufacturing_cost=10, manufacturing_time=1, sell_price=40, raw_materials=[(flour, 30), (sugar, 15), (yeast, 15)], batch_size=300) bakery = scm.Manufacturer(env=env, ID='bakery', name='Bakery', product=bread, shelf_life=5, inventory_type='perishable', capacity=500, initial_level=100, inventory_holding_cost=0.5, replenishment_policy=scm.SSReplenishment, policy_param={'s':300,'S':400}, product_sell_price=35, logging=False) # ------------------- Distributors ------------------- distributor1 = scm.InventoryNode(env=env, ID='dist1', name='Distributor 1', node_type='distributor', product=bread, inventory_type='perishable', shelf_life=5, capacity=float('inf'), initial_level=50, inventory_holding_cost=0.2, replenishment_policy=scm.RQReplenishment, policy_param={'R':150,'Q':50}, product_buy_price=0, product_sell_price=36, logging=False) distributor2 = scm.InventoryNode(env=env, ID='dist2', name='Distributor 2', node_type='distributor', product=bread, inventory_type='perishable', shelf_life=5, capacity=float('inf'), initial_level=40, inventory_holding_cost=0.25, replenishment_policy=scm.SSReplenishment, policy_param={'s':150,'S':200}, product_buy_price=0, product_sell_price=37, logging=False) # ------------------- Retailers ------------------- cake_shops = [] capacities = [40,60,80,60,100] ini_levels = [30,20,30,20,50] policies = [scm.RQReplenishment, scm.PeriodicReplenishment, scm.SSReplenishment, scm.RQReplenishment, scm.PeriodicReplenishment] policy_params = [{'R':20,'Q':40}, {'T':3,'Q':50}, {'s':20,'S':50}, {'R':20,'Q':40}, {'T':3,'Q':100}] supplier_selection = [scm.SelectFirst,scm.SelectAvailable,scm.SelectFirst,scm.SelectAvailable,scm.SelectFirst] for i in range(0,5): shop = scm.InventoryNode(env=env, ID=f'cake_shop{i+1}', name=f'Cake Shop {i+1}', node_type='retailer', product=bread, inventory_type='perishable', shelf_life=5, capacity=capacities[i], initial_level=ini_levels[i], inventory_holding_cost=0.1, replenishment_policy=policies[i], policy_param=policy_params[i], supplier_selection_policy=supplier_selection[i], product_buy_price=25, product_sell_price=40, logging=False) cake_shops.append(shop) # ------------------- Links ------------------- links = [] # Raw material links, suppliers to bakery suppliers = [flour_mill, sugar_factory, yeast_factory] costs = [5, 6, 5] for i in range(3): links.append(scm.Link(env=env, ID=f'l{i+1}', source=suppliers[i], sink=bakery, cost=costs[i], lead_time=lambda: 0.3)) # Bakery \u2192 Distributors links.append(scm.Link(env=env, ID='l4', source=bakery, sink=distributor1, cost=6, lead_time=lambda: 1)) links.append(scm.Link(env=env, ID='l5', source=bakery, sink=distributor2, cost=7, lead_time=lambda: 1.2)) # Distributor 1 \u2192 Shops 1, 2, 3 for i in range(0,3): link = scm.Link(env=env, ID=f'l{i+6}', source=distributor1, sink=cake_shops[i], cost=4, lead_time=lambda: 0.4 + i*0.1) links.append(link) # Distributor 2 \u2192 Shops 4, 5 for i in range(3,5): link = scm.Link(env=env, ID=f'l{i+6}', source=distributor2, sink=cake_shops[i], cost=5, lead_time=lambda: 0.5) links.append(link) # Hybrid cross-links links.append(scm.Link(env=env, ID='l11', source=distributor1, sink=cake_shops[3], cost=8, lead_time=lambda: 0.5)) links.append(scm.Link(env=env, ID='l12', source=distributor2, sink=cake_shops[4], cost=6, lead_time=lambda: 0.8)) # ------------------- Demands ------------------- arrival = Distributions(lam=5) quantity = Distributions(low=1, high=5) demands = [] for i in range(5): demands.append(scm.Demand(env=env, ID=f'd{i+1}', name=f'Demand Shop {i+1}', order_arrival_model=arrival.poisson_arrival, order_quantity_model=quantity.uniform_quantity, demand_node=cake_shops[i], logging=False)) # ------------------- Network ------------------- bread_chain = scm.create_sc_net( env=env, nodes=[flour_mill, sugar_factory, yeast_factory, bakery, distributor1, distributor2, *cake_shops], links=links, demands=demands ) scm.simulate_sc_net(bread_chain, sim_time=365, logging=True) print(\"---- Node-wise performance ----\\n---- ---- Suppliers and Bakery---- ----\") scm.print_node_wise_performance([flour_mill, sugar_factory, yeast_factory, bakery]) print(\"\\n---- ---- Distributors ---- ----\") scm.print_node_wise_performance([distributor1, distributor2]) print(\"\\n---- ---- Retail Shops ---- ----\") scm.print_node_wise_performance(cake_shops) Sample Output INFO sim_trace - Supply chain info: INFO sim_trace - available_inv : 534 INFO sim_trace - avg_available_inv : 365.46027397260275 INFO sim_trace - avg_cost_per_item : 1.8309188338110083 INFO sim_trace - avg_cost_per_order : 352.90117548464065 INFO sim_trace - backorders : [182, 23989] INFO sim_trace - demand_by_customers : [9175, 22985] INFO sim_trace - demand_by_site : [436, 1829491] INFO sim_trace - demands : {'d1': Demand Shop 1, 'd2': Demand Shop 2, 'd3': Demand Shop 3, 'd4': Demand Shop 4, 'd5': Demand Shop 5} INFO sim_trace - env : <simpy.core.Environment object at 0x00000278F5714A10> INFO sim_trace - fulfillment_received_by_customers : [911, 2193] INFO sim_trace - fulfillment_received_by_site : [412, 1827149] INFO sim_trace - inventory_carry_cost : 59324.19758288176 INFO sim_trace - inventory_spend_cost : 3056583.0 INFO sim_trace - inventory_waste : 25961 INFO sim_trace - links : {'l1': fmill to bakery, 'l2': sfact to bakery, 'l3': yfact to bakery, 'l4': bakery to dist1, 'l5': bakery to dist2, 'l6': dist1 to cake_shop1, 'l7': dist1 to cake_shop2, 'l8': dist1 to cake_shop3, 'l9': dist2 to cake_shop4, 'l10': dist2 to cake_shop5, 'l11': dist1 to cake_shop4, 'l12': dist2 to cake_shop5} INFO sim_trace - nodes : {'fmill': Flour Mill, 'sfact': Sugar Factory, 'yfact': Yeast Factory, 'bakery': Bakery, 'dist1': Distributor 1, 'dist2': Distributor 2, 'cake_shop1': Cake Shop 1, 'cake_shop2': Cake Shop 2, 'cake_shop3': Cake Shop 3, 'cake_shop4': Cake Shop 4, 'cake_shop5': Cake Shop 5} INFO sim_trace - num_distributors : 2 INFO sim_trace - num_manufacturers : 1 INFO sim_trace - num_of_links : 12 INFO sim_trace - num_of_nodes : 11 INFO sim_trace - num_retailers : 5 INFO sim_trace - num_suppliers : 3 INFO sim_trace - profit : -2226001.1975828814 INFO sim_trace - revenue : 1165732 INFO sim_trace - shortage : [8446, 34633] INFO sim_trace - total_cost : 3391733.1975828814 INFO sim_trace - total_demand : [9611, 1852476] INFO sim_trace - total_fulfillment_received : [1323, 1829342] INFO sim_trace - transportation_cost : 2466 ---- Node-wise performance ---- ---- ---- Suppliers and Bakery---- ---- Performance Metric Flour Mill Sugar Factory Yeast Factory Bakery backorder [0, 0] [0, 0] [0, 0] [132, 22135] demand_fulfilled [21, 898260] [21, 449130] [21, 449130] [214, 26936] demand_placed [0, 0] [0, 0] [0, 0] [63, 1796520] demand_received [21, 898260] [21, 449130] [21, 449130] [228, 29138] fulfillment_received [0, 0] [0, 0] [0, 0] [63, 1796520] inventory_carry_cost 0 0 0 53334.0 inventory_level 0 0 0 500 inventory_spend_cost 0 0 0 2964258.0 inventory_waste 0 0 0 243 node_cost 0 0 0 3291288.0 orders_shortage [0, 0] [0, 0] [0, 0] [132, 12825] profit 2245650.0 628782.0 89826.0 -2348528.0 revenue 2245650.0 628782.0 89826.0 942760 total_material_cost 0 0 0 N/A total_raw_materials_mined0 0 0 N/A transportation_cost 0 0 0 336 ---- ---- Distributors ---- ---- Performance Metric Distributor 1 Distributor 2 backorder [26, 805] [24, 1049] demand_fulfilled [60, 1389] [75, 2304] demand_placed [124, 6200] [104, 22938] demand_received [67, 1449] [78, 2384] fulfillment_received [116, 5800] [98, 21136] inventory_carry_cost 1165.8018979669055 4439.666173296053 inventory_level 7 27 inventory_spend_cost 0 0 inventory_waste 4842 19345 node_cost 1909.8018979669055 5167.666173296053 orders_shortage [26, 470] [24, 691] profit 48094.19810203309 80080.33382670395 revenue 50004 85248 transportation_cost 744 728 ---- ---- Retail Shops ---- ---- Performance Metric Cake Shop 1 Cake Shop 2 Cake Shop 3 Cake Shop 4 Cake Shop 5 backorder [0, 0] [0, 0] [0, 0] [0, 0] [0, 0] demand_fulfilled [39, 96] [239, 555] [39, 105] [310, 757] [284, 680] demand_placed [8, 198] [52, 947] [7, 304] [29, 1160] [49, 1224] demand_received [39, 96] [239, 555] [39, 105] [310, 757] [284, 680] fulfillment_received [8, 198] [45, 887] [7, 304] [28, 1120] [47, 1184] inventory_carry_cost 9.42778086039718 81.4112372198074 15.98847104347198 148.6863226007502 129.21569989437646 inventory_level 0 0 0 0 0 inventory_spend_cost 4950 22175 7600 28000 29600 inventory_waste 102 352 200 383 494 node_cost 4991.427780860397 22464.411237219807 7643.988471043472 28293.68632260075 29974.215699894376 orders_shortage [1759, 4320] [1595, 3992] [1787, 4534] [1567, 3925] [1556, 3876] profit -1151.4277808603974 -264.41123721980694 -3443.9884710434717 1986.3136773992483 -2774.2156998943756 revenue 3840 22200 4200 30280 27200 transportation_cost 32 208 28 145 245 Suggested Experiments Vary policy_param values ( s/S , R/Q , T/Q ). Change lead_time lambdas and link costs. Switch retailer inventory_type and shelf_life to study perishability. Add/remove cross\u2011links to test resilience. Notes Keep node IDs unique. Ensure product_buy_price \u2264 upstream product_sell_price where applicable. Use consistent time units across processing, lead times, and review periods.","title":"Complex Supply Chain"},{"location":"example-complex/#complex-supply-chain-network","text":"This example demonstrates how to build and simulate a multi\u2011echelon, hybrid supply chain with different replenishment policies in SupplyNetPy .","title":"Complex Supply Chain Network"},{"location":"example-complex/#goals","text":"Creating a network with multiple raw materials, suppliers, a manufacturer, two distributors, and several retailers. Mix replenishment policies (`SS`, `RQ`, `Periodic`). Include hybrid connections (ordering from multiple distributors).","title":"Goals"},{"location":"example-complex/#key-concepts-used","text":"Products, Raw Materials : Class Product used to create a product, Bread, with some shelf life, RawMaterial is used to create raw materials (dough, sugar, yeast) Nodes : Clasees Supplier , Manufacturer , InventoryNode are used to create suppliers, bakery (factory), distributors, and retailers (cake shops). Links : Class Link is used to link different nodes in the network Policies : SSReplenishment : order up to S when inventory <= s RQReplenishment : reorder point R , fixed order quantity Q PeriodicReplenishment : review every T , order Q . Perishability : inventory_type for all nodes is perishable , and parameter shelf_life is passed.","title":"Key Concepts Used"},{"location":"example-complex/#full-example","text":"This script constructs a hybrid network with two distributors and five retailers, then runs a short simulation. import SupplyNetPy.Components as scm import simpy import numpy as np class Distributions: def __init__(self, lam=5, mu=5, low=1, high=10): self.lam = lam self.mu = mu self.low = low self.high = high def poisson_arrival(self): return np.random.exponential(scale=1/self.lam) def uniform_quantity(self): return int(np.random.uniform(low=self.low, high=self.high)) env = simpy.Environment() # ------------------- Raw Materials ------------------- flour = scm.RawMaterial(ID='flourk11', name='Flour', extraction_quantity=50, extraction_time=1, mining_cost=10, cost=2.5) sugar = scm.RawMaterial(ID='sugark21', name='Sugar', extraction_quantity=30, extraction_time=1, mining_cost=8, cost=1.4) yeast = scm.RawMaterial(ID='yeast31', name='Yeast', extraction_quantity=20, extraction_time=1, mining_cost=3, cost=0.2) # ------------------- Suppliers ------------------- flour_mill = scm.Supplier(env=env, ID='fmill', name='Flour Mill', node_type='infinite_supplier', raw_material=flour, logging=False) sugar_factory = scm.Supplier(env=env, ID='sfact', name='Sugar Factory', node_type='infinite_supplier', raw_material=sugar, logging=False) yeast_factory = scm.Supplier(env=env, ID='yfact', name='Yeast Factory', node_type='infinite_supplier', raw_material=yeast, logging=False) # ------------------- Manufacturer ------------------- bread = scm.Product(ID='soft_regular11', name='Bread', manufacturing_cost=10, manufacturing_time=1, sell_price=40, raw_materials=[(flour, 30), (sugar, 15), (yeast, 15)], batch_size=300) bakery = scm.Manufacturer(env=env, ID='bakery', name='Bakery', product=bread, shelf_life=5, inventory_type='perishable', capacity=500, initial_level=100, inventory_holding_cost=0.5, replenishment_policy=scm.SSReplenishment, policy_param={'s':300,'S':400}, product_sell_price=35, logging=False) # ------------------- Distributors ------------------- distributor1 = scm.InventoryNode(env=env, ID='dist1', name='Distributor 1', node_type='distributor', product=bread, inventory_type='perishable', shelf_life=5, capacity=float('inf'), initial_level=50, inventory_holding_cost=0.2, replenishment_policy=scm.RQReplenishment, policy_param={'R':150,'Q':50}, product_buy_price=0, product_sell_price=36, logging=False) distributor2 = scm.InventoryNode(env=env, ID='dist2', name='Distributor 2', node_type='distributor', product=bread, inventory_type='perishable', shelf_life=5, capacity=float('inf'), initial_level=40, inventory_holding_cost=0.25, replenishment_policy=scm.SSReplenishment, policy_param={'s':150,'S':200}, product_buy_price=0, product_sell_price=37, logging=False) # ------------------- Retailers ------------------- cake_shops = [] capacities = [40,60,80,60,100] ini_levels = [30,20,30,20,50] policies = [scm.RQReplenishment, scm.PeriodicReplenishment, scm.SSReplenishment, scm.RQReplenishment, scm.PeriodicReplenishment] policy_params = [{'R':20,'Q':40}, {'T':3,'Q':50}, {'s':20,'S':50}, {'R':20,'Q':40}, {'T':3,'Q':100}] supplier_selection = [scm.SelectFirst,scm.SelectAvailable,scm.SelectFirst,scm.SelectAvailable,scm.SelectFirst] for i in range(0,5): shop = scm.InventoryNode(env=env, ID=f'cake_shop{i+1}', name=f'Cake Shop {i+1}', node_type='retailer', product=bread, inventory_type='perishable', shelf_life=5, capacity=capacities[i], initial_level=ini_levels[i], inventory_holding_cost=0.1, replenishment_policy=policies[i], policy_param=policy_params[i], supplier_selection_policy=supplier_selection[i], product_buy_price=25, product_sell_price=40, logging=False) cake_shops.append(shop) # ------------------- Links ------------------- links = [] # Raw material links, suppliers to bakery suppliers = [flour_mill, sugar_factory, yeast_factory] costs = [5, 6, 5] for i in range(3): links.append(scm.Link(env=env, ID=f'l{i+1}', source=suppliers[i], sink=bakery, cost=costs[i], lead_time=lambda: 0.3)) # Bakery \u2192 Distributors links.append(scm.Link(env=env, ID='l4', source=bakery, sink=distributor1, cost=6, lead_time=lambda: 1)) links.append(scm.Link(env=env, ID='l5', source=bakery, sink=distributor2, cost=7, lead_time=lambda: 1.2)) # Distributor 1 \u2192 Shops 1, 2, 3 for i in range(0,3): link = scm.Link(env=env, ID=f'l{i+6}', source=distributor1, sink=cake_shops[i], cost=4, lead_time=lambda: 0.4 + i*0.1) links.append(link) # Distributor 2 \u2192 Shops 4, 5 for i in range(3,5): link = scm.Link(env=env, ID=f'l{i+6}', source=distributor2, sink=cake_shops[i], cost=5, lead_time=lambda: 0.5) links.append(link) # Hybrid cross-links links.append(scm.Link(env=env, ID='l11', source=distributor1, sink=cake_shops[3], cost=8, lead_time=lambda: 0.5)) links.append(scm.Link(env=env, ID='l12', source=distributor2, sink=cake_shops[4], cost=6, lead_time=lambda: 0.8)) # ------------------- Demands ------------------- arrival = Distributions(lam=5) quantity = Distributions(low=1, high=5) demands = [] for i in range(5): demands.append(scm.Demand(env=env, ID=f'd{i+1}', name=f'Demand Shop {i+1}', order_arrival_model=arrival.poisson_arrival, order_quantity_model=quantity.uniform_quantity, demand_node=cake_shops[i], logging=False)) # ------------------- Network ------------------- bread_chain = scm.create_sc_net( env=env, nodes=[flour_mill, sugar_factory, yeast_factory, bakery, distributor1, distributor2, *cake_shops], links=links, demands=demands ) scm.simulate_sc_net(bread_chain, sim_time=365, logging=True) print(\"---- Node-wise performance ----\\n---- ---- Suppliers and Bakery---- ----\") scm.print_node_wise_performance([flour_mill, sugar_factory, yeast_factory, bakery]) print(\"\\n---- ---- Distributors ---- ----\") scm.print_node_wise_performance([distributor1, distributor2]) print(\"\\n---- ---- Retail Shops ---- ----\") scm.print_node_wise_performance(cake_shops)","title":"Full Example"},{"location":"example-complex/#sample-output","text":"INFO sim_trace - Supply chain info: INFO sim_trace - available_inv : 534 INFO sim_trace - avg_available_inv : 365.46027397260275 INFO sim_trace - avg_cost_per_item : 1.8309188338110083 INFO sim_trace - avg_cost_per_order : 352.90117548464065 INFO sim_trace - backorders : [182, 23989] INFO sim_trace - demand_by_customers : [9175, 22985] INFO sim_trace - demand_by_site : [436, 1829491] INFO sim_trace - demands : {'d1': Demand Shop 1, 'd2': Demand Shop 2, 'd3': Demand Shop 3, 'd4': Demand Shop 4, 'd5': Demand Shop 5} INFO sim_trace - env : <simpy.core.Environment object at 0x00000278F5714A10> INFO sim_trace - fulfillment_received_by_customers : [911, 2193] INFO sim_trace - fulfillment_received_by_site : [412, 1827149] INFO sim_trace - inventory_carry_cost : 59324.19758288176 INFO sim_trace - inventory_spend_cost : 3056583.0 INFO sim_trace - inventory_waste : 25961 INFO sim_trace - links : {'l1': fmill to bakery, 'l2': sfact to bakery, 'l3': yfact to bakery, 'l4': bakery to dist1, 'l5': bakery to dist2, 'l6': dist1 to cake_shop1, 'l7': dist1 to cake_shop2, 'l8': dist1 to cake_shop3, 'l9': dist2 to cake_shop4, 'l10': dist2 to cake_shop5, 'l11': dist1 to cake_shop4, 'l12': dist2 to cake_shop5} INFO sim_trace - nodes : {'fmill': Flour Mill, 'sfact': Sugar Factory, 'yfact': Yeast Factory, 'bakery': Bakery, 'dist1': Distributor 1, 'dist2': Distributor 2, 'cake_shop1': Cake Shop 1, 'cake_shop2': Cake Shop 2, 'cake_shop3': Cake Shop 3, 'cake_shop4': Cake Shop 4, 'cake_shop5': Cake Shop 5} INFO sim_trace - num_distributors : 2 INFO sim_trace - num_manufacturers : 1 INFO sim_trace - num_of_links : 12 INFO sim_trace - num_of_nodes : 11 INFO sim_trace - num_retailers : 5 INFO sim_trace - num_suppliers : 3 INFO sim_trace - profit : -2226001.1975828814 INFO sim_trace - revenue : 1165732 INFO sim_trace - shortage : [8446, 34633] INFO sim_trace - total_cost : 3391733.1975828814 INFO sim_trace - total_demand : [9611, 1852476] INFO sim_trace - total_fulfillment_received : [1323, 1829342] INFO sim_trace - transportation_cost : 2466 ---- Node-wise performance ---- ---- ---- Suppliers and Bakery---- ---- Performance Metric Flour Mill Sugar Factory Yeast Factory Bakery backorder [0, 0] [0, 0] [0, 0] [132, 22135] demand_fulfilled [21, 898260] [21, 449130] [21, 449130] [214, 26936] demand_placed [0, 0] [0, 0] [0, 0] [63, 1796520] demand_received [21, 898260] [21, 449130] [21, 449130] [228, 29138] fulfillment_received [0, 0] [0, 0] [0, 0] [63, 1796520] inventory_carry_cost 0 0 0 53334.0 inventory_level 0 0 0 500 inventory_spend_cost 0 0 0 2964258.0 inventory_waste 0 0 0 243 node_cost 0 0 0 3291288.0 orders_shortage [0, 0] [0, 0] [0, 0] [132, 12825] profit 2245650.0 628782.0 89826.0 -2348528.0 revenue 2245650.0 628782.0 89826.0 942760 total_material_cost 0 0 0 N/A total_raw_materials_mined0 0 0 N/A transportation_cost 0 0 0 336 ---- ---- Distributors ---- ---- Performance Metric Distributor 1 Distributor 2 backorder [26, 805] [24, 1049] demand_fulfilled [60, 1389] [75, 2304] demand_placed [124, 6200] [104, 22938] demand_received [67, 1449] [78, 2384] fulfillment_received [116, 5800] [98, 21136] inventory_carry_cost 1165.8018979669055 4439.666173296053 inventory_level 7 27 inventory_spend_cost 0 0 inventory_waste 4842 19345 node_cost 1909.8018979669055 5167.666173296053 orders_shortage [26, 470] [24, 691] profit 48094.19810203309 80080.33382670395 revenue 50004 85248 transportation_cost 744 728 ---- ---- Retail Shops ---- ---- Performance Metric Cake Shop 1 Cake Shop 2 Cake Shop 3 Cake Shop 4 Cake Shop 5 backorder [0, 0] [0, 0] [0, 0] [0, 0] [0, 0] demand_fulfilled [39, 96] [239, 555] [39, 105] [310, 757] [284, 680] demand_placed [8, 198] [52, 947] [7, 304] [29, 1160] [49, 1224] demand_received [39, 96] [239, 555] [39, 105] [310, 757] [284, 680] fulfillment_received [8, 198] [45, 887] [7, 304] [28, 1120] [47, 1184] inventory_carry_cost 9.42778086039718 81.4112372198074 15.98847104347198 148.6863226007502 129.21569989437646 inventory_level 0 0 0 0 0 inventory_spend_cost 4950 22175 7600 28000 29600 inventory_waste 102 352 200 383 494 node_cost 4991.427780860397 22464.411237219807 7643.988471043472 28293.68632260075 29974.215699894376 orders_shortage [1759, 4320] [1595, 3992] [1787, 4534] [1567, 3925] [1556, 3876] profit -1151.4277808603974 -264.41123721980694 -3443.9884710434717 1986.3136773992483 -2774.2156998943756 revenue 3840 22200 4200 30280 27200 transportation_cost 32 208 28 145 245","title":"Sample Output"},{"location":"example-complex/#suggested-experiments","text":"Vary policy_param values ( s/S , R/Q , T/Q ). Change lead_time lambdas and link costs. Switch retailer inventory_type and shelf_life to study perishability. Add/remove cross\u2011links to test resilience.","title":"Suggested Experiments"},{"location":"example-complex/#notes","text":"Keep node IDs unique. Ensure product_buy_price \u2264 upstream product_sell_price where applicable. Use consistent time units across processing, lead times, and review periods.","title":"Notes"},{"location":"example-newvendor/","text":"img{ width:70%; } News Vendor Problem This example illustrates how to model and simulate the classic newsvendor problem . In this problem, a decision-maker must determine the optimal order quantity for a perishable product with uncertain demand, aiming to maximize expected profit by balancing the risks of overstocking and understocking. Problem Definition The newsvendor orders Q units every day. Each unit costs c, and the selling price is p. The newsvendor faces normally distributed demand with mean \u03bc and standard deviation \u03c3. If, on a certain day, the actual demand is k, then the net profit after selling k units is calculated as: Profit = Revenue \u2212 Order Cost = k \u00d7 p \u2212 Q \u00d7 c However, if there are any units left unsold at the end of the day, they are considered wastage since they cannot be sold the next day. The newsvendor can sell these unsold units back to the supplier at a lower price, called the salvage value s. If the actual demand that day is less than the order size Q, then the net profit is thus calulated as: Profit = Revenue + Salvage \u2212 Order Cost = k \u00d7 p + ( Q \u2212 k ) \u00d7 s \u2212 Q \u00d7 c When the actual demand k exceeds the newsvendor's order quantity Q , the profit is calculated as: Profit = Q \u00d7 p \u2212 Q \u00d7 c \u2003 \u2003 (In this case, all available units are sold, and the profit is based on the total revenue from selling Q units minus the total ordering cost.) So, the newsvendor problem is defined by following parameters. Ordering cost (c) : Cost per unit ordered. Selling price (p) : Price per unit sold. Salvage value (s) : Value per unsold unit at the end of the period. Mean demand (\u03bc) : Average demand during the period. Standard deviation of demand (\u03c3) : Demand variability. Number of samples (n) : Number of demand samples for simulation. Order quantity (Q) : Quantity ordered for the period. The objective is to find the order quantity Q * that maximizes expected profit. Analytical Solution The optimal order quantity is given by: Q * = \u03bc + \u03c3 \u00b7 \u03a6 \u22121 ( C u / (C u + C o ) ) where: C u = p - c: Underage cost (profit lost per unit of unmet demand) C o = c - s: Overage cost (cost per unsold unit) \u03a6 -1 : Inverse standard normal C u /(C u + C o ): Critical ratio (proportion of demand to satisfy) Example Parameters Given: c = 2 p = 5 s = 1 \u03bc = 100 \u03c3 = 15 n = 1000 Q = 100 (example order quantity) Plugging in the values: C u = 5 - 2 = 3 C o = 2 - 1 = 1 Critical ratio = 3/(3 + 1) = 0.75 Q = 100 + 15 \u00b7 \u03a6 -1 (0.75) Q \u2248 100 + 15 \u00b7 0.6745 = 110.12 So, the optimal order quantity is approximately 110 units . Modeling and Simulating the Newsvendor Problem It is a simple three-node supply chain with one supplier, a newsvendor (retailer), and normally distributed demand at the newsvendor. Simulation Setup: An infinite_supplier is used to ensure unlimited supply to the newsvendor. The focus of the simulation is on the newsvendor node newsvendor1 , which: Maintains perishable inventory with a shelf life of 1 day. (Shelf life is set to value 1.00001 to avoid expiration before daily consumption.) Uses a periodic replenishment policy, ordering every day. The link between the supplier and the newsvendor has a lead time of 0, meaning orders are delivered immediately each day. Demand is modeled as a normal distribution. The normal_quantity() function samples order sizes from this distribution. Setting consume_available flag to True for demand allows partial fulfillment. This is necessary because, in the simulation model, the demand appears as a single order of Q units, but in reality, these are individual customers purchasing newspapers. This setup ensures that the simulation accurately represents the intended demand and fulfillment process for the newsvendor problem. import simpy import random import numpy as np import matplotlib.pyplot as plt import SupplyNetPy.Components as scm cost = 2 sell_price = 5 salvage = 1 mean = 100 std_dev = 15 num_samples = 1000 def normal_quantity(): \"\"\"Generates a random order quantity based on a normal distribution.\"\"\" sample = random.gauss(mean, std_dev) while(sample<0): sample = random.gauss(mean, std_dev) return sample cost = 2 # newspaper buy price sell_price = 5 # newspaper sell price salvage = 1 # newspaper salvage price order_quantity = 100 # initial order quantity cost_arr = [] # to store cost for each order quantity profit_arr = [] # to store profit for each order quantity for order_quantity in range(10, 200, 10): env = simpy.Environment() # create an infinite supplier supplier1 = scm.Supplier(env=env, ID=\"S1\", name=\"Supplier1\", node_type=\"infinite_supplier\") #create the distributor newsvendor1 = scm.InventoryNode(env=env, ID=\"D1\", name=\"News Vendor\", node_type=\"distributor\", capacity=float('inf'), initial_level=order_quantity, inventory_holding_cost=0.1, inventory_type=\"perishable\", shelf_life=1.00001, replenishment_policy=scm.PeriodicReplenishment, policy_param={\"T\": 1, \"Q\": order_quantity}, product_sell_price=sell_price, product_buy_price=cost) link1 = scm.Link(env=env,ID=\"l1\", source=supplier1, sink=newsvendor1, cost=10, lead_time=lambda: 0) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, consume_available=True, order_quantity_model=normal_quantity, demand_node=newsvendor1) scm.global_logger.disable_logging() env.run(until=num_samples) # Calculate the cost and profit # total demand fulfilled by newsvendor is available in variable demand_fulfilled # list element 0 is number of orders, element 1 is total quantity daily_sales = newsvendor1.stats.demand_fulfilled[1] wasted_inventory = newsvendor1.inventory.waste everyday_profit = (daily_sales*sell_price + wasted_inventory*salvage - order_quantity*num_samples*cost)/num_samples profit_arr.append([order_quantity,everyday_profit]) profit_arr = np.array(profit_arr) # convert to numpy array for easier manipulation Q = np.argmax(profit_arr[:,1]) # index of maximum profit plt.plot(profit_arr[:,0], profit_arr[:,1], marker='.', linestyle='-', color='b') plt.plot(profit_arr[Q,0], profit_arr[Q,1], marker='o', linestyle='-', color='r', label=f'Q={profit_arr[Q,0]}') plt.xlabel('Order Quantity') plt.ylabel('Profit') plt.title('Profit vs Order Quantity') plt.legend() plt.grid() plt.show() The following plot shows the relationship between profit and order quantity (Q). The curve clearly indicates that the maximum profit is achieved when Q is approximately 110, confirming the analytical solution for the optimal order quantity. Takeway This example demonstrated how to solve the newsvendor problem using simulation-based approaches using SupplyNetPy library. By simulating different order quantities and evaluating the resulting profits, we can visualize and confirm the optimal order quantity that maximizes expected profit. This approach can be extended to more complex inventory scenarios and demand distributions, providing valuable insights for inventory management decisions.","title":"News Vendor"},{"location":"example-newvendor/#news-vendor-problem","text":"This example illustrates how to model and simulate the classic newsvendor problem . In this problem, a decision-maker must determine the optimal order quantity for a perishable product with uncertain demand, aiming to maximize expected profit by balancing the risks of overstocking and understocking.","title":"News Vendor Problem"},{"location":"example-newvendor/#problem-definition","text":"The newsvendor orders Q units every day. Each unit costs c, and the selling price is p. The newsvendor faces normally distributed demand with mean \u03bc and standard deviation \u03c3. If, on a certain day, the actual demand is k, then the net profit after selling k units is calculated as: Profit = Revenue \u2212 Order Cost = k \u00d7 p \u2212 Q \u00d7 c However, if there are any units left unsold at the end of the day, they are considered wastage since they cannot be sold the next day. The newsvendor can sell these unsold units back to the supplier at a lower price, called the salvage value s. If the actual demand that day is less than the order size Q, then the net profit is thus calulated as: Profit = Revenue + Salvage \u2212 Order Cost = k \u00d7 p + ( Q \u2212 k ) \u00d7 s \u2212 Q \u00d7 c When the actual demand k exceeds the newsvendor's order quantity Q , the profit is calculated as: Profit = Q \u00d7 p \u2212 Q \u00d7 c \u2003 \u2003 (In this case, all available units are sold, and the profit is based on the total revenue from selling Q units minus the total ordering cost.) So, the newsvendor problem is defined by following parameters. Ordering cost (c) : Cost per unit ordered. Selling price (p) : Price per unit sold. Salvage value (s) : Value per unsold unit at the end of the period. Mean demand (\u03bc) : Average demand during the period. Standard deviation of demand (\u03c3) : Demand variability. Number of samples (n) : Number of demand samples for simulation. Order quantity (Q) : Quantity ordered for the period. The objective is to find the order quantity Q * that maximizes expected profit.","title":"Problem Definition"},{"location":"example-newvendor/#analytical-solution","text":"The optimal order quantity is given by: Q * = \u03bc + \u03c3 \u00b7 \u03a6 \u22121 ( C u / (C u + C o ) ) where: C u = p - c: Underage cost (profit lost per unit of unmet demand) C o = c - s: Overage cost (cost per unsold unit) \u03a6 -1 : Inverse standard normal C u /(C u + C o ): Critical ratio (proportion of demand to satisfy)","title":"Analytical Solution"},{"location":"example-newvendor/#example-parameters","text":"Given: c = 2 p = 5 s = 1 \u03bc = 100 \u03c3 = 15 n = 1000 Q = 100 (example order quantity) Plugging in the values: C u = 5 - 2 = 3 C o = 2 - 1 = 1 Critical ratio = 3/(3 + 1) = 0.75 Q = 100 + 15 \u00b7 \u03a6 -1 (0.75) Q \u2248 100 + 15 \u00b7 0.6745 = 110.12 So, the optimal order quantity is approximately 110 units .","title":"Example Parameters"},{"location":"example-newvendor/#modeling-and-simulating-the-newsvendor-problem","text":"It is a simple three-node supply chain with one supplier, a newsvendor (retailer), and normally distributed demand at the newsvendor. Simulation Setup: An infinite_supplier is used to ensure unlimited supply to the newsvendor. The focus of the simulation is on the newsvendor node newsvendor1 , which: Maintains perishable inventory with a shelf life of 1 day. (Shelf life is set to value 1.00001 to avoid expiration before daily consumption.) Uses a periodic replenishment policy, ordering every day. The link between the supplier and the newsvendor has a lead time of 0, meaning orders are delivered immediately each day. Demand is modeled as a normal distribution. The normal_quantity() function samples order sizes from this distribution. Setting consume_available flag to True for demand allows partial fulfillment. This is necessary because, in the simulation model, the demand appears as a single order of Q units, but in reality, these are individual customers purchasing newspapers. This setup ensures that the simulation accurately represents the intended demand and fulfillment process for the newsvendor problem. import simpy import random import numpy as np import matplotlib.pyplot as plt import SupplyNetPy.Components as scm cost = 2 sell_price = 5 salvage = 1 mean = 100 std_dev = 15 num_samples = 1000 def normal_quantity(): \"\"\"Generates a random order quantity based on a normal distribution.\"\"\" sample = random.gauss(mean, std_dev) while(sample<0): sample = random.gauss(mean, std_dev) return sample cost = 2 # newspaper buy price sell_price = 5 # newspaper sell price salvage = 1 # newspaper salvage price order_quantity = 100 # initial order quantity cost_arr = [] # to store cost for each order quantity profit_arr = [] # to store profit for each order quantity for order_quantity in range(10, 200, 10): env = simpy.Environment() # create an infinite supplier supplier1 = scm.Supplier(env=env, ID=\"S1\", name=\"Supplier1\", node_type=\"infinite_supplier\") #create the distributor newsvendor1 = scm.InventoryNode(env=env, ID=\"D1\", name=\"News Vendor\", node_type=\"distributor\", capacity=float('inf'), initial_level=order_quantity, inventory_holding_cost=0.1, inventory_type=\"perishable\", shelf_life=1.00001, replenishment_policy=scm.PeriodicReplenishment, policy_param={\"T\": 1, \"Q\": order_quantity}, product_sell_price=sell_price, product_buy_price=cost) link1 = scm.Link(env=env,ID=\"l1\", source=supplier1, sink=newsvendor1, cost=10, lead_time=lambda: 0) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, consume_available=True, order_quantity_model=normal_quantity, demand_node=newsvendor1) scm.global_logger.disable_logging() env.run(until=num_samples) # Calculate the cost and profit # total demand fulfilled by newsvendor is available in variable demand_fulfilled # list element 0 is number of orders, element 1 is total quantity daily_sales = newsvendor1.stats.demand_fulfilled[1] wasted_inventory = newsvendor1.inventory.waste everyday_profit = (daily_sales*sell_price + wasted_inventory*salvage - order_quantity*num_samples*cost)/num_samples profit_arr.append([order_quantity,everyday_profit]) profit_arr = np.array(profit_arr) # convert to numpy array for easier manipulation Q = np.argmax(profit_arr[:,1]) # index of maximum profit plt.plot(profit_arr[:,0], profit_arr[:,1], marker='.', linestyle='-', color='b') plt.plot(profit_arr[Q,0], profit_arr[Q,1], marker='o', linestyle='-', color='r', label=f'Q={profit_arr[Q,0]}') plt.xlabel('Order Quantity') plt.ylabel('Profit') plt.title('Profit vs Order Quantity') plt.legend() plt.grid() plt.show() The following plot shows the relationship between profit and order quantity (Q). The curve clearly indicates that the maximum profit is achieved when Q is approximately 110, confirming the analytical solution for the optimal order quantity.","title":"Modeling and Simulating the Newsvendor Problem"},{"location":"example-newvendor/#takeway","text":"This example demonstrated how to solve the newsvendor problem using simulation-based approaches using SupplyNetPy library. By simulating different order quantities and evaluating the resulting profits, we can visualize and confirm the optimal order quantity that maximizes expected profit. This approach can be extended to more complex inventory scenarios and demand distributions, providing valuable insights for inventory management decisions.","title":"Takeway"},{"location":"example/","text":"Supply Chain With Factory This example demonstrates how to create an end-to-end supply chain involving a raw material supplier, a factory, and a warehouse. Creating Nodes In this scenario, we create a supplier with a limited inventory capacity. A raw material needs to be created and provided to the supplier when it is created with finite inventory. This raw material is defined by several parameters, including ID, name, extraction quantity, extraction time, and cost. The supplier is designed to hold only a single type of raw material in its inventory and is responsible for mining it to maintain inventory levels to fill capacity. import SupplyNetPy.Components as scm raw_mat1 = scm.RawMaterial(ID='rm1', name='raw_mat1', extraction_quantity=1000, extraction_time=1, mining_cost=0.5, cost=0.8) supplier1 = {'ID':'S1', 'name':'supplier1', 'node_type':'supplier', 'capacity':5000, 'initial_level':5000, 'inventory_holding_cost':0.01, 'raw_material':raw_mat1} Creating a factory requires a product. A product and a factory can be created and configured as follows. product1 = scm.Product(ID='p1', name='product1', manufacturing_cost=20, manufacturing_time=1, batch_size=1000, raw_materials=[(raw_mat1, 2)], sell_price=30) factory1 = {'ID':'F1', 'name':'factory1', 'node_type':'factory', 'capacity':2500, 'initial_level':2500, 'inventory_holding_cost':0.02, 'replenishment_policy':scm.SSReplenishment, 'policy_param': {'s':1000,'S':2500}, 'product':product1, 'product_sell_price':30} distributor1 = {'ID': 'D1', 'name': 'Distributor1', 'node_type': 'distributor', 'capacity': 1000, 'initial_level': 1000, 'inventory_holding_cost': 0.2, 'replenishment_policy': scm.SSReplenishment, 'policy_param': {'s':300,'S':1000}, 'product_buy_price':30,'product_sell_price': 35} The factory's behavior is to produce products based on a replenishment policy. In this example, inventory will be replenished when the level drops below a threshold (s). Therefore, the factory will begin manufacturing products once the inventory falls below this level and increase it back up to its maximum capacity (S). Defining Links Links represent the flow of products between nodes, with associated transportation costs and lead times. links1f1 = {'ID': 'L1', 'source': 'S1', 'sink': 'F1', 'cost': 100, 'lead_time': lambda: 2} linkf1d1 = {'ID': 'L2', 'source': 'F1', 'sink': 'D1', 'cost': 120, 'lead_time': lambda: 3} Modeling Demand Demand is generated at the distributor using deterministic arrival and quantity models. demand1 = {'ID': 'd1', 'name': 'Demand1', 'order_arrival_model': lambda: 0.4, 'order_quantity_model': lambda: 30, 'demand_node': 'D1'} Running the Simulation Create the supply chain network and simulate it. supplychainnet = scm.create_sc_net(nodes=[supplier1, factory1, distributor1], links=[links1f1, linkf1d1], demands=[demand1]) supplychainnet = scm.simulate_sc_net(supplychainnet, sim_time=20, logging=True) Review Results Here is the simulation log generated by the network. INFO F1 - 0.0000:F1: Inventory levels:2500, on hand:2500 INFO D1 - 0.0000:D1: Inventory levels:1000, on hand:1000 INFO d1 - 0.0000:d1:Customer1:Order quantity:30, available. INFO D1 - 0.0000:D1: Inventory levels:970, on hand:970 INFO d1 - 0.4000:d1:Customer2:Order quantity:30, available. INFO D1 - 0.4000:D1: Inventory levels:940, on hand:940 INFO d1 - 0.8000:d1:Customer3:Order quantity:30, available. INFO D1 - 0.8000:D1: Inventory levels:910, on hand:910 INFO S1 - 1.0000:S1: Inventory level:5000 INFO d1 - 1.2000:d1:Customer4:Order quantity:30, available. INFO D1 - 1.2000:D1: Inventory levels:880, on hand:880 INFO d1 - 1.6000:d1:Customer5:Order quantity:30, available. INFO D1 - 1.6000:D1: Inventory levels:850, on hand:850 INFO S1 - 2.0000:S1: Inventory level:5000 INFO d1 - 2.0000:d1:Customer6:Order quantity:30, available. INFO D1 - 2.0000:D1: Inventory levels:820, on hand:820 INFO d1 - 2.4000:d1:Customer7:Order quantity:30, available. INFO D1 - 2.4000:D1: Inventory levels:790, on hand:790 INFO d1 - 2.8000:d1:Customer8:Order quantity:30, available. INFO D1 - 2.8000:D1: Inventory levels:760, on hand:760 INFO S1 - 3.0000:S1: Inventory level:5000 INFO d1 - 3.2000:d1:Customer9:Order quantity:30, available. INFO D1 - 3.2000:D1: Inventory levels:730, on hand:730 INFO d1 - 3.6000:d1:Customer10:Order quantity:30, available. INFO D1 - 3.6000:D1: Inventory levels:700, on hand:700 INFO d1 - 4.0000:d1:Customer11:Order quantity:30, available. INFO D1 - 4.0000:D1: Inventory levels:670, on hand:670 INFO S1 - 4.0000:S1: Inventory level:5000 INFO d1 - 4.4000:d1:Customer12:Order quantity:30, available. INFO D1 - 4.4000:D1: Inventory levels:640, on hand:640 INFO d1 - 4.8000:d1:Customer13:Order quantity:30, available. INFO D1 - 4.8000:D1: Inventory levels:610, on hand:610 INFO S1 - 5.0000:S1: Inventory level:5000 INFO d1 - 5.2000:d1:Customer14:Order quantity:30, available. INFO D1 - 5.2000:D1: Inventory levels:580, on hand:580 INFO d1 - 5.6000:d1:Customer15:Order quantity:30, available. INFO D1 - 5.6000:D1: Inventory levels:550, on hand:550 INFO S1 - 6.0000:S1: Inventory level:5000 INFO d1 - 6.0000:d1:Customer16:Order quantity:30, available. INFO D1 - 6.0000:D1: Inventory levels:520, on hand:520 INFO d1 - 6.4000:d1:Customer17:Order quantity:30, available. INFO D1 - 6.4000:D1: Inventory levels:490, on hand:490 INFO d1 - 6.8000:d1:Customer18:Order quantity:30, available. INFO D1 - 6.8000:D1: Inventory levels:460, on hand:460 INFO S1 - 7.0000:S1: Inventory level:5000 INFO d1 - 7.2000:d1:Customer19:Order quantity:30, available. INFO D1 - 7.2000:D1: Inventory levels:430, on hand:430 INFO d1 - 7.6000:d1:Customer20:Order quantity:30, available. INFO D1 - 7.6000:D1: Inventory levels:400, on hand:400 INFO S1 - 8.0000:S1: Inventory level:5000 INFO d1 - 8.0000:d1:Customer21:Order quantity:30, available. INFO D1 - 8.0000:D1: Inventory levels:370, on hand:370 INFO d1 - 8.4000:d1:Customer22:Order quantity:30, available. INFO D1 - 8.4000:D1: Inventory levels:340, on hand:340 INFO d1 - 8.8000:d1:Customer23:Order quantity:30, available. INFO D1 - 8.8000:D1: Inventory levels:310, on hand:310 INFO S1 - 9.0000:S1: Inventory level:5000 INFO d1 - 9.2000:d1:Customer24:Order quantity:30, available. INFO D1 - 9.2000:D1: Inventory levels:280, on hand:280 INFO D1 - 9.2000:D1:Replenishing inventory from supplier:factory1, order placed for 720 units. INFO D1 - 9.2000:D1:shipment in transit from supplier:factory1. INFO F1 - 9.2000:F1: Inventory levels:1780, on hand:1780 INFO d1 - 9.6000:d1:Customer25:Order quantity:30, available. INFO D1 - 9.6000:D1: Inventory levels:250, on hand:970 INFO S1 - 10.0000:S1: Inventory level:5000 INFO d1 - 10.0000:d1:Customer26:Order quantity:30, available. INFO D1 - 10.0000:D1: Inventory levels:220, on hand:940 INFO d1 - 10.4000:d1:Customer27:Order quantity:30, available. INFO D1 - 10.4000:D1: Inventory levels:190, on hand:910 INFO d1 - 10.8000:d1:Customer28:Order quantity:30, available. INFO D1 - 10.8000:D1: Inventory levels:160, on hand:880 INFO S1 - 11.0000:S1: Inventory level:5000 INFO d1 - 11.2000:d1:Customer29:Order quantity:30, available. INFO D1 - 11.2000:D1: Inventory levels:130, on hand:850 INFO d1 - 11.6000:d1:Customer30:Order quantity:30, available. INFO D1 - 11.6000:D1: Inventory levels:100, on hand:820 INFO S1 - 12.0000:S1: Inventory level:5000 INFO d1 - 12.0000:d1:Customer31:Order quantity:30, available. INFO D1 - 12.0000:D1: Inventory levels:70, on hand:790 INFO D1 - 12.2000:D1:Inventory replenished. reorder_quantity=720, Inventory levels:790 INFO d1 - 12.4000:d1:Customer32:Order quantity:30, available. INFO D1 - 12.4000:D1: Inventory levels:760, on hand:760 INFO d1 - 12.8000:d1:Customer33:Order quantity:30, available. INFO D1 - 12.8000:D1: Inventory levels:730, on hand:730 INFO S1 - 13.0000:S1: Inventory level:5000 INFO d1 - 13.2000:d1:Customer34:Order quantity:30, available. INFO D1 - 13.2000:D1: Inventory levels:700, on hand:700 INFO d1 - 13.6000:d1:Customer35:Order quantity:30, available. INFO D1 - 13.6000:D1: Inventory levels:670, on hand:670 INFO S1 - 14.0000:S1: Inventory level:5000 INFO d1 - 14.0000:d1:Customer36:Order quantity:30, available. INFO D1 - 14.0000:D1: Inventory levels:640, on hand:640 INFO d1 - 14.4000:d1:Customer37:Order quantity:30, available. INFO D1 - 14.4000:D1: Inventory levels:610, on hand:610 INFO d1 - 14.8000:d1:Customer38:Order quantity:30, available. INFO D1 - 14.8000:D1: Inventory levels:580, on hand:580 INFO S1 - 15.0000:S1: Inventory level:5000 INFO d1 - 15.2000:d1:Customer39:Order quantity:30, available. INFO D1 - 15.2000:D1: Inventory levels:550, on hand:550 INFO d1 - 15.6000:d1:Customer40:Order quantity:30, available. INFO D1 - 15.6000:D1: Inventory levels:520, on hand:520 INFO S1 - 16.0000:S1: Inventory level:5000 INFO d1 - 16.0000:d1:Customer41:Order quantity:30, available. INFO D1 - 16.0000:D1: Inventory levels:490, on hand:490 INFO d1 - 16.4000:d1:Customer42:Order quantity:30, available. INFO D1 - 16.4000:D1: Inventory levels:460, on hand:460 INFO d1 - 16.8000:d1:Customer43:Order quantity:30, available. INFO D1 - 16.8000:D1: Inventory levels:430, on hand:430 INFO S1 - 17.0000:S1: Inventory level:5000 INFO d1 - 17.2000:d1:Customer44:Order quantity:30, available. INFO D1 - 17.2000:D1: Inventory levels:400, on hand:400 INFO d1 - 17.6000:d1:Customer45:Order quantity:30, available. INFO D1 - 17.6000:D1: Inventory levels:370, on hand:370 INFO S1 - 18.0000:S1: Inventory level:5000 INFO d1 - 18.0000:d1:Customer46:Order quantity:30, available. INFO D1 - 18.0000:D1: Inventory levels:340, on hand:340 INFO d1 - 18.4000:d1:Customer47:Order quantity:30, available. INFO D1 - 18.4000:D1: Inventory levels:310, on hand:310 INFO d1 - 18.8000:d1:Customer48:Order quantity:30, available. INFO D1 - 18.8000:D1: Inventory levels:280, on hand:280 INFO D1 - 18.8000:D1:Replenishing inventory from supplier:factory1, order placed for 720 units. INFO D1 - 18.8000:D1:shipment in transit from supplier:factory1. INFO F1 - 18.8000:F1: Inventory levels:1060, on hand:1060 INFO S1 - 19.0000:S1: Inventory level:5000 INFO d1 - 19.2000:d1:Customer49:Order quantity:30, available. INFO D1 - 19.2000:D1: Inventory levels:250, on hand:970 INFO d1 - 19.6000:d1:Customer50:Order quantity:30, available. INFO D1 - 19.6000:D1: Inventory levels:220, on hand:940 INFO d1 - 20.0000:d1:Customer51:Order quantity:30, available. INFO D1 - 20.0000:D1: Inventory levels:190, on hand:910 INFO sim_trace - Supply chain info: INFO sim_trace - available_inv : 6250 INFO sim_trace - avg_available_inv : 7634.5 INFO sim_trace - avg_cost_per_item : 8.663434343434345 INFO sim_trace - avg_cost_per_order : 485.4792452830189 INFO sim_trace - backorders : [0, 0] INFO sim_trace - demand_by_customers : [51, 1530] INFO sim_trace - demand_by_site : [2, 1440] INFO sim_trace - demands : {'d1': Demand1} INFO sim_trace - env : <simpy.core.Environment object at 0x00000196503EB290> INFO sim_trace - fulfillment_received_by_customers : [51, 1530] INFO sim_trace - fulfillment_received_by_site : [1, 720] INFO sim_trace - inventory_carry_cost : 3890.4 INFO sim_trace - inventory_spend_cost : 21600 INFO sim_trace - inventory_waste : 0 INFO sim_trace - links : {'L1': S1 to F1, 'L2': F1 to D1} INFO sim_trace - nodes : {'S1': supplier1, 'F1': factory1, 'D1': Distributor1} INFO sim_trace - num_distributors : 1 INFO sim_trace - num_manufacturers : 1 INFO sim_trace - num_of_links : 2 INFO sim_trace - num_of_nodes : 3 INFO sim_trace - num_retailers : 0 INFO sim_trace - num_suppliers : 1 INFO sim_trace - profit : 49419.6 INFO sim_trace - revenue : 75150.0 INFO sim_trace - shortage : [0, 0] INFO sim_trace - total_cost : 25730.4 INFO sim_trace - total_demand : [53, 2970] INFO sim_trace - total_fulfillment_received : [52, 2250] INFO sim_trace - transportation_cost : 240","title":"Supply Chain With Factory"},{"location":"example/#supply-chain-with-factory","text":"This example demonstrates how to create an end-to-end supply chain involving a raw material supplier, a factory, and a warehouse.","title":"Supply Chain With Factory"},{"location":"example/#creating-nodes","text":"In this scenario, we create a supplier with a limited inventory capacity. A raw material needs to be created and provided to the supplier when it is created with finite inventory. This raw material is defined by several parameters, including ID, name, extraction quantity, extraction time, and cost. The supplier is designed to hold only a single type of raw material in its inventory and is responsible for mining it to maintain inventory levels to fill capacity. import SupplyNetPy.Components as scm raw_mat1 = scm.RawMaterial(ID='rm1', name='raw_mat1', extraction_quantity=1000, extraction_time=1, mining_cost=0.5, cost=0.8) supplier1 = {'ID':'S1', 'name':'supplier1', 'node_type':'supplier', 'capacity':5000, 'initial_level':5000, 'inventory_holding_cost':0.01, 'raw_material':raw_mat1} Creating a factory requires a product. A product and a factory can be created and configured as follows. product1 = scm.Product(ID='p1', name='product1', manufacturing_cost=20, manufacturing_time=1, batch_size=1000, raw_materials=[(raw_mat1, 2)], sell_price=30) factory1 = {'ID':'F1', 'name':'factory1', 'node_type':'factory', 'capacity':2500, 'initial_level':2500, 'inventory_holding_cost':0.02, 'replenishment_policy':scm.SSReplenishment, 'policy_param': {'s':1000,'S':2500}, 'product':product1, 'product_sell_price':30} distributor1 = {'ID': 'D1', 'name': 'Distributor1', 'node_type': 'distributor', 'capacity': 1000, 'initial_level': 1000, 'inventory_holding_cost': 0.2, 'replenishment_policy': scm.SSReplenishment, 'policy_param': {'s':300,'S':1000}, 'product_buy_price':30,'product_sell_price': 35} The factory's behavior is to produce products based on a replenishment policy. In this example, inventory will be replenished when the level drops below a threshold (s). Therefore, the factory will begin manufacturing products once the inventory falls below this level and increase it back up to its maximum capacity (S).","title":"Creating Nodes"},{"location":"example/#defining-links","text":"Links represent the flow of products between nodes, with associated transportation costs and lead times. links1f1 = {'ID': 'L1', 'source': 'S1', 'sink': 'F1', 'cost': 100, 'lead_time': lambda: 2} linkf1d1 = {'ID': 'L2', 'source': 'F1', 'sink': 'D1', 'cost': 120, 'lead_time': lambda: 3}","title":"Defining Links"},{"location":"example/#modeling-demand","text":"Demand is generated at the distributor using deterministic arrival and quantity models. demand1 = {'ID': 'd1', 'name': 'Demand1', 'order_arrival_model': lambda: 0.4, 'order_quantity_model': lambda: 30, 'demand_node': 'D1'}","title":"Modeling Demand"},{"location":"example/#running-the-simulation","text":"Create the supply chain network and simulate it. supplychainnet = scm.create_sc_net(nodes=[supplier1, factory1, distributor1], links=[links1f1, linkf1d1], demands=[demand1]) supplychainnet = scm.simulate_sc_net(supplychainnet, sim_time=20, logging=True)","title":"Running the Simulation"},{"location":"example/#review-results","text":"Here is the simulation log generated by the network. INFO F1 - 0.0000:F1: Inventory levels:2500, on hand:2500 INFO D1 - 0.0000:D1: Inventory levels:1000, on hand:1000 INFO d1 - 0.0000:d1:Customer1:Order quantity:30, available. INFO D1 - 0.0000:D1: Inventory levels:970, on hand:970 INFO d1 - 0.4000:d1:Customer2:Order quantity:30, available. INFO D1 - 0.4000:D1: Inventory levels:940, on hand:940 INFO d1 - 0.8000:d1:Customer3:Order quantity:30, available. INFO D1 - 0.8000:D1: Inventory levels:910, on hand:910 INFO S1 - 1.0000:S1: Inventory level:5000 INFO d1 - 1.2000:d1:Customer4:Order quantity:30, available. INFO D1 - 1.2000:D1: Inventory levels:880, on hand:880 INFO d1 - 1.6000:d1:Customer5:Order quantity:30, available. INFO D1 - 1.6000:D1: Inventory levels:850, on hand:850 INFO S1 - 2.0000:S1: Inventory level:5000 INFO d1 - 2.0000:d1:Customer6:Order quantity:30, available. INFO D1 - 2.0000:D1: Inventory levels:820, on hand:820 INFO d1 - 2.4000:d1:Customer7:Order quantity:30, available. INFO D1 - 2.4000:D1: Inventory levels:790, on hand:790 INFO d1 - 2.8000:d1:Customer8:Order quantity:30, available. INFO D1 - 2.8000:D1: Inventory levels:760, on hand:760 INFO S1 - 3.0000:S1: Inventory level:5000 INFO d1 - 3.2000:d1:Customer9:Order quantity:30, available. INFO D1 - 3.2000:D1: Inventory levels:730, on hand:730 INFO d1 - 3.6000:d1:Customer10:Order quantity:30, available. INFO D1 - 3.6000:D1: Inventory levels:700, on hand:700 INFO d1 - 4.0000:d1:Customer11:Order quantity:30, available. INFO D1 - 4.0000:D1: Inventory levels:670, on hand:670 INFO S1 - 4.0000:S1: Inventory level:5000 INFO d1 - 4.4000:d1:Customer12:Order quantity:30, available. INFO D1 - 4.4000:D1: Inventory levels:640, on hand:640 INFO d1 - 4.8000:d1:Customer13:Order quantity:30, available. INFO D1 - 4.8000:D1: Inventory levels:610, on hand:610 INFO S1 - 5.0000:S1: Inventory level:5000 INFO d1 - 5.2000:d1:Customer14:Order quantity:30, available. INFO D1 - 5.2000:D1: Inventory levels:580, on hand:580 INFO d1 - 5.6000:d1:Customer15:Order quantity:30, available. INFO D1 - 5.6000:D1: Inventory levels:550, on hand:550 INFO S1 - 6.0000:S1: Inventory level:5000 INFO d1 - 6.0000:d1:Customer16:Order quantity:30, available. INFO D1 - 6.0000:D1: Inventory levels:520, on hand:520 INFO d1 - 6.4000:d1:Customer17:Order quantity:30, available. INFO D1 - 6.4000:D1: Inventory levels:490, on hand:490 INFO d1 - 6.8000:d1:Customer18:Order quantity:30, available. INFO D1 - 6.8000:D1: Inventory levels:460, on hand:460 INFO S1 - 7.0000:S1: Inventory level:5000 INFO d1 - 7.2000:d1:Customer19:Order quantity:30, available. INFO D1 - 7.2000:D1: Inventory levels:430, on hand:430 INFO d1 - 7.6000:d1:Customer20:Order quantity:30, available. INFO D1 - 7.6000:D1: Inventory levels:400, on hand:400 INFO S1 - 8.0000:S1: Inventory level:5000 INFO d1 - 8.0000:d1:Customer21:Order quantity:30, available. INFO D1 - 8.0000:D1: Inventory levels:370, on hand:370 INFO d1 - 8.4000:d1:Customer22:Order quantity:30, available. INFO D1 - 8.4000:D1: Inventory levels:340, on hand:340 INFO d1 - 8.8000:d1:Customer23:Order quantity:30, available. INFO D1 - 8.8000:D1: Inventory levels:310, on hand:310 INFO S1 - 9.0000:S1: Inventory level:5000 INFO d1 - 9.2000:d1:Customer24:Order quantity:30, available. INFO D1 - 9.2000:D1: Inventory levels:280, on hand:280 INFO D1 - 9.2000:D1:Replenishing inventory from supplier:factory1, order placed for 720 units. INFO D1 - 9.2000:D1:shipment in transit from supplier:factory1. INFO F1 - 9.2000:F1: Inventory levels:1780, on hand:1780 INFO d1 - 9.6000:d1:Customer25:Order quantity:30, available. INFO D1 - 9.6000:D1: Inventory levels:250, on hand:970 INFO S1 - 10.0000:S1: Inventory level:5000 INFO d1 - 10.0000:d1:Customer26:Order quantity:30, available. INFO D1 - 10.0000:D1: Inventory levels:220, on hand:940 INFO d1 - 10.4000:d1:Customer27:Order quantity:30, available. INFO D1 - 10.4000:D1: Inventory levels:190, on hand:910 INFO d1 - 10.8000:d1:Customer28:Order quantity:30, available. INFO D1 - 10.8000:D1: Inventory levels:160, on hand:880 INFO S1 - 11.0000:S1: Inventory level:5000 INFO d1 - 11.2000:d1:Customer29:Order quantity:30, available. INFO D1 - 11.2000:D1: Inventory levels:130, on hand:850 INFO d1 - 11.6000:d1:Customer30:Order quantity:30, available. INFO D1 - 11.6000:D1: Inventory levels:100, on hand:820 INFO S1 - 12.0000:S1: Inventory level:5000 INFO d1 - 12.0000:d1:Customer31:Order quantity:30, available. INFO D1 - 12.0000:D1: Inventory levels:70, on hand:790 INFO D1 - 12.2000:D1:Inventory replenished. reorder_quantity=720, Inventory levels:790 INFO d1 - 12.4000:d1:Customer32:Order quantity:30, available. INFO D1 - 12.4000:D1: Inventory levels:760, on hand:760 INFO d1 - 12.8000:d1:Customer33:Order quantity:30, available. INFO D1 - 12.8000:D1: Inventory levels:730, on hand:730 INFO S1 - 13.0000:S1: Inventory level:5000 INFO d1 - 13.2000:d1:Customer34:Order quantity:30, available. INFO D1 - 13.2000:D1: Inventory levels:700, on hand:700 INFO d1 - 13.6000:d1:Customer35:Order quantity:30, available. INFO D1 - 13.6000:D1: Inventory levels:670, on hand:670 INFO S1 - 14.0000:S1: Inventory level:5000 INFO d1 - 14.0000:d1:Customer36:Order quantity:30, available. INFO D1 - 14.0000:D1: Inventory levels:640, on hand:640 INFO d1 - 14.4000:d1:Customer37:Order quantity:30, available. INFO D1 - 14.4000:D1: Inventory levels:610, on hand:610 INFO d1 - 14.8000:d1:Customer38:Order quantity:30, available. INFO D1 - 14.8000:D1: Inventory levels:580, on hand:580 INFO S1 - 15.0000:S1: Inventory level:5000 INFO d1 - 15.2000:d1:Customer39:Order quantity:30, available. INFO D1 - 15.2000:D1: Inventory levels:550, on hand:550 INFO d1 - 15.6000:d1:Customer40:Order quantity:30, available. INFO D1 - 15.6000:D1: Inventory levels:520, on hand:520 INFO S1 - 16.0000:S1: Inventory level:5000 INFO d1 - 16.0000:d1:Customer41:Order quantity:30, available. INFO D1 - 16.0000:D1: Inventory levels:490, on hand:490 INFO d1 - 16.4000:d1:Customer42:Order quantity:30, available. INFO D1 - 16.4000:D1: Inventory levels:460, on hand:460 INFO d1 - 16.8000:d1:Customer43:Order quantity:30, available. INFO D1 - 16.8000:D1: Inventory levels:430, on hand:430 INFO S1 - 17.0000:S1: Inventory level:5000 INFO d1 - 17.2000:d1:Customer44:Order quantity:30, available. INFO D1 - 17.2000:D1: Inventory levels:400, on hand:400 INFO d1 - 17.6000:d1:Customer45:Order quantity:30, available. INFO D1 - 17.6000:D1: Inventory levels:370, on hand:370 INFO S1 - 18.0000:S1: Inventory level:5000 INFO d1 - 18.0000:d1:Customer46:Order quantity:30, available. INFO D1 - 18.0000:D1: Inventory levels:340, on hand:340 INFO d1 - 18.4000:d1:Customer47:Order quantity:30, available. INFO D1 - 18.4000:D1: Inventory levels:310, on hand:310 INFO d1 - 18.8000:d1:Customer48:Order quantity:30, available. INFO D1 - 18.8000:D1: Inventory levels:280, on hand:280 INFO D1 - 18.8000:D1:Replenishing inventory from supplier:factory1, order placed for 720 units. INFO D1 - 18.8000:D1:shipment in transit from supplier:factory1. INFO F1 - 18.8000:F1: Inventory levels:1060, on hand:1060 INFO S1 - 19.0000:S1: Inventory level:5000 INFO d1 - 19.2000:d1:Customer49:Order quantity:30, available. INFO D1 - 19.2000:D1: Inventory levels:250, on hand:970 INFO d1 - 19.6000:d1:Customer50:Order quantity:30, available. INFO D1 - 19.6000:D1: Inventory levels:220, on hand:940 INFO d1 - 20.0000:d1:Customer51:Order quantity:30, available. INFO D1 - 20.0000:D1: Inventory levels:190, on hand:910 INFO sim_trace - Supply chain info: INFO sim_trace - available_inv : 6250 INFO sim_trace - avg_available_inv : 7634.5 INFO sim_trace - avg_cost_per_item : 8.663434343434345 INFO sim_trace - avg_cost_per_order : 485.4792452830189 INFO sim_trace - backorders : [0, 0] INFO sim_trace - demand_by_customers : [51, 1530] INFO sim_trace - demand_by_site : [2, 1440] INFO sim_trace - demands : {'d1': Demand1} INFO sim_trace - env : <simpy.core.Environment object at 0x00000196503EB290> INFO sim_trace - fulfillment_received_by_customers : [51, 1530] INFO sim_trace - fulfillment_received_by_site : [1, 720] INFO sim_trace - inventory_carry_cost : 3890.4 INFO sim_trace - inventory_spend_cost : 21600 INFO sim_trace - inventory_waste : 0 INFO sim_trace - links : {'L1': S1 to F1, 'L2': F1 to D1} INFO sim_trace - nodes : {'S1': supplier1, 'F1': factory1, 'D1': Distributor1} INFO sim_trace - num_distributors : 1 INFO sim_trace - num_manufacturers : 1 INFO sim_trace - num_of_links : 2 INFO sim_trace - num_of_nodes : 3 INFO sim_trace - num_retailers : 0 INFO sim_trace - num_suppliers : 1 INFO sim_trace - profit : 49419.6 INFO sim_trace - revenue : 75150.0 INFO sim_trace - shortage : [0, 0] INFO sim_trace - total_cost : 25730.4 INFO sim_trace - total_demand : [53, 2970] INFO sim_trace - total_fulfillment_received : [52, 2250] INFO sim_trace - transportation_cost : 240","title":"Review Results"},{"location":"known-issues/","text":"Known Issues and Planned Work This page lists known issues, current limitations, and planned improvements for upcoming versions of SupplyNetPy . Known Issues \u26a0\ufe0f Loops in a Supply Chain : The library does not check for loops in the network. It is possible to create a supply chain with loops, for example, when two distribution centers are connected to overcome shortages during supply. \u26a0\ufe0f Simultaneous Events : When multiple events are scheduled at the same time (e.g., at time t=10), they are executed sequentially, one after another. SupplyNetPy is built on SimPy and executes events according to event IDs (as in SimPy). For deterministic simulations, the same output is generated for each run. \u26a0\ufe0f Simulation Parallelization : Currently, SupplyNetPy does not support parallelizing the simulation model. \u26a0\ufe0f Real-Time Simulation : Real-time simulation is not supported. Planned Work Case Studies : Real-world supply chain models. Logistics Operations : Geographic map locations, CO\u2082 calculations, and fleet management. Node/Link Disruption : For resilience and risk assessment, this feature will interrupt events impacted by disruptions (earthquakes, natural calamities, pandemics, etc.). Simulation Parallelization : To enable faster execution of the model and support real-time simulation. Simulation-Based Optimization (SBO) : Integration of optimization methods from Python's SciPy library to support SBO.","title":"Known Issues and Planned Work"},{"location":"known-issues/#known-issues-and-planned-work","text":"This page lists known issues, current limitations, and planned improvements for upcoming versions of SupplyNetPy .","title":"Known Issues and Planned Work"},{"location":"known-issues/#known-issues","text":"\u26a0\ufe0f Loops in a Supply Chain : The library does not check for loops in the network. It is possible to create a supply chain with loops, for example, when two distribution centers are connected to overcome shortages during supply. \u26a0\ufe0f Simultaneous Events : When multiple events are scheduled at the same time (e.g., at time t=10), they are executed sequentially, one after another. SupplyNetPy is built on SimPy and executes events according to event IDs (as in SimPy). For deterministic simulations, the same output is generated for each run. \u26a0\ufe0f Simulation Parallelization : Currently, SupplyNetPy does not support parallelizing the simulation model. \u26a0\ufe0f Real-Time Simulation : Real-time simulation is not supported.","title":"Known Issues"},{"location":"known-issues/#planned-work","text":"Case Studies : Real-world supply chain models. Logistics Operations : Geographic map locations, CO\u2082 calculations, and fleet management. Node/Link Disruption : For resilience and risk assessment, this feature will interrupt events impacted by disruptions (earthquakes, natural calamities, pandemics, etc.). Simulation Parallelization : To enable faster execution of the model and support real-time simulation. Simulation-Based Optimization (SBO) : Integration of optimization methods from Python's SciPy library to support SBO.","title":"Planned Work"},{"location":"license/","text":"License MIT License Copyright (c) 2024 Tushar Lone, Neha Karanjkar, Lekshmi P. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright (c) 2024 Tushar Lone, Neha Karanjkar, Lekshmi P. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"safety_inv_est/","text":"img{ width:75%; } This example is from the textbook Supply Chain Management: Strategy, Planning, and Operation, (Chopra and Meindl) Find the Google Colab notebook for this example here . Estimating Safety Stock Level Safety inventory can help a supply chain improve product availability in the presence of supply and demand variability. Image source: [Textbook] Supply Chain Management: Strategy, Planning, and Operation, (Chopra and Meindl) System Description Bloomingdale sells Gucci purses. Demand is 100 per week. Gucci takes 3 weeks to deliver purses to Bloomingdale in response to an order. Therfore Bloomingdale can place an order when exactly 300 purses are remaining in the inventory. Given deand fluctuations, demand over three weeks may be higher or lower than that of 300. If it is higher, Bloomingdale will lose sales. The store manager decides to put an order of 400 purses (therfore, safety level is 100). Goal: To determine the appropriate level of safety inventory. Replinishment policies: Continuous review: Inventory is continuously tracked, and an order for a lot size Q is placed when the inventory declines to the reorder point (ROP). As an example, consider the store manager at B&M who continuously tracks the inventory of phones. She orders 600 phones when the inventory drops below ROP 400. In this case, the size of the order does not change from one order to the next. The time between orders may fluctuate given variable demand. Periodic review: Inventory status is checked at regular periodic intervals, and an order is placed to raise the inventory level to a specified threshold. As an example, consider the purchase of film at B&M. The store manager does not track film inventory continuously. Every Thursday, employees check film inventory, and the manager orders enough so that the total of the available inventory and the size of the order equals 1,000 films. In this case, the time between orders is fixed. The size of each order, however, can fluctuate given variable demand. Numerical Example Evaluating Safety Inventory, Given an Inventory Policy Assume that weekly demand for phones at B&M Office Supplies is normally distributed, with a mean of 2,500 and a standard deviation of 500. The manufacturer takes two weeks to fill an order placed by the B&M manager. The store manager currently orders 10,000 phones when the inventory on hand drops to 6,000. Evaluate the safety inventory and the average inventory carried by B&M. Also evaluate the average time a phone spends at B&M. Analytical Solution: Under this replenishment policy, we have Average demand per week, \\(D = 2500\\) Standard deviation of weekly demand, \\(\\sigma_D = 500\\) Average lead tme for replenishment, \\(L = 2\\) Weeks Reorder point \\(ROP = 6000\\) Average lot size \\(Q = 10000\\) using eq 12.3 in the textbook, safety inv, \\(ss = ROP - D^*L = 6000-5000 = 1000\\) B&M thus carries a safety inventory of 1,000 phones. Cycle inventory = \\(\\frac{Q}{3} = \\frac{10000}{2} = 5000\\) Average inventory = cycle inventory + safety inventory \\(= 5000 + 1000 = 6000\\) Average flow time = average inventory/throughput \\(= \\frac{6000}{2500} = 2.4\\) weeks System: Cost per unit, transportation cost is not given. So we can assume anything. We want to find Safety inventory level (the average number of phones on hand when a replenishment order arrives). Cycle inventory (average inventory levels) Average flowtime (average time spent by a product in the inventory) Implementation import simpy import numpy as np import matplotlib.pyplot as plt import SupplyNetPy.Components as scm daily_demand_mean = 2500/7 daily_demand_std = 500/(7**0.5) simlen = 3650 # simulation length in days def normal_quantity(): global daily_demand_mean, daily_demand_std sample = -1 while sample < 0: sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] return sample env = simpy.Environment() # create an infinite supplier supplier1 = scm.Supplier(env=env, ID=\"S1\", name=\"Supplier1\", node_type=\"infinite_supplier\") #create the distributor distributor1 = scm.InventoryNode(env=env, ID=\"D1\", name=\"Distributor1\", node_type=\"distributor\", capacity=float('inf'), initial_level=6000, inventory_holding_cost=0.1, product_buy_price=0, replenishment_policy=scm.RQReplenishment, policy_param={'R':6000,'Q':10000}, product_sell_price=399) link1 = scm.Link(env=env,ID=\"l1\", source=supplier1, sink=distributor1, cost=100, lead_time=lambda: 14) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, order_quantity_model=normal_quantity, demand_node=distributor1) scm.global_logger.disable_logging() # disable logging env.run(until=simlen) # calculate performance metrics safety_stock = [] replenish_cycles = [0] inv_levels = np.array(distributor1.inventory.instantaneous_levels) # instantaneous inventory levels # lets calculate safety stock level for i in range(len(inv_levels)-1): if(inv_levels[i,1]<inv_levels[i+1,1]): # inventory level is increasing that means a replenishment order is received safety_stock.append(inv_levels[i,1]) replenish_cycles.append(inv_levels[i,0]) # time of replenishment order # calculate average flow time (amount of time an item is stored in inventory) flow_time = [] for i in range(len(replenish_cycles)-1): flow_time.append(replenish_cycles[i+1]-replenish_cycles[i]) print(\"\\n\\t***\\nSafety Stock Level: \", np.mean(safety_stock)) print(\"Average Inventory Level:\", np.mean(inv_levels[:,1])) print(\"Average Flow Time: \", np.mean(flow_time)/2, \"days\",\"\\n\") # plot the inventory level over time plt.plot(inv_levels[:,0], inv_levels[:,1], marker='.', label=\"Inventory Level\", color='green', linestyle='') plt.axhline(y=6000, color='r', linestyle='--', label=\"ROP\") plt.xlabel(\"Time (days)\") plt.ylabel(\"Inventory Level\") plt.title(\"Inventory Level over Time\") plt.legend() plt.grid() plt.show() *** Safety Stock Level: 1315.2294619614904 Average Inventory Level: 6207.3688497299245 Average Flow Time: 13.57089552238806 days Since the demand at the B&M office is unpredictable, we will estimate the safety inventory by conducting multiple simulations. First, we will define a function to simulate the B&M office sales. We will then use this function to run several simulations. def bnmoffice(): env = simpy.Environment() # create an infinite supplier supplier1 = scm.Supplier(env=env, ID=\"S1\", name=\"Supplier1\", node_type=\"infinite_supplier\") #create the distributor distributor1 = scm.InventoryNode(env=env, ID=\"D1\", name=\"Distributor1\", node_type=\"distributor\", capacity=16000, initial_level=6000, inventory_holding_cost=0.1, product_buy_price=0, replenishment_policy=scm.SSReplenishment, policy_param={'s':6000,'S':16000}, product_sell_price=399) link1 = scm.Link(env=env,ID=\"l1\", source=supplier1, sink=distributor1, cost=100, lead_time=lambda: 14) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, order_quantity_model=normal_quantity, demand_node=distributor1) scm.global_logger.disable_logging() # disable logging env.run(until=simlen) # calculate performance metrics safety_stock = [] replenish_cycles = [0] inv_levels = np.array(distributor1.inventory.instantaneous_levels) # instantaneous inventory levels # lets calculate safety stock level for i in range(len(inv_levels)-1): if(inv_levels[i,1]<inv_levels[i+1,1]): # inventory level is increasing that means a replenishment order is received safety_stock.append(inv_levels[i,1]) replenish_cycles.append(inv_levels[i,0]) # time of replenishment order # calculate average flow time (amount of time an item is stored in inventory) flow_time = [] for i in range(len(replenish_cycles)-1): flow_time.append(replenish_cycles[i+1]-replenish_cycles[i]) return np.mean(safety_stock), np.mean(inv_levels[:,1]), np.mean(flow_time)/2 num_simulations = 100 ana_arr = [] # let us gather all stats in this variable for i in range(0,num_simulations): ana_arr.append([]) safety_stock, avg_inv, flow_t = bnmoffice() ana_arr[-1].extend([safety_stock, avg_inv, flow_t]) ana_arr = np.array(ana_arr) # convert to array for convenience #Final Stats print(\"\\n\\t***\\nSafety Stock Level: Mean: \", np.mean(ana_arr[:,0]), \" Std:\", np.std(ana_arr[:,0])) print(\"Average Inventory Level:\", np.mean(ana_arr[:,1]), \" Std:\", np.std(ana_arr[:,1])) print(\"Average Flow Time: \", np.mean(ana_arr[:,2]), \"days\",\"\\n\", \" Std:\", np.std(ana_arr[:,2])) Results *** Safety Stock Level: Mean: 1347.9523813366336 Std: 54.85624022638165 Average Inventory Level: 6315.472134834441 Std: 42.11831759963809 Average Flow Time: 13.820451583252883 days Std: 0.1074252955034431 We obtain a slightly higher safety level, and average inventory levels from the simulation because sampling from a normal distribution can yield a few values less than zero. In our method, normal_quantity() , we resample in such cases to ensure that we only get numbers that are greater than or equal to zero, as negative demand is not possible. This resampling increases the probability of obtaining positive values. We will demonstrate this further below. def normal_quantity(): \"\"\" Normal Distribution with given mean, and std A new sample is generated for every negative sample \"\"\" global daily_demand_mean, daily_demand_std sample = -1 while sample < 0: sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] return sample def normal_quantity_mean(): \"\"\" Normal Distribution with given mean, and std The mean value replaces a negative sample \"\"\" global daily_demand_mean, daily_demand_std sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] if sample < 0: sample = daily_demand_mean return sample def normal_quantity_wn(): \"\"\" Normal Distribution with given mean, and std including negatives \"\"\" global daily_demand_mean, daily_demand_std sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] return sample samples = [] samples_wn = [] samples_mean = [] for r in range(5000): samples.append(normal_quantity()) samples_wn.append(normal_quantity_wn()) samples_mean.append(normal_quantity_mean()) plt.figure(figsize=(5, 3)) plt.hist(samples, bins=50, density=True, alpha=0.5, color='blue', label='Normal without negatives') plt.title('Normal') plt.xlabel('Quantity') plt.ylabel('Density') plt.grid() plt.legend() plt.figure(figsize=(5, 3)) plt.hist(samples_wn, bins=50, density=True, alpha=0.5, color='green', label='Normal with negatives') #plt.title('Normal without negative quantities') plt.xlabel('Quantity') plt.ylabel('Density') plt.grid() plt.legend() plt.figure(figsize=(5, 3)) plt.hist(samples_mean, bins=50, density=True, alpha=0.5, color='red', label='Normal: replace mean for negatives') #plt.title('Normal with mean for negative quantities') plt.xlabel('Quantity') plt.ylabel('Density') plt.grid() plt.legend()","title":"Estimating Safety Stock"},{"location":"safety_inv_est/#estimating-safety-stock-level","text":"Safety inventory can help a supply chain improve product availability in the presence of supply and demand variability. Image source: [Textbook] Supply Chain Management: Strategy, Planning, and Operation, (Chopra and Meindl)","title":"Estimating Safety Stock Level"},{"location":"safety_inv_est/#system-description","text":"Bloomingdale sells Gucci purses. Demand is 100 per week. Gucci takes 3 weeks to deliver purses to Bloomingdale in response to an order. Therfore Bloomingdale can place an order when exactly 300 purses are remaining in the inventory. Given deand fluctuations, demand over three weeks may be higher or lower than that of 300. If it is higher, Bloomingdale will lose sales. The store manager decides to put an order of 400 purses (therfore, safety level is 100). Goal: To determine the appropriate level of safety inventory. Replinishment policies: Continuous review: Inventory is continuously tracked, and an order for a lot size Q is placed when the inventory declines to the reorder point (ROP). As an example, consider the store manager at B&M who continuously tracks the inventory of phones. She orders 600 phones when the inventory drops below ROP 400. In this case, the size of the order does not change from one order to the next. The time between orders may fluctuate given variable demand. Periodic review: Inventory status is checked at regular periodic intervals, and an order is placed to raise the inventory level to a specified threshold. As an example, consider the purchase of film at B&M. The store manager does not track film inventory continuously. Every Thursday, employees check film inventory, and the manager orders enough so that the total of the available inventory and the size of the order equals 1,000 films. In this case, the time between orders is fixed. The size of each order, however, can fluctuate given variable demand.","title":"System Description"},{"location":"safety_inv_est/#numerical-example","text":"Evaluating Safety Inventory, Given an Inventory Policy Assume that weekly demand for phones at B&M Office Supplies is normally distributed, with a mean of 2,500 and a standard deviation of 500. The manufacturer takes two weeks to fill an order placed by the B&M manager. The store manager currently orders 10,000 phones when the inventory on hand drops to 6,000. Evaluate the safety inventory and the average inventory carried by B&M. Also evaluate the average time a phone spends at B&M. Analytical Solution: Under this replenishment policy, we have Average demand per week, \\(D = 2500\\) Standard deviation of weekly demand, \\(\\sigma_D = 500\\) Average lead tme for replenishment, \\(L = 2\\) Weeks Reorder point \\(ROP = 6000\\) Average lot size \\(Q = 10000\\) using eq 12.3 in the textbook, safety inv, \\(ss = ROP - D^*L = 6000-5000 = 1000\\) B&M thus carries a safety inventory of 1,000 phones. Cycle inventory = \\(\\frac{Q}{3} = \\frac{10000}{2} = 5000\\) Average inventory = cycle inventory + safety inventory \\(= 5000 + 1000 = 6000\\) Average flow time = average inventory/throughput \\(= \\frac{6000}{2500} = 2.4\\) weeks System: Cost per unit, transportation cost is not given. So we can assume anything. We want to find Safety inventory level (the average number of phones on hand when a replenishment order arrives). Cycle inventory (average inventory levels) Average flowtime (average time spent by a product in the inventory)","title":"Numerical Example"},{"location":"safety_inv_est/#implementation","text":"import simpy import numpy as np import matplotlib.pyplot as plt import SupplyNetPy.Components as scm daily_demand_mean = 2500/7 daily_demand_std = 500/(7**0.5) simlen = 3650 # simulation length in days def normal_quantity(): global daily_demand_mean, daily_demand_std sample = -1 while sample < 0: sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] return sample env = simpy.Environment() # create an infinite supplier supplier1 = scm.Supplier(env=env, ID=\"S1\", name=\"Supplier1\", node_type=\"infinite_supplier\") #create the distributor distributor1 = scm.InventoryNode(env=env, ID=\"D1\", name=\"Distributor1\", node_type=\"distributor\", capacity=float('inf'), initial_level=6000, inventory_holding_cost=0.1, product_buy_price=0, replenishment_policy=scm.RQReplenishment, policy_param={'R':6000,'Q':10000}, product_sell_price=399) link1 = scm.Link(env=env,ID=\"l1\", source=supplier1, sink=distributor1, cost=100, lead_time=lambda: 14) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, order_quantity_model=normal_quantity, demand_node=distributor1) scm.global_logger.disable_logging() # disable logging env.run(until=simlen) # calculate performance metrics safety_stock = [] replenish_cycles = [0] inv_levels = np.array(distributor1.inventory.instantaneous_levels) # instantaneous inventory levels # lets calculate safety stock level for i in range(len(inv_levels)-1): if(inv_levels[i,1]<inv_levels[i+1,1]): # inventory level is increasing that means a replenishment order is received safety_stock.append(inv_levels[i,1]) replenish_cycles.append(inv_levels[i,0]) # time of replenishment order # calculate average flow time (amount of time an item is stored in inventory) flow_time = [] for i in range(len(replenish_cycles)-1): flow_time.append(replenish_cycles[i+1]-replenish_cycles[i]) print(\"\\n\\t***\\nSafety Stock Level: \", np.mean(safety_stock)) print(\"Average Inventory Level:\", np.mean(inv_levels[:,1])) print(\"Average Flow Time: \", np.mean(flow_time)/2, \"days\",\"\\n\") # plot the inventory level over time plt.plot(inv_levels[:,0], inv_levels[:,1], marker='.', label=\"Inventory Level\", color='green', linestyle='') plt.axhline(y=6000, color='r', linestyle='--', label=\"ROP\") plt.xlabel(\"Time (days)\") plt.ylabel(\"Inventory Level\") plt.title(\"Inventory Level over Time\") plt.legend() plt.grid() plt.show() *** Safety Stock Level: 1315.2294619614904 Average Inventory Level: 6207.3688497299245 Average Flow Time: 13.57089552238806 days Since the demand at the B&M office is unpredictable, we will estimate the safety inventory by conducting multiple simulations. First, we will define a function to simulate the B&M office sales. We will then use this function to run several simulations. def bnmoffice(): env = simpy.Environment() # create an infinite supplier supplier1 = scm.Supplier(env=env, ID=\"S1\", name=\"Supplier1\", node_type=\"infinite_supplier\") #create the distributor distributor1 = scm.InventoryNode(env=env, ID=\"D1\", name=\"Distributor1\", node_type=\"distributor\", capacity=16000, initial_level=6000, inventory_holding_cost=0.1, product_buy_price=0, replenishment_policy=scm.SSReplenishment, policy_param={'s':6000,'S':16000}, product_sell_price=399) link1 = scm.Link(env=env,ID=\"l1\", source=supplier1, sink=distributor1, cost=100, lead_time=lambda: 14) demand1 = scm.Demand(env=env,ID=\"d1\", name=\"demand_d1\", order_arrival_model=lambda: 1, order_quantity_model=normal_quantity, demand_node=distributor1) scm.global_logger.disable_logging() # disable logging env.run(until=simlen) # calculate performance metrics safety_stock = [] replenish_cycles = [0] inv_levels = np.array(distributor1.inventory.instantaneous_levels) # instantaneous inventory levels # lets calculate safety stock level for i in range(len(inv_levels)-1): if(inv_levels[i,1]<inv_levels[i+1,1]): # inventory level is increasing that means a replenishment order is received safety_stock.append(inv_levels[i,1]) replenish_cycles.append(inv_levels[i,0]) # time of replenishment order # calculate average flow time (amount of time an item is stored in inventory) flow_time = [] for i in range(len(replenish_cycles)-1): flow_time.append(replenish_cycles[i+1]-replenish_cycles[i]) return np.mean(safety_stock), np.mean(inv_levels[:,1]), np.mean(flow_time)/2 num_simulations = 100 ana_arr = [] # let us gather all stats in this variable for i in range(0,num_simulations): ana_arr.append([]) safety_stock, avg_inv, flow_t = bnmoffice() ana_arr[-1].extend([safety_stock, avg_inv, flow_t]) ana_arr = np.array(ana_arr) # convert to array for convenience #Final Stats print(\"\\n\\t***\\nSafety Stock Level: Mean: \", np.mean(ana_arr[:,0]), \" Std:\", np.std(ana_arr[:,0])) print(\"Average Inventory Level:\", np.mean(ana_arr[:,1]), \" Std:\", np.std(ana_arr[:,1])) print(\"Average Flow Time: \", np.mean(ana_arr[:,2]), \"days\",\"\\n\", \" Std:\", np.std(ana_arr[:,2]))","title":"Implementation"},{"location":"safety_inv_est/#results","text":"*** Safety Stock Level: Mean: 1347.9523813366336 Std: 54.85624022638165 Average Inventory Level: 6315.472134834441 Std: 42.11831759963809 Average Flow Time: 13.820451583252883 days Std: 0.1074252955034431 We obtain a slightly higher safety level, and average inventory levels from the simulation because sampling from a normal distribution can yield a few values less than zero. In our method, normal_quantity() , we resample in such cases to ensure that we only get numbers that are greater than or equal to zero, as negative demand is not possible. This resampling increases the probability of obtaining positive values. We will demonstrate this further below. def normal_quantity(): \"\"\" Normal Distribution with given mean, and std A new sample is generated for every negative sample \"\"\" global daily_demand_mean, daily_demand_std sample = -1 while sample < 0: sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] return sample def normal_quantity_mean(): \"\"\" Normal Distribution with given mean, and std The mean value replaces a negative sample \"\"\" global daily_demand_mean, daily_demand_std sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] if sample < 0: sample = daily_demand_mean return sample def normal_quantity_wn(): \"\"\" Normal Distribution with given mean, and std including negatives \"\"\" global daily_demand_mean, daily_demand_std sample = np.random.normal(daily_demand_mean, daily_demand_std, 1)[0] return sample samples = [] samples_wn = [] samples_mean = [] for r in range(5000): samples.append(normal_quantity()) samples_wn.append(normal_quantity_wn()) samples_mean.append(normal_quantity_mean()) plt.figure(figsize=(5, 3)) plt.hist(samples, bins=50, density=True, alpha=0.5, color='blue', label='Normal without negatives') plt.title('Normal') plt.xlabel('Quantity') plt.ylabel('Density') plt.grid() plt.legend() plt.figure(figsize=(5, 3)) plt.hist(samples_wn, bins=50, density=True, alpha=0.5, color='green', label='Normal with negatives') #plt.title('Normal without negative quantities') plt.xlabel('Quantity') plt.ylabel('Density') plt.grid() plt.legend() plt.figure(figsize=(5, 3)) plt.hist(samples_mean, bins=50, density=True, alpha=0.5, color='red', label='Normal: replace mean for negatives') #plt.title('Normal with mean for negative quantities') plt.xlabel('Quantity') plt.ylabel('Density') plt.grid() plt.legend()","title":"Results"},{"location":"ten_min/","text":"SupplyNetPy in 10 Minutes Installation SupplyNetPy can be installed using pip: pip install supplynetpy Quick Start: Building a Simple Three-Node Supply Chain Follow these steps to create and simulate a basic supply chain with a supplier and a manufacturer: Import the Library import SupplyNetPy.Components as scm The Components module in SupplyNetPy offers essential building blocks for constructing supply chain networks. It enables us to define supply chain nodes, products, inventory, demand, and the links that connect them. We can easily assemble and customize supply chain models using these constructs to suit particular requirements. Create Nodes Let us create a supplier node in the supply chain that has infinite inventory and can supply any required quantity of product units to a consumer node. The supplier node requires several parameters, including ID, name, and node type. To set it as an infinite supplier, we must specify the node type as infinite_supplier . supplier1 = {'ID': 'S1', 'name': 'Supplier1', 'node_type': 'infinite_supplier'} A distributor or warehouse node that purchases products from a supplier is created below by specifying configurable parameters, including ID, name, inventory capacity, replenishment policy, policy parameters, product buy price, and product sell price. distributor1 = {'ID': 'D1', 'name': 'Distributor1', 'node_type': 'distributor', 'capacity': 150, 'initial_level': 50, 'inventory_holding_cost': 0.2, 'replenishment_policy': scm.SSReplenishment, 'policy_param': {'s':100,'S':150}, 'product_buy_price': 100,'product_sell_price': 105} When creating a manufacturer, distributor, wholesaler, or retailer, we must specify the inventory replenishment policy and its parameters. The SupplyNetPy Components module includes an InventoryReplenishment class that can be customized to define specific replenishment policies. Currently, SupplyNetPy supports the following replenishment policies: Reorder-level (s,S) \u2014 continuously monitor inventory and replenish up to S when the level drops below s. Parameters: {s, S} (class SSReplenishment ) Reorder-level (s,S) with Safety Stock \u2014 reorder-level replenishment that factors in a safety stock buffer. Parameters: {s, S, safety_stock} ( SSReplenishment ) Replenish Quantity (RQ) \u2014 reorder a fixed quantity Q when placing an order. Parameters: {R, Q} ( RQReplenishment ) Replenish Quantity (RQ) with safety stock \u2014 reorder a fixed quantity Q when placing an order. Parameters: {R, Q, safety_stock} ( RQReplenishment ) Periodic (T,Q) \u2014 replenish inventory every T days with Q units. Parameters: {T, Q} ( PeriodicReplenishment ) Periodic (T,Q) with safety stock \u2014 replenish inventory every T days with Q units. If safety stock is specified, then when the safety stock level is violated, order Q units in addition to the quantity needed to maintain safety stock levels. Parameters: {T, Q, safety_stock} ( PeriodicReplenishment ) Create a Link A link is created as described below. It is configured using parameters such as transportation cost and lead time. The lead time parameter accepts a generative function that produces random lead times based on a specified distribution. Users can create this function according to their needs or define a constant lead time using a Python lambda function. link1 = {'ID': 'L1', 'source': 'S1', 'sink': 'D1', 'cost': 5, 'lead_time': lambda: 2} Specify Demand A demand is created by specifying an ID, name, demand node, order arrival time, and order quantity. The order arrival parameter accepts a generator function that produces random arrival times, while the order quantity parameter takes a generator function that produces random quantities. Users can define a function that models these arrivals and quantities or use Python's lambda function to create a deterministic demand, as shown below. A demand can be created at either a distributor node or a retailer. In this example, we have created a steady demand for 10 daily units at distributor D1. demand1 = {'ID': 'd1', 'name': 'Demand1', 'order_arrival_model': lambda: 1, 'order_quantity_model': lambda: 10, 'demand_node': 'D1'} Assemble and Simulate the Network To create and simulate the supply chain, use the create_sc_net function to instantiate the supply chain nodes and assemble them into a network. This function adds metadata to the supply chain, such as the number of nodes, and other relevant information, keeping everything organized. It returns a Python dictionary containing all supply chain components and metadata. The simulate_sc_net function then simulates the supply chain network over a specified period and provides a log of the simulation run. It also calculates performance measures such as net profit, throughput, and more. Let's use these functions to build and simulate our supply chain. # create a supply chain network supplychainnet = scm.create_sc_net(nodes=[supplier1, distributor1], links=[link1], demands=[demand1]) # simulate for 20 days supplychainnet = scm.simulate_sc_net(supplychainnet, sim_time=20, logging=True) Review Results After the simulation, inspect supplychainnet to view performance metrics for the supply chain nodes. By default, the simulation log is displayed in the console and saved to a local file named simulation_trace.log , which is located in the same directory as the Python script. Each node in the simulation has its own logger, and logging can be enabled or disabled by providing an additional parameter: logging=True or logging=False while creating the node. SupplyNetPy uses a global logger referred to as global_logger , which allows to show or hide all logs by calling scm.global_logger.enable_logging() or scm.global_logger.disable_logging() . Below is an example of a simulation log generated by this program. At the end of the log, supply chain-level performance metrics are calculated and printed. These performance measures are computed for each node in the supply chain and include: Inventory carry cost (holding cost) Inventory spend (replenishment cost) Transportation cost Total cost Revenue Profit INFO D1 - 0.0000:D1: Inventory levels:50, on hand:50 INFO D1 - 0.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 100 units. INFO D1 - 0.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 0.0000:d1:Customer1:Order quantity:10, available. INFO D1 - 0.0000:D1: Inventory levels:40, on hand:140 INFO d1 - 1.0000:d1:Customer2:Order quantity:10, available. INFO D1 - 1.0000:D1: Inventory levels:30, on hand:130 INFO D1 - 2.0000:D1:Inventory replenished. reorder_quantity=100, Inventory levels:130 INFO d1 - 2.0000:d1:Customer3:Order quantity:10, available. INFO D1 - 2.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 3.0000:d1:Customer4:Order quantity:10, available. INFO D1 - 3.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 4.0000:d1:Customer5:Order quantity:10, available. INFO D1 - 4.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 4.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 4.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 5.0000:d1:Customer6:Order quantity:10, available. INFO D1 - 5.0000:D1: Inventory levels:90, on hand:140 INFO D1 - 6.0000:D1:Inventory replenished. reorder_quantity=50, Inventory levels:140 INFO d1 - 6.0000:d1:Customer7:Order quantity:10, available. INFO D1 - 6.0000:D1: Inventory levels:130, on hand:130 INFO d1 - 7.0000:d1:Customer8:Order quantity:10, available. INFO D1 - 7.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 8.0000:d1:Customer9:Order quantity:10, available. INFO D1 - 8.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 9.0000:d1:Customer10:Order quantity:10, available. INFO D1 - 9.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 9.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 9.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 10.0000:d1:Customer11:Order quantity:10, available. INFO D1 - 10.0000:D1: Inventory levels:90, on hand:140 INFO D1 - 11.0000:D1:Inventory replenished. reorder_quantity=50, Inventory levels:140 INFO d1 - 11.0000:d1:Customer12:Order quantity:10, available. INFO D1 - 11.0000:D1: Inventory levels:130, on hand:130 INFO d1 - 12.0000:d1:Customer13:Order quantity:10, available. INFO D1 - 12.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 13.0000:d1:Customer14:Order quantity:10, available. INFO D1 - 13.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 14.0000:d1:Customer15:Order quantity:10, available. INFO D1 - 14.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 14.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 14.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 15.0000:d1:Customer16:Order quantity:10, available. INFO D1 - 15.0000:D1: Inventory levels:90, on hand:140 INFO D1 - 16.0000:D1:Inventory replenished. reorder_quantity=50, Inventory levels:140 INFO d1 - 16.0000:d1:Customer17:Order quantity:10, available. INFO D1 - 16.0000:D1: Inventory levels:130, on hand:130 INFO d1 - 17.0000:d1:Customer18:Order quantity:10, available. INFO D1 - 17.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 18.0000:d1:Customer19:Order quantity:10, available. INFO D1 - 18.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 19.0000:d1:Customer20:Order quantity:10, available. INFO D1 - 19.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 19.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 19.0000:D1:shipment in transit from supplier:Supplier1. INFO sim_trace - Supply chain info: INFO sim_trace - available_inv : 100 INFO sim_trace - avg_available_inv : 112.5 INFO sim_trace - avg_cost_per_item : 50.87 INFO sim_trace - avg_cost_per_order : 1017.4 INFO sim_trace - backorders : [0, 0] INFO sim_trace - demand_by_customers : [20, 200] INFO sim_trace - demand_by_site : [5, 300] INFO sim_trace - demands : {'d1': Demand1} INFO sim_trace - env : <simpy.core.Environment object at 0x0000028D55F67C10> INFO sim_trace - fulfillment_received_by_customers : [20, 200] INFO sim_trace - fulfillment_received_by_site : [4, 250] INFO sim_trace - inventory_carry_cost : 410.0 INFO sim_trace - inventory_spend_cost : 25000 INFO sim_trace - inventory_waste : 0 INFO sim_trace - links : {'L1': S1 to D1} INFO sim_trace - nodes : {'S1': Supplier1, 'D1': Distributor1} INFO sim_trace - num_distributors : 1 INFO sim_trace - num_manufacturers : 0 INFO sim_trace - num_of_links : 1 INFO sim_trace - num_of_nodes : 2 INFO sim_trace - num_retailers : 0 INFO sim_trace - num_suppliers : 1 INFO sim_trace - profit : -4435.0 INFO sim_trace - revenue : 21000 INFO sim_trace - shortage : [0, 0] INFO sim_trace - total_cost : 25435.0 INFO sim_trace - total_demand : [25, 500] INFO sim_trace - total_fulfillment_received : [24, 450] INFO sim_trace - transportation_cost : 25 To access node performance metrics easily, call node.stats.get_statistics() . In this example, the D1 node level statistics can be accessed with the following code: D1_node = supplychainnet[\"nodes\"][\"D1\"] # Get D1 node stats = D1_node.stats.get_statistics() # Get D1_node statistics print(stats) # print Here is the output produced by the code mentioned above. {'demand_placed': [5, 300], 'fulfillment_received': [4, 250], 'demand_received': [20, 200], 'demand_fulfilled': [20, 200], 'orders_shortage': [0, 0], 'backorder': [0, 0], 'inventory_level': 100, 'inventory_waste': 0, 'inventory_carry_cost': 410.0, 'inventory_spend_cost': 25000, 'transportation_cost': 25, 'node_cost': 25435.0, 'revenue': 21000, 'profit': -4435.0} Alternative Approach: Using Object-Oriented API This approach demonstrates how to build and simulate a supply chain using SupplyNetPy's object-oriented API. Instead of passing dictionaries to utility functions, we instantiate supply chain components as Python objects, providing greater flexibility and extensibility. Each node and link is created as an object, and the simulation is managed within a SimPy environment, allowing for more advanced customization and integration with other SimPy-based processes. import simpy # importing simpy to create a simpy environment env = simpy.Environment() # create a simpy environment # create an infinite supplier supplier1 = scm.Supplier(env=env, ID='S1', name='Supplier', node_type=\"infinite_supplier\") # create a distributor node distributor1 = scm.InventoryNode(env=env, ID='D1', name='Distributor1', node_type='distributor', capacity=150, initial_level=50, inventory_holding_cost=0.2, replenishment_policy=scm.SSReplenishment, policy_param={'s':100, 'S':150}, product_buy_price=100, product_sell_price=105) # create a link for distributor link1 = scm.Link(env=env, ID='L1', source=supplier1, sink=distributor1, cost=5, lead_time=lambda: 2) # create demand at distributor1 demand1 = scm.Demand(env=env, ID='d1', name='Demand1', order_arrival_model=lambda: 1, order_quantity_model=lambda:10, demand_node=distributor1) # we can simulate the supply chain env.run(until=20) This script generates an identical simulation log because the network configuration and demand are deterministic. Final statistics will not be included in the log, as overall supply chain statistics are calculated by the function simulate_sc_net . However, node-level statistics will still be available and can be accessed as mentioned earlier. We can proceed to create and simulate the supply chain network using the same functions, create_sc_net and simulate_sc_net , as demonstrated below. # create a supply chain network supplychainnet = scm.create_sc_net(env=env, nodes=[supplier1, distributor1], links=[link1], demands=[demand1]) # simulate supplychainnet = scm.simulate_sc_net(supplychainnet, sim_time=20, logging=True) Note that an additional parameter, env , is passed to the function create_sc_net to create a supply chain network. This is necessary because the SimPy environment ( env ) is now created by us and the same needs to be used for creating the supply chain network and running the simulations.","title":"SupplyNetPy in 10 Minutes"},{"location":"ten_min/#supplynetpy-in-10-minutes","text":"","title":"SupplyNetPy in 10 Minutes"},{"location":"ten_min/#installation","text":"SupplyNetPy can be installed using pip: pip install supplynetpy","title":"Installation"},{"location":"ten_min/#quick-start-building-a-simple-three-node-supply-chain","text":"Follow these steps to create and simulate a basic supply chain with a supplier and a manufacturer:","title":"Quick Start: Building a Simple Three-Node Supply Chain"},{"location":"ten_min/#import-the-library","text":"import SupplyNetPy.Components as scm The Components module in SupplyNetPy offers essential building blocks for constructing supply chain networks. It enables us to define supply chain nodes, products, inventory, demand, and the links that connect them. We can easily assemble and customize supply chain models using these constructs to suit particular requirements.","title":"Import the Library"},{"location":"ten_min/#create-nodes","text":"Let us create a supplier node in the supply chain that has infinite inventory and can supply any required quantity of product units to a consumer node. The supplier node requires several parameters, including ID, name, and node type. To set it as an infinite supplier, we must specify the node type as infinite_supplier . supplier1 = {'ID': 'S1', 'name': 'Supplier1', 'node_type': 'infinite_supplier'} A distributor or warehouse node that purchases products from a supplier is created below by specifying configurable parameters, including ID, name, inventory capacity, replenishment policy, policy parameters, product buy price, and product sell price. distributor1 = {'ID': 'D1', 'name': 'Distributor1', 'node_type': 'distributor', 'capacity': 150, 'initial_level': 50, 'inventory_holding_cost': 0.2, 'replenishment_policy': scm.SSReplenishment, 'policy_param': {'s':100,'S':150}, 'product_buy_price': 100,'product_sell_price': 105} When creating a manufacturer, distributor, wholesaler, or retailer, we must specify the inventory replenishment policy and its parameters. The SupplyNetPy Components module includes an InventoryReplenishment class that can be customized to define specific replenishment policies. Currently, SupplyNetPy supports the following replenishment policies: Reorder-level (s,S) \u2014 continuously monitor inventory and replenish up to S when the level drops below s. Parameters: {s, S} (class SSReplenishment ) Reorder-level (s,S) with Safety Stock \u2014 reorder-level replenishment that factors in a safety stock buffer. Parameters: {s, S, safety_stock} ( SSReplenishment ) Replenish Quantity (RQ) \u2014 reorder a fixed quantity Q when placing an order. Parameters: {R, Q} ( RQReplenishment ) Replenish Quantity (RQ) with safety stock \u2014 reorder a fixed quantity Q when placing an order. Parameters: {R, Q, safety_stock} ( RQReplenishment ) Periodic (T,Q) \u2014 replenish inventory every T days with Q units. Parameters: {T, Q} ( PeriodicReplenishment ) Periodic (T,Q) with safety stock \u2014 replenish inventory every T days with Q units. If safety stock is specified, then when the safety stock level is violated, order Q units in addition to the quantity needed to maintain safety stock levels. Parameters: {T, Q, safety_stock} ( PeriodicReplenishment )","title":"Create Nodes"},{"location":"ten_min/#create-a-link","text":"A link is created as described below. It is configured using parameters such as transportation cost and lead time. The lead time parameter accepts a generative function that produces random lead times based on a specified distribution. Users can create this function according to their needs or define a constant lead time using a Python lambda function. link1 = {'ID': 'L1', 'source': 'S1', 'sink': 'D1', 'cost': 5, 'lead_time': lambda: 2}","title":"Create a Link"},{"location":"ten_min/#specify-demand","text":"A demand is created by specifying an ID, name, demand node, order arrival time, and order quantity. The order arrival parameter accepts a generator function that produces random arrival times, while the order quantity parameter takes a generator function that produces random quantities. Users can define a function that models these arrivals and quantities or use Python's lambda function to create a deterministic demand, as shown below. A demand can be created at either a distributor node or a retailer. In this example, we have created a steady demand for 10 daily units at distributor D1. demand1 = {'ID': 'd1', 'name': 'Demand1', 'order_arrival_model': lambda: 1, 'order_quantity_model': lambda: 10, 'demand_node': 'D1'}","title":"Specify Demand"},{"location":"ten_min/#assemble-and-simulate-the-network","text":"To create and simulate the supply chain, use the create_sc_net function to instantiate the supply chain nodes and assemble them into a network. This function adds metadata to the supply chain, such as the number of nodes, and other relevant information, keeping everything organized. It returns a Python dictionary containing all supply chain components and metadata. The simulate_sc_net function then simulates the supply chain network over a specified period and provides a log of the simulation run. It also calculates performance measures such as net profit, throughput, and more. Let's use these functions to build and simulate our supply chain. # create a supply chain network supplychainnet = scm.create_sc_net(nodes=[supplier1, distributor1], links=[link1], demands=[demand1]) # simulate for 20 days supplychainnet = scm.simulate_sc_net(supplychainnet, sim_time=20, logging=True)","title":"Assemble and Simulate the Network"},{"location":"ten_min/#review-results","text":"After the simulation, inspect supplychainnet to view performance metrics for the supply chain nodes. By default, the simulation log is displayed in the console and saved to a local file named simulation_trace.log , which is located in the same directory as the Python script. Each node in the simulation has its own logger, and logging can be enabled or disabled by providing an additional parameter: logging=True or logging=False while creating the node. SupplyNetPy uses a global logger referred to as global_logger , which allows to show or hide all logs by calling scm.global_logger.enable_logging() or scm.global_logger.disable_logging() . Below is an example of a simulation log generated by this program. At the end of the log, supply chain-level performance metrics are calculated and printed. These performance measures are computed for each node in the supply chain and include: Inventory carry cost (holding cost) Inventory spend (replenishment cost) Transportation cost Total cost Revenue Profit INFO D1 - 0.0000:D1: Inventory levels:50, on hand:50 INFO D1 - 0.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 100 units. INFO D1 - 0.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 0.0000:d1:Customer1:Order quantity:10, available. INFO D1 - 0.0000:D1: Inventory levels:40, on hand:140 INFO d1 - 1.0000:d1:Customer2:Order quantity:10, available. INFO D1 - 1.0000:D1: Inventory levels:30, on hand:130 INFO D1 - 2.0000:D1:Inventory replenished. reorder_quantity=100, Inventory levels:130 INFO d1 - 2.0000:d1:Customer3:Order quantity:10, available. INFO D1 - 2.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 3.0000:d1:Customer4:Order quantity:10, available. INFO D1 - 3.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 4.0000:d1:Customer5:Order quantity:10, available. INFO D1 - 4.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 4.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 4.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 5.0000:d1:Customer6:Order quantity:10, available. INFO D1 - 5.0000:D1: Inventory levels:90, on hand:140 INFO D1 - 6.0000:D1:Inventory replenished. reorder_quantity=50, Inventory levels:140 INFO d1 - 6.0000:d1:Customer7:Order quantity:10, available. INFO D1 - 6.0000:D1: Inventory levels:130, on hand:130 INFO d1 - 7.0000:d1:Customer8:Order quantity:10, available. INFO D1 - 7.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 8.0000:d1:Customer9:Order quantity:10, available. INFO D1 - 8.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 9.0000:d1:Customer10:Order quantity:10, available. INFO D1 - 9.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 9.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 9.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 10.0000:d1:Customer11:Order quantity:10, available. INFO D1 - 10.0000:D1: Inventory levels:90, on hand:140 INFO D1 - 11.0000:D1:Inventory replenished. reorder_quantity=50, Inventory levels:140 INFO d1 - 11.0000:d1:Customer12:Order quantity:10, available. INFO D1 - 11.0000:D1: Inventory levels:130, on hand:130 INFO d1 - 12.0000:d1:Customer13:Order quantity:10, available. INFO D1 - 12.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 13.0000:d1:Customer14:Order quantity:10, available. INFO D1 - 13.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 14.0000:d1:Customer15:Order quantity:10, available. INFO D1 - 14.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 14.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 14.0000:D1:shipment in transit from supplier:Supplier1. INFO d1 - 15.0000:d1:Customer16:Order quantity:10, available. INFO D1 - 15.0000:D1: Inventory levels:90, on hand:140 INFO D1 - 16.0000:D1:Inventory replenished. reorder_quantity=50, Inventory levels:140 INFO d1 - 16.0000:d1:Customer17:Order quantity:10, available. INFO D1 - 16.0000:D1: Inventory levels:130, on hand:130 INFO d1 - 17.0000:d1:Customer18:Order quantity:10, available. INFO D1 - 17.0000:D1: Inventory levels:120, on hand:120 INFO d1 - 18.0000:d1:Customer19:Order quantity:10, available. INFO D1 - 18.0000:D1: Inventory levels:110, on hand:110 INFO d1 - 19.0000:d1:Customer20:Order quantity:10, available. INFO D1 - 19.0000:D1: Inventory levels:100, on hand:100 INFO D1 - 19.0000:D1:Replenishing inventory from supplier:Supplier1, order placed for 50 units. INFO D1 - 19.0000:D1:shipment in transit from supplier:Supplier1. INFO sim_trace - Supply chain info: INFO sim_trace - available_inv : 100 INFO sim_trace - avg_available_inv : 112.5 INFO sim_trace - avg_cost_per_item : 50.87 INFO sim_trace - avg_cost_per_order : 1017.4 INFO sim_trace - backorders : [0, 0] INFO sim_trace - demand_by_customers : [20, 200] INFO sim_trace - demand_by_site : [5, 300] INFO sim_trace - demands : {'d1': Demand1} INFO sim_trace - env : <simpy.core.Environment object at 0x0000028D55F67C10> INFO sim_trace - fulfillment_received_by_customers : [20, 200] INFO sim_trace - fulfillment_received_by_site : [4, 250] INFO sim_trace - inventory_carry_cost : 410.0 INFO sim_trace - inventory_spend_cost : 25000 INFO sim_trace - inventory_waste : 0 INFO sim_trace - links : {'L1': S1 to D1} INFO sim_trace - nodes : {'S1': Supplier1, 'D1': Distributor1} INFO sim_trace - num_distributors : 1 INFO sim_trace - num_manufacturers : 0 INFO sim_trace - num_of_links : 1 INFO sim_trace - num_of_nodes : 2 INFO sim_trace - num_retailers : 0 INFO sim_trace - num_suppliers : 1 INFO sim_trace - profit : -4435.0 INFO sim_trace - revenue : 21000 INFO sim_trace - shortage : [0, 0] INFO sim_trace - total_cost : 25435.0 INFO sim_trace - total_demand : [25, 500] INFO sim_trace - total_fulfillment_received : [24, 450] INFO sim_trace - transportation_cost : 25 To access node performance metrics easily, call node.stats.get_statistics() . In this example, the D1 node level statistics can be accessed with the following code: D1_node = supplychainnet[\"nodes\"][\"D1\"] # Get D1 node stats = D1_node.stats.get_statistics() # Get D1_node statistics print(stats) # print Here is the output produced by the code mentioned above. {'demand_placed': [5, 300], 'fulfillment_received': [4, 250], 'demand_received': [20, 200], 'demand_fulfilled': [20, 200], 'orders_shortage': [0, 0], 'backorder': [0, 0], 'inventory_level': 100, 'inventory_waste': 0, 'inventory_carry_cost': 410.0, 'inventory_spend_cost': 25000, 'transportation_cost': 25, 'node_cost': 25435.0, 'revenue': 21000, 'profit': -4435.0}","title":"Review Results"},{"location":"ten_min/#alternative-approach-using-object-oriented-api","text":"This approach demonstrates how to build and simulate a supply chain using SupplyNetPy's object-oriented API. Instead of passing dictionaries to utility functions, we instantiate supply chain components as Python objects, providing greater flexibility and extensibility. Each node and link is created as an object, and the simulation is managed within a SimPy environment, allowing for more advanced customization and integration with other SimPy-based processes. import simpy # importing simpy to create a simpy environment env = simpy.Environment() # create a simpy environment # create an infinite supplier supplier1 = scm.Supplier(env=env, ID='S1', name='Supplier', node_type=\"infinite_supplier\") # create a distributor node distributor1 = scm.InventoryNode(env=env, ID='D1', name='Distributor1', node_type='distributor', capacity=150, initial_level=50, inventory_holding_cost=0.2, replenishment_policy=scm.SSReplenishment, policy_param={'s':100, 'S':150}, product_buy_price=100, product_sell_price=105) # create a link for distributor link1 = scm.Link(env=env, ID='L1', source=supplier1, sink=distributor1, cost=5, lead_time=lambda: 2) # create demand at distributor1 demand1 = scm.Demand(env=env, ID='d1', name='Demand1', order_arrival_model=lambda: 1, order_quantity_model=lambda:10, demand_node=distributor1) # we can simulate the supply chain env.run(until=20) This script generates an identical simulation log because the network configuration and demand are deterministic. Final statistics will not be included in the log, as overall supply chain statistics are calculated by the function simulate_sc_net . However, node-level statistics will still be available and can be accessed as mentioned earlier. We can proceed to create and simulate the supply chain network using the same functions, create_sc_net and simulate_sc_net , as demonstrated below. # create a supply chain network supplychainnet = scm.create_sc_net(env=env, nodes=[supplier1, distributor1], links=[link1], demands=[demand1]) # simulate supplychainnet = scm.simulate_sc_net(supplychainnet, sim_time=20, logging=True) Note that an additional parameter, env , is passed to the function create_sc_net to create a supply chain network. This is necessary because the SimPy environment ( env ) is now created by us and the same needs to be used for creating the supply chain network and running the simulations.","title":"Alternative Approach: Using Object-Oriented API"},{"location":"api-reference/api-intro/","text":"SupplyNetPy API Reference SupplyNetPy includes a sub-module called Components , which facilitates the creation of supply chain networks by providing essential components such as nodes, links, and demand, and assembling them into a network. The Components module contains four sub-modules: core, inventory, logger, and utilities. The core module is responsible for creating supply chain components. It includes classes such as RawMaterial , Product , Inventory , Node , Link , Supplier , Manufacturer , InventoryNode , and Demand . Any new node created using these classes will be instantiated within a SimPy environment. The Inventory class is responsible for monitoring inventories. By default, the classes in the core module support single-product inventories. The Inventory class extends the SimPy Container class to implement the basic behavior of an inventory, including routines to record inventory level changes. If users wish to create a different inventory type with custom behavior, they can do so by extending either Inventory or SimPy Container . The logger module is designed to maintain simulation logs. It includes the GlobalLogger class, which serves as a common logger for all components within the environment. Users can configure this logger to save logs to a specific file or print them to the console. The utilities module provides useful Python routines to reduce manual work. It contains functions for creating random supply chains, generating multiple nodes or links, and more. Additionally, it offers routines for supply chain network visualization. SupplyNetPy Library Hierarchy SupplyNetPy \u251c\u2500\u2500 Components \u2502 \u251c\u2500\u2500 core.py \u2502 \u251c\u2500\u2500 logger.py \u2502 \u251c\u2500\u2500 utilities.py","title":"Introduction"},{"location":"api-reference/api-intro/#supplynetpy-api-reference","text":"SupplyNetPy includes a sub-module called Components , which facilitates the creation of supply chain networks by providing essential components such as nodes, links, and demand, and assembling them into a network. The Components module contains four sub-modules: core, inventory, logger, and utilities. The core module is responsible for creating supply chain components. It includes classes such as RawMaterial , Product , Inventory , Node , Link , Supplier , Manufacturer , InventoryNode , and Demand . Any new node created using these classes will be instantiated within a SimPy environment. The Inventory class is responsible for monitoring inventories. By default, the classes in the core module support single-product inventories. The Inventory class extends the SimPy Container class to implement the basic behavior of an inventory, including routines to record inventory level changes. If users wish to create a different inventory type with custom behavior, they can do so by extending either Inventory or SimPy Container . The logger module is designed to maintain simulation logs. It includes the GlobalLogger class, which serves as a common logger for all components within the environment. Users can configure this logger to save logs to a specific file or print them to the console. The utilities module provides useful Python routines to reduce manual work. It contains functions for creating random supply chains, generating multiple nodes or links, and more. Additionally, it offers routines for supply chain network visualization.","title":"SupplyNetPy API Reference"},{"location":"api-reference/api-intro/#supplynetpy-library-hierarchy","text":"SupplyNetPy \u251c\u2500\u2500 Components \u2502 \u251c\u2500\u2500 core.py \u2502 \u251c\u2500\u2500 logger.py \u2502 \u251c\u2500\u2500 utilities.py","title":"SupplyNetPy Library Hierarchy"},{"location":"api-reference/api-ref-core/","text":"SupplyNetPy Components.core Module The Components.core module provides the foundational building blocks for modeling and simulating supply chain networks in SupplyNetPy. It defines key classes representing entities and their interactions within a supply chain. SupplyNetPy.Components.core NamedEntity The NamedEntity class provides a standardized way to display names of the objects in the supply chain model. When printed or displayed, the object will show its name (if defined), otherwise its ID , or the class name as a fallback. This improves the readability and interpretability of simulation outputs by ensuring objects are easily identifiable. Methods: Name Description __str__ returns the name of the object if available, otherwise returns the class name __repr__ returns the name of the object if available, otherwise returns the class name __str__ __str__() -> str Returns the name of the object if available, otherwise returns the class name. Source code in src/SupplyNetPy/Components/core.py def __str__(self) -> str: \"\"\"Returns the name of the object if available, otherwise returns the class name.\"\"\" return getattr(self, 'name', getattr(self, 'ID', self.__class__.__name__)) __repr__ __repr__() -> str Returns the name of the object if available, otherwise returns the class name. Source code in src/SupplyNetPy/Components/core.py def __repr__(self) -> str: \"\"\"Returns the name of the object if available, otherwise returns the class name.\"\"\" return getattr(self, 'name', getattr(self, 'ID', self.__class__.__name__)) InfoMixin The InfoMixin class allows objects to easily provide their key details and statistics as dictionaries. This helps in quickly summarizing, logging, or analyzing object data in a structured and consistent way across the simulation. Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary _stats_keys ( list ) \u2013 list of keys to include in the statistics dictionary Methods: Name Description get_info returns a dictionary containing details of the object get_statistics returns a dictionary containing statistics of the object get_info get_info() -> dict Returns a dictionary containing details of the object. Returns: dict ( dict ) \u2013 dictionary containing details of the object Source code in src/SupplyNetPy/Components/core.py def get_info(self) -> dict: \"\"\" Returns a dictionary containing details of the object. Parameters: None Attributes: None Returns: dict: dictionary containing details of the object \"\"\" if self._info_keys: return {key: getattr(self, key, None) for key in self._info_keys} return self.__dict__ get_statistics get_statistics() -> dict Returns a dictionary containing statistics of the object. Returns: dict ( dict ) \u2013 dictionary containing statistics of the object Source code in src/SupplyNetPy/Components/core.py def get_statistics(self) -> dict: \"\"\" Returns a dictionary containing statistics of the object. Parameters: None Attributes: None Returns: dict: dictionary containing statistics of the object \"\"\" if self._stats_keys: return {key: getattr(self, key, None) for key in self._stats_keys} return self.__dict__ Statistics Statistics(node: object, periodic_update: bool = False, period: float = 1) Bases: InfoMixin The Statistics class tracks and summarizes key performance indicators for each node in the supply chain. It monitors essential metrics such as demand, inventory levels, shortages, backorders, costs, revenue, and profit. The class supports both automatic periodic updates and manual updates through the update_stats method, which can be called at any point in the simulation to immediately record changes. Parameters: node ( object ) \u2013 The node for which statistics are tracked. periodic_update ( bool , default: False ) \u2013 Whether to update statistics periodically. Default is False. period ( float , default: 1 ) \u2013 Time interval for periodic updates. Default is 1. Attributes: node ( object ) \u2013 The node to which this statistics object belongs. name ( str ) \u2013 Name of the statistics object. By default, it is the node's name post-fix \" statistics\". demand_placed ( list ) \u2013 Orders and quantities placed by this node. fulfillment_received ( list ) \u2013 Orders and quantities received by this node. demand_received ( list ) \u2013 Orders and quantities demanded at this node. demand_fulfilled ( list ) \u2013 Orders and quantities fulfilled by this node. orders_shortage ( list ) \u2013 Orders and quantities that faced shortage. backorder ( list ) \u2013 Backorders at this node. inventory_level ( float ) \u2013 Current inventory level. inventory_waste ( float ) \u2013 Inventory waste. inventory_carry_cost ( float ) \u2013 Inventory carrying cost. inventory_spend_cost ( float ) \u2013 Inventory replenishment cost. transportation_cost ( float ) \u2013 Transportation cost. node_cost ( float ) \u2013 Total cost at this node. revenue ( float ) \u2013 Revenue generated by this node. profit ( float ) \u2013 Profit generated by this node. _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. Methods: Name Description reset Resets all statistics to initial values. update_stats Updates statistics based on provided values. update_stats_periodically Periodically updates statistics during simulation. Initialize the statistics object. Parameters: node ( object ) \u2013 The node for which statistics are tracked. periodic_update ( bool , default: False ) \u2013 Whether to update statistics periodically. Default is False. period ( float , default: 1 ) \u2013 Time interval for periodic updates. Default is 1. Attributes: node ( object ) \u2013 The node to which this statistics object belongs. name ( str ) \u2013 Name of the statistics object. demand_placed ( list ) \u2013 Orders and quantities placed by this node. fulfillment_received ( list ) \u2013 Orders and quantities received by this node. demand_received ( list ) \u2013 Orders and quantities demanded at this node. demand_fulfilled ( list ) \u2013 Orders and quantities fulfilled by this node. orders_shortage ( list ) \u2013 Orders and quantities that faced shortage. backorder ( list ) \u2013 Backorders at this node. inventory_level ( float ) \u2013 Current inventory level. inventory_waste ( float ) \u2013 Inventory waste. inventory_carry_cost ( float ) \u2013 Inventory carrying cost. inventory_spend_cost ( float ) \u2013 Inventory replenishment cost. transportation_cost ( float ) \u2013 Transportation cost. node_cost ( float ) \u2013 Total cost at this node. revenue ( float ) \u2013 Revenue generated by this node. profit ( float ) \u2013 Profit generated by this node. _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node:object, periodic_update:bool=False, period:float=1): \"\"\" Initialize the statistics object. Parameters: node (object): The node for which statistics are tracked. periodic_update (bool, optional): Whether to update statistics periodically. Default is False. period (float, optional): Time interval for periodic updates. Default is 1. Attributes: node (object): The node to which this statistics object belongs. name (str): Name of the statistics object. demand_placed (list): Orders and quantities placed by this node. fulfillment_received (list): Orders and quantities received by this node. demand_received (list): Orders and quantities demanded at this node. demand_fulfilled (list): Orders and quantities fulfilled by this node. orders_shortage (list): Orders and quantities that faced shortage. backorder (list): Backorders at this node. inventory_level (float): Current inventory level. inventory_waste (float): Inventory waste. inventory_carry_cost (float): Inventory carrying cost. inventory_spend_cost (float): Inventory replenishment cost. transportation_cost (float): Transportation cost. node_cost (float): Total cost at this node. revenue (float): Revenue generated by this node. profit (float): Profit generated by this node. _info_keys (list): Keys to include in the info dictionary. _stats_keys (list): Keys to include in the statistics dictionary. Returns: None \"\"\" self._info_keys = [\"name\"] self._stats_keys = [\"demand_placed\", \"fulfillment_received\", \"demand_received\", \"demand_fulfilled\", \"orders_shortage\", \"backorder\", \"inventory_level\", \"inventory_waste\", \"inventory_carry_cost\", \"inventory_spend_cost\", \"transportation_cost\", \"node_cost\", \"revenue\", \"profit\"] self.node = node # the node to which this statistics object belongs self.name = f\"{self.node.ID} statistics\" self.demand_placed = [0,0] # demand placed by this node [total orders placed, total quantity] self.fulfillment_received = [0,0] # fulfillment received by this node self.demand_received = [0,0] # demand received by this node (demand at this node) self.demand_fulfilled = [0,0] # demand fulfilled by this node (demand that was served by this node) self.orders_shortage = [0,0] # shortage of products at this node self.backorder = [0,0] # any backorders at this node self.inventory_level = 0 # current inventory level at this node self.inventory_waste = 0 # inventory waste at this node self.inventory_carry_cost = 0 # inventory carrying cost at this node self.inventory_spend_cost = 0 # inventory replenishment cost at this node self.transportation_cost = 0 # transportation cost at this node self.node_cost = 0 # total cost at this node self.revenue = 0 # revenue generated by this node self.profit = 0 # profit generated by this node (revenue - total cost) if(periodic_update): self.node.env.process(self.update_stats_periodically(period=period)) reset reset() Reset the statistics to their initial values. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def reset(self): \"\"\" Reset the statistics to their initial values. Parameters: None Attributes: None Returns: None \"\"\" for key, value in vars(self).items(): if isinstance(value, list): if \"_keys\" in key: continue setattr(self, key, [0,0]) elif isinstance(value, (int, float)): setattr(self, key, 0) if hasattr(self.node, 'inventory'): self.node.inventory.carry_cost = 0 self.node.inventory.waste = 0 update_stats update_stats(**kwargs) Update the statistics with the given keyword arguments. Parameters: **kwargs \u2013 keyword arguments containing the statistics to update Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def update_stats(self,**kwargs): \"\"\" Update the statistics with the given keyword arguments. Parameters: **kwargs: keyword arguments containing the statistics to update Attributes: None Returns: None \"\"\" for key, value in kwargs.items(): if hasattr(self, key): attr = getattr(self, key) if isinstance(attr, list): # value = [v1,v2] attr[0] += value[0] attr[1] += value[1] setattr(self, key, attr) # update the attribute with the new value else: attr += value setattr(self, key, attr) # update the attribute with the new value else: global_logger.logger.warning(f\"{self.node.ID}: (Updaing stats) Attribute {key} not found in Statistics class.\") if hasattr(self.node, 'inventory'): if self.node.inventory.level != float('inf'): self.inventory_level = self.node.inventory.inventory.level if hasattr(self.node, 'inventory') else 0 self.node.inventory.update_carry_cost() self.inventory_carry_cost = self.node.inventory.carry_cost self.inventory_waste = self.node.inventory.waste if hasattr(self.node.inventory, 'waste') else 0 total_cost = 0 for key,value in vars(self).items(): if key == \"node_cost\": # exclude node_cost from the total cost calculation continue if \"cost\" in key: # consider all cost attributes total_cost += value self.node_cost = total_cost self.revenue = self.demand_fulfilled[1] * self.node.sell_price if hasattr(self.node, 'sell_price') else 0 self.profit = self.revenue - self.node_cost update_stats_periodically update_stats_periodically(period) Update the statistics periodically. Parameters: period ( float ) \u2013 period for periodic update of statistics Returns: generator \u2013 a generator that yields after the specified period Source code in src/SupplyNetPy/Components/core.py def update_stats_periodically(self, period): \"\"\" Update the statistics periodically. Parameters: period (float): period for periodic update of statistics Attributes: None Returns: generator: a generator that yields after the specified period \"\"\" while True: yield self.node.env.timeout(period) self.update_stats() RawMaterial RawMaterial(ID: str, name: str, extraction_quantity: float, extraction_time: float, mining_cost: float, cost: float) Bases: NamedEntity , InfoMixin The RawMaterial class represents a raw material in a supply chain. It defines key properties of a raw material, including extraction rate, extraction time, mining cost, and selling price. This class helps model the extraction processes at a raw material supplier node in the network. Parameters: ID ( str ) \u2013 ID of the raw material. name ( str ) \u2013 Name of the raw material. extraction_quantity ( float ) \u2013 Quantity extracted per extraction cycle. extraction_time ( float ) \u2013 Time required to extract the specified quantity. mining_cost ( float ) \u2013 Mining cost per item. cost ( float ) \u2013 Selling price per item. Attributes: _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. ID ( str ) \u2013 ID of the raw material. name ( str ) \u2013 Name of the raw material. extraction_quantity ( float ) \u2013 Quantity extracted per extraction cycle. extraction_time ( float ) \u2013 Time required for extraction. mining_cost ( float ) \u2013 Mining cost per item. cost ( float ) \u2013 Selling price per item. Methods: Name Description Initialize the raw material object. Parameters: ID ( str ) \u2013 ID of the raw material (alphanumeric) name ( str ) \u2013 name of the raw material extraction_quantity ( float ) \u2013 quantity of the raw material that is extracted in extraction_time extraction_time ( float ) \u2013 time to extract 'extraction_quantity' units of raw material mining_cost ( float ) \u2013 mining cost of the raw material (per item) cost ( float ) \u2013 selling cost of the raw material (per item) Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary _stats_keys ( list ) \u2013 list of keys to include in the statistics dictionary ID ( str ) \u2013 ID of the raw material (alphanumeric) name ( str ) \u2013 name of the raw material extraction_quantity ( float ) \u2013 quantity of the raw material that is extracted in extraction_time extraction_time ( float ) \u2013 time to extract 'extraction_quantity' units of raw material mining_cost ( float ) \u2013 mining cost of the raw material (per item) cost ( float ) \u2013 selling cost of the raw material (per item) Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, ID: str, name: str, extraction_quantity: float, extraction_time: float, mining_cost: float, cost: float) -> None: \"\"\" Initialize the raw material object. Parameters: ID (str): ID of the raw material (alphanumeric) name (str): name of the raw material extraction_quantity (float): quantity of the raw material that is extracted in extraction_time extraction_time (float): time to extract 'extraction_quantity' units of raw material mining_cost (float): mining cost of the raw material (per item) cost (float): selling cost of the raw material (per item) Attributes: _info_keys (list): list of keys to include in the info dictionary _stats_keys (list): list of keys to include in the statistics dictionary ID (str): ID of the raw material (alphanumeric) name (str): name of the raw material extraction_quantity (float): quantity of the raw material that is extracted in extraction_time extraction_time (float): time to extract 'extraction_quantity' units of raw material mining_cost (float): mining cost of the raw material (per item) cost (float): selling cost of the raw material (per item) Returns: None \"\"\" validate_positive(\"Extraction quantity\", extraction_quantity) validate_non_negative(\"Extraction time\", extraction_time) validate_non_negative(\"Mining Cost\", mining_cost) validate_positive(\"Cost\", cost) self._info_keys = [\"ID\", \"name\", \"extraction_quantity\", \"extraction_time\", \"mining_cost\", \"cost\"] self._stats_keys = [] self.ID = ID # ID of the raw material (alphanumeric) self.name = name # name of the raw material self.extraction_quantity = extraction_quantity # quantity of the raw material that is extracted in extraction_time self.extraction_time = extraction_time # time to extract 'extraction_quantity' units of raw material self.mining_cost = mining_cost # mining cost of the raw material (per item) self.cost = cost # selling cost of the raw material (per item) Product Product(ID: str, name: str, manufacturing_cost: float, manufacturing_time: float, sell_price: float, raw_materials: list, batch_size: int, buy_price: float = 0) Bases: NamedEntity , InfoMixin The Product class models a finished good in the supply chain. It defines essential properties such as manufacturing cost, manufacturing time, selling price, and the raw materials required to produce it. The class supports both buying and manufacturing workflows, allowing nodes to either purchase the product directly or produce it using defined raw material combinations. Products are typically manufactured in batches, with each batch size and cycle time configurable, making it easy to model real-world production processes. Parameters: ID ( str ) \u2013 ID of the product. name ( str ) \u2013 Name of the product. manufacturing_cost ( float ) \u2013 Manufacturing cost per unit. manufacturing_time ( float ) \u2013 Time to manufacture one batch. sell_price ( float ) \u2013 Selling price per unit. raw_materials ( list ) \u2013 List of (raw material object, quantity) tuples required to produce one unit. batch_size ( int ) \u2013 Number of units manufactured per cycle. buy_price ( float , default: 0 ) \u2013 Buying price per unit (default is 0). Attributes: _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. ID ( str ) \u2013 ID of the product. name ( str ) \u2013 Name of the product. manufacturing_cost ( float ) \u2013 Manufacturing cost per unit. manufacturing_time ( float ) \u2013 Manufacturing time for one batch. sell_price ( float ) \u2013 Selling price per unit. buy_price ( float ) \u2013 Buying price per unit. raw_materials ( list ) \u2013 List of (raw material, quantity) tuples required to produce one unit. batch_size ( int ) \u2013 Units manufactured per cycle. Methods: Name Description Initialize the product object. Performs input validation for positive and non-negative values, and ensures raw materials are provided. Parameters: ID ( str ) \u2013 ID of the product (alphanumeric) name ( str ) \u2013 Name of the product manufacturing_cost ( float ) \u2013 Manufacturing cost of the product per unit manufacturing_time ( float ) \u2013 Time to manufacture one batch of products sell_price ( float ) \u2013 Price at which the product is sold buy_price ( float , default: 0 ) \u2013 Price at which the product is bought (default is 0) raw_materials ( list ) \u2013 List of tuples containing (raw material object, quantity required) to manufacture one unit of the product batch_size ( int ) \u2013 Number of units manufactured per manufacturing cycle Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary _stats_keys ( list ) \u2013 List of keys to include in the statistics dictionary ID ( str ) \u2013 ID of the product name ( str ) \u2013 Name of the product manufacturing_cost ( float ) \u2013 Manufacturing cost per unit manufacturing_time ( float ) \u2013 Time to manufacture one batch sell_price ( float ) \u2013 Selling price of the product buy_price ( float ) \u2013 Buying price of the product (default is 0) raw_materials ( list ) \u2013 List of (raw material, quantity) required for one unit batch_size ( int ) \u2013 Number of units produced per manufacturing cycle Returns: None \u2013 None Raises: ValueError \u2013 If validations fail for positive values, non-negative values, or empty raw materials list. Source code in src/SupplyNetPy/Components/core.py def __init__(self, ID: str, name: str, manufacturing_cost: float, manufacturing_time: float, sell_price: float, raw_materials: list, batch_size: int, buy_price: float = 0) -> None: \"\"\" Initialize the product object. Performs input validation for positive and non-negative values, and ensures raw materials are provided. Parameters: ID (str): ID of the product (alphanumeric) name (str): Name of the product manufacturing_cost (float): Manufacturing cost of the product per unit manufacturing_time (float): Time to manufacture one batch of products sell_price (float): Price at which the product is sold buy_price (float, optional): Price at which the product is bought (default is 0) raw_materials (list): List of tuples containing (raw material object, quantity required) to manufacture one unit of the product batch_size (int): Number of units manufactured per manufacturing cycle Attributes: _info_keys (list): List of keys to include in the info dictionary _stats_keys (list): List of keys to include in the statistics dictionary ID (str): ID of the product name (str): Name of the product manufacturing_cost (float): Manufacturing cost per unit manufacturing_time (float): Time to manufacture one batch sell_price (float): Selling price of the product buy_price (float): Buying price of the product (default is 0) raw_materials (list): List of (raw material, quantity) required for one unit batch_size (int): Number of units produced per manufacturing cycle Returns: None Raises: ValueError: If validations fail for positive values, non-negative values, or empty raw materials list. \"\"\" validate_positive(\"Manufacturing cost\", manufacturing_cost) validate_non_negative(\"Manufacturing time\", manufacturing_time) validate_positive(\"Sell price\", sell_price) validate_non_negative(\"Buy price\", buy_price) validate_positive(\"Units per cycle\", batch_size) if raw_materials is None or len(raw_materials) == 0: global_logger.logger.error(\"Raw materials cannot be empty.\") raise ValueError(\"Raw materials cannot be empty.\") for raw_mat in raw_materials: if not isinstance(raw_mat[0], RawMaterial): raise ValueError(\"Invalid raw material.\") if raw_mat[1] <= 0: raise ValueError(\"Invalid quantity for raw material.\") self._info_keys = [\"ID\", \"name\", \"manufacturing_cost\", \"manufacturing_time\", \"sell_price\", \"buy_price\", \"raw_materials\", \"batch_size\"] self._stats_keys = [] self.ID = ID # ID of the product (alphanumeric) self.name = name # name of the product self.manufacturing_cost = manufacturing_cost # manufacturing cost of the product (per unit) self.manufacturing_time = manufacturing_time # time (days) to manufacture 'batch_size' units of product self.sell_price = sell_price # price at which the product is sold self.buy_price = buy_price # price at which the product is bought, (default: 0). It is used by InventoryNode buy the product at some price and sell it at a higher price. self.raw_materials = raw_materials # list of raw materials and quantity required to manufacture a single product unit self.batch_size = batch_size # number of units manufactured per cycle InventoryReplenishment InventoryReplenishment(env: Environment, node: object, params: dict) Bases: InfoMixin , NamedEntity The InventoryReplenishment class defines the abstract structure for inventory replenishment policies within SupplyNetPy. It provides a common interface for managing how nodes place replenishment orders during the simulation. This class is not intended for direct use. It must be subclassed to implement specific replenishment strategies, such as min-max (s, S), reorder point, quantity (RQ), or periodic review (TQ) policies. The run method should be overridden to define the replenishment logic for the policy. The class integrates with the SimPy environment to support time-driven inventory management. The inventory_drop event is used to signal stock depletion, enabling the replenishment process to respond to changes in inventory levels in real time. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy. Methods: Name Description run Placeholder method to be overridden by subclasses. Initialize the replenishment policy object. Parameters: env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, node: object, params: dict) -> None: \"\"\" Initialize the replenishment policy object. Parameters: env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy Attributes: _info_keys (list): list of keys to include in the info dictionary env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy Returns: None \"\"\" if not isinstance(env, simpy.Environment): raise ValueError(\"Invalid environment. Provide a valid SimPy environment.\") self._info_keys = [\"node\", \"params\"] self.env = env # simulation environment self.node = node # node to which this policy applies self.params = params # parameters for the replenishment policy run run() This method should be overridden by subclasses to implement the specific replenishment policy logic. Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" This method should be overridden by subclasses to implement the specific replenishment policy logic. \"\"\" pass SSReplenishment SSReplenishment(env, node, params) Bases: InventoryReplenishment Implements the (s, S) or min-max inventory replenishment policy with optional safety stock support. When the inventory level falls to or below the reorder point (s), an order is placed to replenish stock up to the order-up-to level (S). If safety stock is provided, both the reorder point and the order-up-to level are adjusted accordingly. The policy supports both event-driven and periodic inventory checks, with an optional initial review delay. Supplier selection is automatically managed using the node\u2019s supplier selection policy. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters (s, S) and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters. name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check begins. period ( float ) \u2013 Time interval for periodic inventory checks. Methods: Name Description run Monitors inventory and places orders based on the (s, S) policy. Initialize the replenishment policy object. Parameters: env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (s, S) Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (s, S) name ( str ) \u2013 replenishment policy name first_review_delay ( float ) \u2013 delay before the first inventory check is performed period ( float ) \u2013 period for periodic inventory check Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env, node, params): \"\"\" Initialize the replenishment policy object. Parameters: env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (s, S) Attributes: _info_keys (list): list of keys to include in the info dictionary env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (s, S) name (str): replenishment policy name first_review_delay (float): delay before the first inventory check is performed period (float): period for periodic inventory check Returns: None \"\"\" validate_non_negative(\"Reorder point (s)\", params['s']) # this assertion ensures that the reorder point is positive validate_positive(\"Order-up-to level (S)\", params['S']) # this assertion ensures that the order-up-to level is non-negative if 's' not in params or 'S' not in params: raise ValueError(\"Parameters 's' and 'S' must be provided for the (s, S) replenishment policy.\") if params['s'] > params['S']: raise ValueError(\"Reorder point (s) must be less than or equal to order-up-to level (S).\") super().__init__(env, node, params) self._info_keys.extend([\"name\",\"first_review_delay\",\"period\"]) self.name = \"min-max replenishment (s, S)\" self.first_review_delay = params.get('first_review_delay', 0) self.period = params.get('period',0) run run() Replenishes the inventory based on the sS policy. Attributes: s ( float ) \u2013 reorder point S ( float ) \u2013 order-up-to level Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" Replenishes the inventory based on the sS policy. Parameters: None Attributes: s (float): reorder point S (float): order-up-to level Returns: None \"\"\" s, S = self.params['s'], self.params['S'] # get the reorder point and order-up-to level if s > S: self.node.logger.logger.error(\"Reorder point (s) must be less than or equal to order-up-to level (S).\") raise ValueError(\"Reorder point (s) must be less than or equal to order-up-to level (S).\") if 'safety_stock' in self.params: # check if safety_stock is specified validate_positive(\"Safety stock\", self.params['safety_stock']) self.name = \"min-max with safety replenishment (s, S, safety_stock)\" s += self.params['safety_stock'] S += self.params['safety_stock'] if self.first_review_delay > 0: # if first review delay is specified, wait for the specified time before starting the replenishment process yield self.env.timeout(self.first_review_delay) while True: # run the replenishment process indefinitely self.node.logger.logger.info(f\"{self.env.now:.4f}:{self.node.ID}: Inventory levels:{self.node.inventory.inventory.level}, on hand:{self.node.inventory.on_hand}\") if (self.node.inventory.on_hand - self.node.stats.backorder[1] <= s): order_quantity = S - (self.node.inventory.on_hand - self.node.stats.backorder[1]) # calculate the order quantity supplier = self.node.selection_policy.select(order_quantity) # select a supplier based on the supplier selection policy self.node.ongoing_order = True self.env.process(self.node.process_order(supplier, order_quantity)) if self.period==0: # if periodic check is OFF yield self.node.inventory_drop # wait for the inventory to be dropped self.node.inventory_drop = self.env.event() # reset the event for the next iteration elif(self.period): # if periodic check is ON yield self.env.timeout(self.period) RQReplenishment RQReplenishment(env, node, params) Bases: InventoryReplenishment Implements a Reorder Quantity (RQ) Inventory Replenishment Policy with optional safety stock support. This policy continuously monitors inventory levels and places a replenishment order when the inventory falls to or below the reorder point (R). The replenishment quantity is fixed at Q units per order. The inventory can be checked continuously (event-based) if 'period' is set to 0 (default) and periodically if a positive 'period' is provided. An optional first review delay can be configured to introduce a delay before the first inventory check begins. Supplier selection is managed automatically using the node's supplier selection policy. If the selected supplier does not have sufficient inventory, the shortage is recorded. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy: R, Q, and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters (R, Q, optional delays and period). name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check begins. period ( float ) \u2013 Time interval for periodic inventory checks. If 0, continuous checking is used. Methods: Name Description run Continuously monitors inventory and places replenishment orders when the reorder point is reached. Initialize the RQ replenishment policy object. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters R, Q, and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters (R, Q, optional delays and period). name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check begins. period ( float ) \u2013 Time interval for periodic inventory checks. If 0, continuous checking is used. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env, node, params): \"\"\" Initialize the RQ replenishment policy object. Parameters: env (simpy.Environment): Simulation environment. node (object): Node to which this policy applies. params (dict): Replenishment policy parameters R, Q, and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys (list): List of keys to include in the info dictionary. env (simpy.Environment): Simulation environment. node (object): Node to which this policy applies. params (dict): Replenishment policy parameters (R, Q, optional delays and period). name (str): Replenishment policy name. first_review_delay (float): Delay before the first inventory check begins. period (float): Time interval for periodic inventory checks. If 0, continuous checking is used. Returns: None \"\"\" validate_non_negative(\"Reorder point (R)\", params['R']) # this assertion ensures that the reorder point is non-negative validate_positive(\"Order quantity (Q)\", params['Q']) # this assertion ensures that the order quantity is positive super().__init__(env, node, params) self._info_keys.extend([\"name\", \"first_review_delay\", \"period\"]) # add the keys to the info dictionary self.name = \"RQ replenishment (R, Q)\" self.first_review_delay = params.get('first_review_delay', 0) self.period = params.get('period', 0) run run() Continuously monitors the inventory and places replenishment orders when the inventory level falls to or below the reorder point (R). If a periodic review interval is provided, inventory is checked at that interval. Otherwise, the system waits for inventory drop events to trigger the next check. Attributes: R ( float ) \u2013 Reorder point. Q ( float ) \u2013 Replenishment quantity. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" Continuously monitors the inventory and places replenishment orders when the inventory level falls to or below the reorder point (R). If a periodic review interval is provided, inventory is checked at that interval. Otherwise, the system waits for inventory drop events to trigger the next check. Parameters: None Attributes: R (float): Reorder point. Q (float): Replenishment quantity. Returns: None \"\"\" R, Q = self.params['R'], self.params['Q'] if self.first_review_delay > 0: yield self.env.timeout(self.first_review_delay) while True: self.node.logger.logger.info(f\"{self.env.now:.4f}:{self.node.ID}: Inventory levels: {self.node.inventory.inventory.level}, on hand: {self.node.inventory.on_hand}\") if (self.node.inventory.on_hand - self.node.stats.backorder[1] <= R): supplier = self.node.selection_policy.select(Q) self.node.ongoing_order = True self.env.process(self.node.process_order(supplier, Q)) if self.period == 0: yield self.node.inventory_drop self.node.inventory_drop = self.env.event() else: yield self.env.timeout(self.period) PeriodicReplenishment PeriodicReplenishment(env, node, params) Bases: InventoryReplenishment Implements a time-based inventory replenishment policy where a fixed quantity Q is ordered at regular intervals T with optional safety stock support. This policy ensures consistent inventory reviews and replenishment, independent of the current stock level. Supports an optional initial review delay before starting periodic checks. Supplier selection is automatically managed using the node\u2019s defined supplier selection policy. Shortages are recorded if the supplier does not have enough stock. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Dictionary containing replenishment parameters: T, Q, and optional parameters (safety_stock, first_review_delay). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy. name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check. Methods: Name Description run Continuously manages periodic replenishment by placing orders of size Q every T time units. Initialize the replenishment policy object. Parameters: env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (T, Q), and optional parameters (safety_stock, first_review_delay). Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (T, Q) name ( str ) \u2013 replenishment policy name first_review_delay ( float ) \u2013 delay before the first inventory check is performed Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env, node, params): \"\"\" Initialize the replenishment policy object. Parameters: env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (T, Q), and optional parameters (safety_stock, first_review_delay). Attributes: _info_keys (list): list of keys to include in the info dictionary env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (T, Q) name (str): replenishment policy name first_review_delay (float): delay before the first inventory check is performed Returns: None \"\"\" validate_positive(\"Replenishment period (T)\", params['T']) # this assertion ensures that the replenishment period is positive validate_positive(\"Replenishment quantity (Q)\", params['Q']) # this assertion ensures that the replenishment quantity is positive super().__init__(env, node, params) self._info_keys.extend([\"name\", \"first_review_delay\"]) # add the keys to the info dictionary self.name = \"Periodic replenishment (T, Q)\" self.first_review_delay = params.get('first_review_delay', 0) run run() Replenishes the inventory based on the periodic policy. Attributes: name ( str ) \u2013 replenishment policy name _info_keys ( list ) \u2013 list of keys to include in the info dictionary Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" Replenishes the inventory based on the periodic policy. Parameters: None Attributes: name (str): replenishment policy name _info_keys (list): list of keys to include in the info dictionary Returns: None \"\"\" T, Q = self.params['T'], self.params['Q'] # get the period and quantity ss = 0 if 'safety_stock' in self.params: # check if safety_stock is specified validate_non_negative(\"Safety stock\", self.params['safety_stock']) self.name = \"Periodic with safety replenishment (T, Q, safety_stock)\" ss = self.params['safety_stock'] if self.first_review_delay > 0: yield self.env.timeout(self.first_review_delay) while True: self.node.logger.logger.info(f\"{self.env.now:.4f}:{self.node.ID}: Inventory levels:{self.node.inventory.inventory.level}, on hand:{self.node.inventory.on_hand}\") reorder_quantity = Q if (self.node.inventory.level < ss): reorder_quantity += ss - self.node.inventory.level supplier = self.node.selection_policy.select(reorder_quantity) # select a supplier based on the supplier selection policy self.node.ongoing_order = True self.env.process(self.node.process_order(supplier, reorder_quantity)) yield self.env.timeout(T) # periodic replenishment, wait for the next period SupplierSelectionPolicy SupplierSelectionPolicy(node, mode='dynamic') Bases: InfoMixin , NamedEntity Defines the framework for supplier selection strategies in the supply chain. Supports two modes: (1) \"dynamic\": Supplier selection is flexible and can change based on real-time conditions. (2) \"fixed\": Always selects a pre-assigned supplier. The policy is applied at the node level, and this class serves as a base for implementing custom supplier selection policies. The 'select' method must be overridden in subclasses to define specific supplier selection logic. Parameters: node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode. Must be \"dynamic\" or \"fixed\". Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier ( object ) \u2013 Fixed supplier if the mode is set to \"fixed\". Methods: Name Description select Supplier selection logic to be implemented by subclasses. validate_suppliers Validates that the node has at least one connected supplier. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier ( object ) \u2013 Fixed supplier if the mode is set to \"fixed\". Returns: \u2013 None Raises: ValueError \u2013 If the mode is not \"dynamic\" or \"fixed\". TypeError \u2013 If the node is not an instance of Node class. Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node for which the supplier selection policy is applied. mode (str): Supplier selection mode (\"dynamic\" or \"fixed\"). Attributes: _info_keys (list): List of keys to include in the info dictionary. node (object): Node for which the supplier selection policy is applied. mode (str): Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier (object): Fixed supplier if the mode is set to \"fixed\". Returns: None Raises: ValueError: If the mode is not \"dynamic\" or \"fixed\". TypeError: If the node is not an instance of Node class. \"\"\" if mode not in [\"dynamic\", \"fixed\"]: global_logger.logger.error(f\"Invalid mode: {mode}. Mode must be either 'dynamic' or 'fixed'.\") raise ValueError(\"Mode must be either 'dynamic' or 'fixed'.\") if not isinstance(node, Node): global_logger.logger.error(\"Node must be an instance of Node class.\") raise TypeError(\"Node must be an instance of Node class.\") self._info_keys = [\"node\", \"mode\"] self.node = node self.mode = mode self.fixed_supplier = None select select(order_quantity) Supplier selection logic to be implemented by subclasses. Parameters: order_quantity ( float ) \u2013 Quantity to be ordered. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Supplier selection logic to be implemented by subclasses. Parameters: order_quantity (float): Quantity to be ordered. Returns: None \"\"\" raise NotImplementedError(\"Subclasses must implement this method.\") validate_suppliers validate_suppliers() Validates that the node has at least one connected supplier. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def validate_suppliers(self): \"\"\" Validates that the node has at least one connected supplier. Returns: None \"\"\" if not self.node.suppliers: global_logger.logger.error(f\"{self.node.ID} must have at least one supplier.\") raise ValueError(f\"{self.node.ID} must have at least one supplier.\") SelectFirst SelectFirst(node, mode='fixed') Bases: SupplierSelectionPolicy Implements a supplier selection policy that always selects the first supplier in the supplier list. In dynamic mode, the first supplier is selected at each order event. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'fixed' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"fixed\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode. fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the first supplier, either dynamically or as a fixed supplier. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'fixed' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"fixed\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"fixed\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"fixed\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"First fixed supplier\" self._info_keys.extend([\"name\"]) select select(order_quantity) Selects the first supplier in the supplier list. In dynamic mode, the selection is evaluated for each order. In fixed mode, the first supplier is locked for all subsequent selections. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the first supplier in the supplier list. In dynamic mode, the selection is evaluated for each order. In fixed mode, the first supplier is locked for all subsequent selections. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = self.node.suppliers[0] if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected SelectAvailable SelectAvailable(node, mode='dynamic') Bases: SupplierSelectionPolicy Selects the first supplier that has sufficient available inventory to fulfill the requested order quantity. If no supplier can fully meet the order, it defaults to the first supplier in the list. Supports both dynamic selection (evaluated at each order event) and fixed selection (locks the first selected supplier). Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode. fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the first available supplier with sufficient inventory. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"First available supplier\" self._info_keys.extend([\"name\"]) select select(order_quantity) Selects the first supplier with sufficient available inventory. If no supplier can fully meet the requested order quantity, defaults to the first supplier in the list. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the first supplier with sufficient available inventory. If no supplier can fully meet the requested order quantity, defaults to the first supplier in the list. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = self.node.suppliers[0] suppliers = [s for s in self.node.suppliers if s.source.inventory.inventory.level >= order_quantity] if suppliers: selected = suppliers[0] if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected SelectCheapest SelectCheapest(node, mode='dynamic') Bases: SupplierSelectionPolicy Selects the supplier offering the lowest transportation cost for the order. The supplier is chosen based on the minimum transportation cost among all connected suppliers. Supports both dynamic selection (evaluated at each order event) and fixed selection (locks the first selected supplier). Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode. fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the supplier with the lowest transportation cost. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"Cheapest supplier (Transportation cost)\" self._info_keys.extend([\"name\"]) select select(order_quantity) Selects the supplier with the lowest transportation cost. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the supplier with the lowest transportation cost. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = min(self.node.suppliers, key=lambda s: s.cost) if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected SelectFastest SelectFastest(node, mode='dynamic') Bases: SupplierSelectionPolicy Selects the supplier with the shortest lead time to deliver the product. The selection is based on minimizing lead time among all connected suppliers. Supports both dynamic selection (evaluated at each order event) and fixed selection (locks the first selected supplier for all subsequent orders). Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the supplier with the shortest lead time based on the configured mode. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str, optional): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"Fastest supplier (Lead time)\" self._info_keys.extend([\"name\"]) select select(order_quantity) Selects the supplier with the shortest lead time. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the supplier with the shortest lead time. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = min(self.node.suppliers, key=lambda s: s.lead_time()) if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected Node Node(env: Environment, ID: str, name: str, node_type: str, failure_p: float = 0.0, node_disrupt_time: callable = None, node_recovery_time: callable = lambda: 1, logging: bool = True, **kwargs) Bases: NamedEntity , InfoMixin Represents a node in the supply network, such as a supplier, manufacturer, warehouse, distributor, retailer, or demand point. Supports automatic disruption and recovery, dynamic logging, and performance tracking. Each node can experience disruptions either probabilistically or based on custom-defined disruption and recovery times. During disruptions, the node becomes inactive and resumes operations after the specified recovery period. Tracks key performance metrics like transportation costs, node-specific costs, profit and net profit, products sold, demand placed, and shortages. Supports integration with inbuilt replenishment policies: SS, RQ, Periodic and any custom policy created by extending the ReplenishmentPolicy class. Supplier selection policies: Available, Cheapest, Fastest and any custom policy created by extending the SupplierSelectionPolicy class. Supported node types: \"infinite_supplier\", \"supplier\", \"manufacturer\", \"factory\", \"warehouse\", \"distributor\", \"retailer\", \"store\", \"demand\" Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique node ID. name ( str ) \u2013 Node name. node_type ( str ) \u2013 Type of the node. failure_p ( float , default: 0.0 ) \u2013 Probability of node failure. node_disrupt_time ( callable , default: None ) \u2013 Function to generate disruption time. node_recovery_time ( callable , default: lambda: 1 ) \u2013 Function to generate recovery time. logging ( bool , default: True ) \u2013 Flag to enable/disable logging. **kwargs \u2013 Additional arguments for the logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 ID of the node (alphanumeric) name ( str ) \u2013 name of the node node_type ( str ) \u2013 type of the node node_failure_p ( float ) \u2013 node failure probability node_status ( str ) \u2013 status of the node (active/inactive) node_disrupt_time ( callable ) \u2013 function to model node disruption time node_recovery_time ( callable ) \u2013 function to model node recovery time logger ( GlobalLogger ) \u2013 logger object Methods: Name Description disruption Simulates node disruption and automatic recovery over time. Initialize the node object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique node ID. name ( str ) \u2013 Node name. node_type ( str ) \u2013 Type of the node. failure_p ( float , default: 0.0 ) \u2013 Probability of node failure. node_disrupt_time ( callable , default: None ) \u2013 Function to generate disruption time. node_recovery_time ( callable , default: lambda: 1 ) \u2013 Function to generate recovery time. logging ( bool , default: True ) \u2013 Flag to enable/disable logging. **kwargs \u2013 Additional arguments for the logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 ID of the node (alphanumeric) name ( str ) \u2013 name of the node node_type ( str ) \u2013 type of the node node_failure_p ( float ) \u2013 node failure probability node_status ( str ) \u2013 status of the node (active/inactive) node_disrupt_time ( callable ) \u2013 function to model node disruption time node_recovery_time ( callable ) \u2013 function to model node recovery time logger ( GlobalLogger ) \u2013 logger object Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, node_type: str, failure_p:float = 0.0, node_disrupt_time:callable = None, node_recovery_time:callable = lambda: 1, logging: bool = True, **kwargs) -> None: \"\"\" Initialize the node object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique node ID. name (str): Node name. node_type (str): Type of the node. failure_p (float, optional): Probability of node failure. node_disrupt_time (callable, optional): Function to generate disruption time. node_recovery_time (callable, optional): Function to generate recovery time. logging (bool, optional): Flag to enable/disable logging. **kwargs: Additional arguments for the logger. Attributes: _info_keys (list): List of keys to include in the info dictionary. env (simpy.Environment): simulation environment ID (str): ID of the node (alphanumeric) name (str): name of the node node_type (str): type of the node node_failure_p (float): node failure probability node_status (str): status of the node (active/inactive) node_disrupt_time (callable): function to model node disruption time node_recovery_time (callable): function to model node recovery time logger (GlobalLogger): logger object Returns: None \"\"\" if not isinstance(env, simpy.Environment): raise ValueError(\"Invalid environment. Provide a valid SimPy environment.\") if(node_type.lower() not in [\"infinite_supplier\",\"supplier\", \"manufacturer\", \"factory\", \"warehouse\", \"distributor\", \"retailer\", \"store\", \"demand\"]): global_logger.logger.error(f\"Invalid node type. Node type: {node_type}\") raise ValueError(\"Invalid node type.\") if not callable(node_recovery_time): node_recovery_time = lambda val=node_recovery_time: val # convert to a callable function if node_disrupt_time is not None: if not callable(node_disrupt_time): node_disrupt_time = lambda val=node_disrupt_time: val # convert to a callable function validate_number(name=\"node_disrupt_time\", value=node_disrupt_time()) # check if disrupt_time is a number if node_recovery_time is not None: validate_number(name=\"node_recovery_time\", value=node_recovery_time()) # check if disrupt_time is a number self._info_keys = [\"ID\", \"name\", \"node_type\", \"failure_p\", \"node_status\", \"logging\"] self.env = env # simulation environment self.ID = ID # ID of the node (alphanumeric) self.name = name # name of the node self.node_type = node_type # type of the node (supplier, manufacturer, warehouse, distributor, retailer, demand) self.node_failure_p = failure_p # node failure probability self.node_status = \"active\" # node status (active/inactive) self.node_disrupt_time = node_disrupt_time # callable function to model node disruption time self.node_recovery_time = node_recovery_time # callable function to model node recovery time logger_name = self.ID # default logger name is the node ID if 'logger_name' in kwargs.keys(): logger_name = kwargs['logger_name'] self.logger = GlobalLogger(logger_name=logger_name, **kwargs) # create a logger if not logging: self.logger.disable_logging() # disable logging if logging is False else: self.logger.enable_logging() if(self.node_failure_p>0 or self.node_disrupt_time): # start self disruption if failure probability > 0 self.env.process(self.disruption()) disruption disruption() This method disrupts the node by changing the node status to \"inactive\" and recovers it after the specified recovery time. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def disruption(self): \"\"\" This method disrupts the node by changing the node status to \"inactive\" and recovers it after the specified recovery time. Parameters: None Attributes: None Returns: None \"\"\" # TODO: interrupt all ongoing processes spawned by this node on disruption, and resume them after recovery. while True: if(self.node_status==\"active\"): if(self.node_disrupt_time): # if node_disrupt_time is provided, wait for the disruption time disrupt_time = self.node_disrupt_time() # get the disruption time validate_positive(name=\"node_disrupt_time\", value=disrupt_time) # check if disrupt_time is positive yield self.env.timeout(disrupt_time) self.node_status = \"inactive\" # change the node status to inactive self.logger.logger.info(f\"{self.env.now}:{self.ID}: Node disrupted.\") elif(random.random() < self.node_failure_p): self.node_status = \"inactive\" self.logger.logger.info(f\"{self.env.now}:{self.ID}: Node disrupted.\") yield self.env.timeout(1) else: recovery_time = self.node_recovery_time() # get the recovery time validate_positive(name=\"node_recovery_time\", value=recovery_time) # check if disrupt_time is positive yield self.env.timeout(recovery_time) self.node_status = \"active\" self.logger.logger.info(f\"{self.env.now}:{self.ID}: Node recovered from disruption.\") Link Link(env: Environment, ID: str, source: Node, sink: Node, cost: float, lead_time: callable, link_failure_p: float = 0.0, link_disrupt_time: callable = None, link_recovery_time: callable = lambda: 1) Bases: NamedEntity , InfoMixin Represents a transportation connection between two nodes in the supply network. Each link carries a transportation cost and lead time. Links can experience disruptions based on a failure probability or a disruption time distribution and will automatically recover after a specified recovery time. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 ID of the link. source ( Node ) \u2013 Source node of the link. sink ( Node ) \u2013 Sink node of the link. cost ( float ) \u2013 Transportation cost of the link. lead_time ( callable ) \u2013 Function returning lead time for the link. link_failure_p ( float , default: 0.0 ) \u2013 Probability of random link failure. link_disrupt_time ( callable , default: None ) \u2013 Function returning time to next disruption. link_recovery_time ( callable , default: lambda: 1 ) \u2013 Function returning recovery time after disruption. Attributes: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 ID of the link. source ( Node ) \u2013 Source node. sink ( Node ) \u2013 Sink node. cost ( float ) \u2013 Transportation cost. lead_time ( callable ) \u2013 Function for stochastic lead time. link_failure_p ( float ) \u2013 Failure probability. status ( str ) \u2013 Current status of the link (\"active\" or \"inactive\"). link_disrupt_time ( callable ) \u2013 Disruption time function. link_recovery_time ( callable ) \u2013 Recovery time function. Methods: Name Description disruption Simulates link disruption and automatic recovery. Initialize the Link object representing a transportation connection between two nodes. Parameters: env ( Environment ) \u2013 The simulation environment. ID ( str ) \u2013 Unique identifier for the link. source ( Node ) \u2013 The source node of the link. Cannot be a demand node. sink ( Node ) \u2013 The sink node of the link. Cannot be a supplier node. cost ( float ) \u2013 Transportation cost associated with the link. Must be non-negative. lead_time ( callable ) \u2013 Function returning the stochastic lead time. Cannot be None. link_failure_p ( float , default: 0.0 ) \u2013 Probability of random link failure. Default is 0.0. link_disrupt_time ( callable , default: None ) \u2013 Function returning the time to the next disruption. If provided, overrides link_failure_p. link_recovery_time ( callable , default: lambda: 1 ) \u2013 Function returning the time required for link recovery after disruption. Default is a constant 1 unit. Attributes: env ( Environment ) \u2013 The simulation environment. ID ( str ) \u2013 The ID of the link. source ( Node ) \u2013 The source node. sink ( Node ) \u2013 The sink node. name ( str ) \u2013 Readable name of the link combining source and sink IDs. cost ( float ) \u2013 Transportation cost. lead_time ( callable ) \u2013 Lead time function. link_failure_p ( float ) \u2013 Link failure probability. status ( str ) \u2013 Link status (\"active\" or \"inactive\"). link_recovery_time ( callable ) \u2013 Link recovery time function. link_disrupt_time ( callable ) \u2013 Disruption time function. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, source: Node, sink: Node, cost: float, # transportation cost lead_time: callable, link_failure_p: float = 0.0, link_disrupt_time: callable = None, link_recovery_time: callable = lambda: 1) -> None: \"\"\" Initialize the Link object representing a transportation connection between two nodes. Parameters: env (simpy.Environment): The simulation environment. ID (str): Unique identifier for the link. source (Node): The source node of the link. Cannot be a demand node. sink (Node): The sink node of the link. Cannot be a supplier node. cost (float): Transportation cost associated with the link. Must be non-negative. lead_time (callable): Function returning the stochastic lead time. Cannot be None. link_failure_p (float, optional): Probability of random link failure. Default is 0.0. link_disrupt_time (callable, optional): Function returning the time to the next disruption. If provided, overrides link_failure_p. link_recovery_time (callable, optional): Function returning the time required for link recovery after disruption. Default is a constant 1 unit. Attributes: env (simpy.Environment): The simulation environment. ID (str): The ID of the link. source (Node): The source node. sink (Node): The sink node. name (str): Readable name of the link combining source and sink IDs. cost (float): Transportation cost. lead_time (callable): Lead time function. link_failure_p (float): Link failure probability. status (str): Link status (\"active\" or \"inactive\"). link_recovery_time (callable): Link recovery time function. link_disrupt_time (callable): Disruption time function. Returns: None \"\"\" self._info_keys = [\"ID\", \"source\", \"sink\", \"cost\", \"lead_time\", \"link_failure_p\"] self._stats_keys = [\"status\"] if not isinstance(env, simpy.Environment): raise ValueError(\"Invalid environment. Provide a valid SimPy environment.\") if not isinstance(source, Node) or not isinstance(sink, Node): raise ValueError(\"Invalid source or sink node. Provide valid Node instances.\") if not callable(lead_time): lead_time = lambda val=lead_time: val # convert to callable if(lead_time == None): global_logger.logger.error(\"Lead time cannot be None. Provide a function to model stochastic lead time.\") raise ValueError(\"Lead time cannot be None. Provide a function to model stochastic lead time.\") if(source == sink): global_logger.logger.error(\"Source and sink nodes cannot be the same.\") raise ValueError(\"Source and sink nodes cannot be the same.\") if(source.node_type == \"demand\"): global_logger.logger.error(\"Demand node cannot be a source node.\") raise ValueError(\"Demand node cannot be a source node.\") if(\"supplier\" in sink.node_type): global_logger.logger.error(\"Supplier node cannot be a sink node.\") raise ValueError(\"Supplier node cannot be a sink node.\") if(\"supplier\" in source.node_type and \"supplier\" in sink.node_type): global_logger.logger.error(\"Supplier nodes cannot be connected.\") raise ValueError(\"Supplier nodes cannot be connected.\") if(\"supplier\" in source.node_type and sink.node_type == \"demand\"): global_logger.logger.error(\"Supplier node cannot be connected to a demand node.\") raise ValueError(\"Supplier node cannot be connected to a demand node.\") validate_non_negative(\"Cost\", cost) if (link_disrupt_time is not None): validate_number(name=\"link_disrupt_time\", value=link_disrupt_time()) # check if disrupt_time is a number if (link_recovery_time is not None): validate_number(name=\"link_recovery_time\", value=link_recovery_time()) # check if disrupt_time is a number self.env = env # simulation environment self.ID = ID # ID of the link (alphanumeric) self.source = source # source node of the link self.sink = sink # sink node of the link self.name = f\"{self.source.ID} to {self.sink.ID}\" # name of the link self.cost = cost # cost of the link self.lead_time = lead_time # lead time of the link self.link_failure_p = link_failure_p # link failure probability self.status = \"active\" # link status (active/inactive) self.link_recovery_time = link_recovery_time # link recovery time self.link_disrupt_time = link_disrupt_time # link disruption time, if provided self.sink.suppliers.append(self) # add the link as a supplier link to the sink node if(self.link_failure_p>0 or self.link_disrupt_time): # disrupt the link if link_failure_p > 0 self.env.process(self.disruption()) disruption disruption() This method disrupts the link by changing the link status to \"inactive\" and recovers it after the specified recovery time. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def disruption(self): \"\"\" This method disrupts the link by changing the link status to \"inactive\" and recovers it after the specified recovery time. Parameters: None Attributes: None Returns: None \"\"\" # TODO: interrupt all ongoing transports by this link on disruption. while True: if(self.status==\"active\"): if(self.link_disrupt_time): # if link_disrupt_time is provided, wait for the disruption time disrupt_time = self.link_disrupt_time() # get the disruption time validate_positive(name=\"link_disrupt_time\", value=disrupt_time) # check if disrupt_time is positive yield self.env.timeout(disrupt_time) self.status = \"inactive\" # change the link status to inactive global_logger.logger.info(f\"{self.env.now}:{self.ID}: Link disrupted.\") elif(random.random() < self.link_failure_p): self.status = \"inactive\" global_logger.logger.info(f\"{self.env.now}:{self.ID}: Link disrupted.\") yield self.env.timeout(1) else: recovery_time = self.link_recovery_time() # get the recovery time validate_positive(name=\"link_recovery_time\", value=recovery_time) # check if disrupt_time is positive yield self.env.timeout(recovery_time) self.status = \"active\" global_logger.logger.info(f\"{self.env.now}:{self.ID}: Link recovered from disruption.\") Inventory Inventory(env: Environment, capacity: float, initial_level: float, node: Node, replenishment_policy: InventoryReplenishment, holding_cost: float = 0.0, shelf_life: float = 0, inv_type: str = 'non-perishable') Bases: NamedEntity , InfoMixin The Inventory class models stock management within a node in the supply network. It supports both perishable and non-perishable items, enforces capacity limits, tracks on-hand levels, and notifies replenishment policy whenever inventory levels drops. For perishable inventories, it manages product shelf life and automatically removes expired items. The class also records inventory levels and calculates carrying costs over time. Parameters: env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. node ( Node ) \u2013 Node to which this inventory belongs. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy for the inventory. holding_cost ( float , default: 0.0 ) \u2013 Holding cost per unit per time period. shelf_life ( float , default: 0 ) \u2013 Shelf life for perishable items. inv_type ( str , default: 'non-perishable' ) \u2013 Type of the inventory, either \"non-perishable\" or \"perishable\". Attributes: _info_keys ( list ) \u2013 Keys included in the information dictionary. _stats_keys ( list ) \u2013 Keys included in the statistics dictionary. env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum inventory capacity. init_level ( float ) \u2013 Initial inventory level. level ( float ) \u2013 Current inventory level. on_hand ( float ) \u2013 Current on-hand inventory. inv_type ( str ) \u2013 Inventory type (\"non-perishable\" or \"perishable\"). holding_cost ( float ) \u2013 Holding cost per unit. carry_cost ( float ) \u2013 Total accumulated carrying cost. replenishment_policy ( InventoryReplenishment ) \u2013 Inventory replenishment policy. inventory ( Container ) \u2013 SimPy container managing inventory levels. last_update_t ( float ) \u2013 Last timestamp when carrying cost was updated. shelf_life ( float ) \u2013 Shelf life of perishable items (if applicable). perish_queue ( list ) \u2013 Queue managing perishable items as (manufacturing_date, quantity). waste ( float ) \u2013 Total quantity of expired items. instantaneous_levels ( list ) \u2013 Recorded inventory levels over time. Methods: Name Description record_inventory_levels Records inventory levels at regular time intervals. put Adds items to the inventory, handling perishable item tracking. get Removes items from inventory, using FIFO for perishables. remove_expired Automatically removes expired items from perishable inventory. update_carry_cost Updates carrying cost based on inventory level and holding time. Initialize the Inventory object. Parameters: env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. node ( Node ) \u2013 Node to which this inventory belongs. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy for the inventory. holding_cost ( float , default: 0.0 ) \u2013 Holding cost per unit per time period. shelf_life ( float , default: 0 ) \u2013 Shelf life for perishable items. inv_type ( str , default: 'non-perishable' ) \u2013 Type of the inventory, either \"non-perishable\" or \"perishable\". Attributes: _info_keys ( list ) \u2013 Keys included in the information dictionary. _stats_keys ( list ) \u2013 Keys included in the statistics dictionary. env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum inventory capacity. init_level ( float ) \u2013 Initial inventory level. level ( float ) \u2013 Current inventory level. on_hand ( float ) \u2013 Current on-hand inventory. inv_type ( str ) \u2013 Inventory type (\"non-perishable\" or \"perishable\"). holding_cost ( float ) \u2013 Holding cost per unit. carry_cost ( float ) \u2013 Total accumulated carrying cost. replenishment_policy ( InventoryReplenishment ) \u2013 Inventory replenishment policy. inventory ( Container ) \u2013 SimPy container managing inventory levels. last_update_t ( float ) \u2013 Last timestamp when carrying cost was updated. shelf_life ( float ) \u2013 Shelf life of perishable items (if applicable). perish_queue ( list ) \u2013 Queue managing perishable items as (manufacturing_date, quantity). waste ( float ) \u2013 Total quantity of expired items. instantaneous_levels ( list ) \u2013 Recorded inventory levels over time. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, capacity: float, initial_level: float, node: Node, replenishment_policy: InventoryReplenishment, holding_cost: float = 0.0, shelf_life: float = 0, inv_type: str = \"non-perishable\") -> None: \"\"\" Initialize the Inventory object. Parameters: env (simpy.Environment): Simulation environment. capacity (float): Maximum capacity of the inventory. initial_level (float): Initial inventory level. node (Node): Node to which this inventory belongs. replenishment_policy (InventoryReplenishment): Replenishment policy for the inventory. holding_cost (float): Holding cost per unit per time period. shelf_life (float): Shelf life for perishable items. inv_type (str): Type of the inventory, either \"non-perishable\" or \"perishable\". Attributes: _info_keys (list): Keys included in the information dictionary. _stats_keys (list): Keys included in the statistics dictionary. env (simpy.Environment): Simulation environment. capacity (float): Maximum inventory capacity. init_level (float): Initial inventory level. level (float): Current inventory level. on_hand (float): Current on-hand inventory. inv_type (str): Inventory type (\"non-perishable\" or \"perishable\"). holding_cost (float): Holding cost per unit. carry_cost (float): Total accumulated carrying cost. replenishment_policy (InventoryReplenishment): Inventory replenishment policy. inventory (simpy.Container): SimPy container managing inventory levels. last_update_t (float): Last timestamp when carrying cost was updated. shelf_life (float): Shelf life of perishable items (if applicable). perish_queue (list): Queue managing perishable items as (manufacturing_date, quantity). waste (float): Total quantity of expired items. instantaneous_levels (list): Recorded inventory levels over time. Returns: None \"\"\" if not isinstance(node, Node): global_logger.logger.error(\"Node must be an instance of Node class.\") raise TypeError(\"Node must be an instance of Node class.\") self.node = node # node to which this inventory belongs if initial_level > capacity: self.node.logger.logger.error(\"Initial level cannot be greater than capacity.\") raise ValueError(\"Initial level cannot be greater than capacity.\") if replenishment_policy is not None: if not issubclass(replenishment_policy.__class__, InventoryReplenishment): self.node.logger.logger.error(f\"{replenishment_policy.__name__} must inherit from InventoryReplenishment\") raise TypeError(f\"{replenishment_policy.__name__} must inherit from InventoryReplenishment\") if inv_type not in [\"non-perishable\", \"perishable\"]: self.node.logger.logger.error(f\"Invalid inventory type. {inv_type} is not yet available.\") raise ValueError(f\"Invalid inventory type. {inv_type} is not yet available.\") validate_positive(\"Capacity\", capacity) validate_non_negative(\"Initial level\", initial_level) validate_non_negative(\"Inventory holding cost\",holding_cost) validate_non_negative(\"Shelf life\", shelf_life) self._info_keys = [\"capacity\", \"initial_level\", \"replenishment_policy\", \"holding_cost\", \"shelf_life\", \"inv_type\"] self._stats_keys = [\"level\", \"carry_cost\", \"instantaneous_levels\"] self.env = env self.capacity = capacity self.init_level = initial_level self.level = initial_level self.on_hand = initial_level # current inventory level self.inv_type = inv_type self.holding_cost = holding_cost self.carry_cost = 0 # initial carrying cost based on the initial inventory level self.replenishment_policy = replenishment_policy self.inventory = simpy.Container(env=self.env, capacity=self.capacity, init=self.init_level) # Inventory container setup self.last_update_t = self.env.now # last time the carrying cost was updated if self.inv_type == \"perishable\": validate_positive(\"Shelf life\", shelf_life) self.shelf_life = shelf_life self.perish_queue = [(0, initial_level)] self.waste = 0 self.env.process(self.remove_expired()) self.instantaneous_levels = [] self.env.process(self.record_inventory_levels()) # record inventory levels at regular intervals record_inventory_levels record_inventory_levels() Record inventory levels at regular intervals. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def record_inventory_levels(self): \"\"\" Record inventory levels at regular intervals. Parameters: None Attributes: None Returns: None \"\"\" while True: self.instantaneous_levels.append((self.env.now,self.inventory.level)) # record the current inventory level yield self.env.timeout(1) put put(amount: float, manufacturing_date: float = None) Add items to inventory. For perishable items, tracks manufacturing date. Parameters: amount ( float ) \u2013 amount to add manufacturing_date ( float , default: None ) \u2013 only required for perishable inventories Source code in src/SupplyNetPy/Components/core.py def put(self, amount: float, manufacturing_date: float = None): \"\"\" Add items to inventory. For perishable items, tracks manufacturing date. Parameters: amount (float): amount to add manufacturing_date (float): only required for perishable inventories \"\"\" if self.inventory.level == float('inf') or amount <=0: return if self.inv_type == \"perishable\": if manufacturing_date is None: self.node.logger.logger.error(\"Manufacturing date must be provided for perishable inventory.\") raise ValueError(\"Manufacturing date must be provided for perishable inventory.\") inserted = False for i in range(len(self.perish_queue)): if self.perish_queue[i][0] > manufacturing_date: self.perish_queue.insert(i, (manufacturing_date, amount)) inserted = True break if not inserted: self.perish_queue.append((manufacturing_date, amount)) self.update_carry_cost() # Update carrying cost based on the amount added self.inventory.put(amount) self.level = self.inventory.level # Update the current inventory level if(not self.node.inventory_raised.triggered): self.node.inventory_raised.succeed() # signal that inventory has been raised get get(amount: float) Remove items from inventory. For perishable items, oldest products are removed first. Parameters: amount ( float ) \u2013 amount to remove Returns: tuple \u2013 (SimPy get event, List of (manufacture_date, quantity)) for perishable items Source code in src/SupplyNetPy/Components/core.py def get(self, amount: float): \"\"\" Remove items from inventory. For perishable items, oldest products are removed first. Parameters: amount (float): amount to remove Returns: tuple: (SimPy get event, List of (manufacture_date, quantity)) for perishable items \"\"\" if self.inventory.level == float('inf'): return self.inventory.get(amount), [] man_date_ls = [] if self.inv_type == \"perishable\": x_amount = amount while x_amount > 0 and self.perish_queue: mfg_date, qty = self.perish_queue[0] if qty <= x_amount: man_date_ls.append((mfg_date, qty)) x_amount -= qty self.perish_queue.pop(0) else: man_date_ls.append((mfg_date, x_amount)) self.perish_queue[0] = (mfg_date, qty - x_amount) x_amount = 0 self.update_carry_cost() get_event = self.inventory.get(amount) self.level = self.inventory.level # Update the current inventory level self.on_hand -= amount # Update the on-hand inventory level if(self.replenishment_policy): if(not self.node.inventory_drop.triggered): self.node.inventory_drop.succeed() # signal that inventory has been dropped return get_event, man_date_ls remove_expired remove_expired() Remove expired items from perishable inventory. Source code in src/SupplyNetPy/Components/core.py def remove_expired(self): \"\"\" Remove expired items from perishable inventory. \"\"\" while True: yield self.env.timeout(1) while self.perish_queue and self.env.now - self.perish_queue[0][0] >= self.shelf_life: mfg_date, qty = self.perish_queue[0] # get first item in the queue self.node.logger.logger.info(f\"{self.env.now:.4f}: {qty} units expired (Mgf date:{mfg_date}).\") self.waste += qty if qty > 0: self.get(qty) # get/remove expired items from the inventory else: self.perish_queue.pop(0) update_carry_cost update_carry_cost() Update the carrying cost of the inventory based on the current level and holding cost. Source code in src/SupplyNetPy/Components/core.py def update_carry_cost(self): \"\"\" Update the carrying cost of the inventory based on the current level and holding cost. \"\"\" carry_period = self.env.now - self.last_update_t self.carry_cost += self.inventory.level * (carry_period) * self.holding_cost # update the carrying cost based on the current inventory level self.last_update_t = self.env.now # update the last update time Supplier Supplier(env: Environment, ID: str, name: str, node_type: str = 'supplier', capacity: float = 0.0, initial_level: float = 0.0, inventory_holding_cost: float = 0.0, raw_material: RawMaterial = None, **kwargs) Bases: Node The Supplier class represents a supplier in the supply network that continuously extracts raw materials whenever the inventory is not full. Each supplier is associated with a specific raw material and can have either finite or infinite inventory capacity. For finite suppliers, raw materials are extracted in batches based on the extraction quantity and extraction time specified by the instance of RawMaterial class. For infinite suppliers, inventory is considered unlimited. Parameters: env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 unique identifier for the supplier name ( str ) \u2013 name of the supplier node_type ( str , default: 'supplier' ) \u2013 type of the node (supplier/infinite_supplier) capacity ( float , default: 0.0 ) \u2013 maximum capacity of the inventory initial_level ( float , default: 0.0 ) \u2013 initial inventory level inventory_holding_cost ( float , default: 0.0 ) \u2013 inventory holding cost raw_material ( RawMaterial , default: None ) \u2013 raw material supplied by the supplier **kwargs \u2013 any additional keyword arguments for the Node class and logger Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary. raw_material ( RawMaterial ) \u2013 raw material supplied by the supplier sell_price ( float ) \u2013 selling price of the raw material inventory ( Inventory ) \u2013 inventory of the supplier inventory_drop ( Event ) \u2013 event to signal when inventory is dropped inventory_raised ( Event ) \u2013 event to signal when inventory is raised stats ( Statistics ) \u2013 statistics object for the supplier Methods: Name Description behavior Simulates the continuous raw material extraction process. Initialize the supplier object. Parameters: env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 unique identifier for the supplier name ( str ) \u2013 name of the supplier node_type ( str , default: 'supplier' ) \u2013 type of the node (supplier/infinite_supplier) capacity ( float , default: 0.0 ) \u2013 maximum capacity of the inventory initial_level ( float , default: 0.0 ) \u2013 initial inventory level inventory_holding_cost ( float , default: 0.0 ) \u2013 inventory holding cost raw_material ( RawMaterial , default: None ) \u2013 raw material supplied by the supplier **kwargs \u2013 any additional keyword arguments for the Node class and logger Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary. raw_material ( RawMaterial ) \u2013 raw material supplied by the supplier sell_price ( float ) \u2013 selling price of the raw material inventory ( Inventory ) \u2013 inventory of the supplier inventory_drop ( Event ) \u2013 event to signal when inventory is dropped inventory_raised ( Event ) \u2013 event to signal when inventory is raised stats ( Statistics ) \u2013 statistics object for the supplier Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, node_type: str = \"supplier\", capacity: float = 0.0, initial_level: float = 0.0, inventory_holding_cost:float = 0.0, raw_material: RawMaterial = None, **kwargs) -> None: \"\"\" Initialize the supplier object. Parameters: env (simpy.Environment): simulation environment ID (str): unique identifier for the supplier name (str): name of the supplier node_type (str): type of the node (supplier/infinite_supplier) capacity (float): maximum capacity of the inventory initial_level (float): initial inventory level inventory_holding_cost (float): inventory holding cost raw_material (RawMaterial): raw material supplied by the supplier **kwargs: any additional keyword arguments for the Node class and logger Attributes: _info_keys (list): list of keys to include in the info dictionary. raw_material (RawMaterial): raw material supplied by the supplier sell_price (float): selling price of the raw material inventory (Inventory): inventory of the supplier inventory_drop (simpy.Event): event to signal when inventory is dropped inventory_raised (simpy.Event): event to signal when inventory is raised stats (Statistics): statistics object for the supplier Returns: None \"\"\" super().__init__(env=env,ID=ID,name=name,node_type=node_type,**kwargs) self._info_keys.extend([\"raw_material\", \"sell_price\"]) self.raw_material = raw_material # raw material supplied by the supplier self.sell_price = 0 if(self.raw_material): self.sell_price = self.raw_material.cost # selling price of the raw material if(self.node_type!=\"infinite_supplier\"): self.inventory = Inventory(env=self.env, capacity=capacity, initial_level=initial_level, node=self, holding_cost=inventory_holding_cost, replenishment_policy=None) self.inventory_drop = self.env.event() # event to signal when inventory is dropped self.inventory_raised = self.env.event() # signal to indicate that inventory has been raised if(self.raw_material): self.env.process(self.behavior()) # start the behavior process else: self.logger.logger.error(f\"{self.ID}:Raw material not provided for this supplier. Recreate it with a raw material.\") raise ValueError(\"Raw material not provided.\") else: self.inventory = Inventory(env=self.env, capacity=float('inf'), initial_level=float('inf'), node=self, holding_cost=inventory_holding_cost, replenishment_policy=None) self.stats = Statistics(self) setattr(self.stats,\"total_raw_materials_mined\",0) setattr(self.stats,\"total_material_cost\",0) self.stats._stats_keys.extend([\"total_raw_materials_mined\", \"total_material_cost\"]) behavior behavior() Supplier behavior: The supplier keeps extracting raw material whenever the inventory is not full. Assume that a supplier can extract a single type of raw material. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def behavior(self): \"\"\" Supplier behavior: The supplier keeps extracting raw material whenever the inventory is not full. Assume that a supplier can extract a single type of raw material. Parameters: None Attributes: None Returns: None \"\"\" while True: if(self.inventory.inventory.level < self.inventory.inventory.capacity): # check if the inventory is not full mined_quantity = self.raw_material.extraction_quantity if((self.inventory.inventory.level+self.raw_material.extraction_quantity)>self.inventory.inventory.capacity): # check if the inventory can accommodate the extracted quantity mined_quantity = self.inventory.inventory.capacity - self.inventory.inventory.level # update statistics self.inventory.put(mined_quantity) self.stats.update_stats(total_raw_materials_mined=mined_quantity, total_material_cost=mined_quantity*self.raw_material.mining_cost) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Raw material mined/extracted. Inventory level:{self.inventory.inventory.level}\") yield self.env.timeout(self.raw_material.extraction_time) else: yield self.env.timeout(1) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}: Inventory level:{self.inventory.inventory.level}\") # log every day/period inventory level InventoryNode InventoryNode(env: Environment, ID: str, name: str, node_type: str, capacity: float, initial_level: float, inventory_holding_cost: float, replenishment_policy: InventoryReplenishment, policy_param: dict, product_sell_price: float, product_buy_price: float, inventory_type: str = 'non-perishable', shelf_life: float = 0.0, manufacture_date: callable = None, product: Product = None, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = 'fixed', **kwargs) Bases: Node The InventoryNode class represents an inventory management node in the supply network, such as a retailer, a store, a warehouse, or distributor. It manages inventory levels, replenishment policies, supplier selection, and order processing dynamically. The node can handle both perishable and non-perishable inventories and supports automatic replenishment using various replenishment policies. The node can also interact with multiple supplier links and selects suppliers based on the configured selection policy. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the node. name ( str ) \u2013 Name of the inventory node. node_type ( str ) \u2013 Type of the inventory node (e.g., retailer or distributor). capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. inventory_holding_cost ( float ) \u2013 Inventory holding cost per unit. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product_sell_price ( float ) \u2013 Selling price of the product. product_buy_price ( float ) \u2013 Buying price of the product. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product for perishable items. manufacture_date ( callable , default: None ) \u2013 Function to model manufacturing date (used for perishable inventories). product ( Product , default: None ) \u2013 Product managed by the inventory node. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Mode for supplier selection (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object. inventory ( Inventory ) \u2013 Inventory object managing stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. manufacture_date ( callable ) \u2013 Manufacturing date generation function. sell_price ( float ) \u2013 Selling price of the product. buy_price ( float ) \u2013 Buying price of the product. product ( Product ) \u2013 Product managed by the node. suppliers ( list ) \u2013 List of supplier links connected to this node. ongoing_order ( bool ) \u2013 Indicates if an order is currently in process. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for this node. Methods: Name Description process_order Places an order with the selected supplier and updates inventory upon delivery. Initialize the inventory node object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the node. name ( str ) \u2013 Name of the inventory node. node_type ( str ) \u2013 Type of the inventory node (e.g., retailer or distributor). capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. inventory_holding_cost ( float ) \u2013 Inventory holding cost per unit. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product_sell_price ( float ) \u2013 Selling price of the product. product_buy_price ( float ) \u2013 Buying price of the product. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product for perishable items. manufacture_date ( callable , default: None ) \u2013 Function to model manufacturing date (used for perishable inventories). product ( Product , default: None ) \u2013 Product managed by the inventory node. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Mode for supplier selection (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object. inventory ( Inventory ) \u2013 Inventory object managing stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. manufacture_date ( callable ) \u2013 Manufacturing date generation function. sell_price ( float ) \u2013 Selling price of the product. buy_price ( float ) \u2013 Buying price of the product. product ( Product ) \u2013 Product managed by the node. suppliers ( list ) \u2013 List of supplier links connected to this node. ongoing_order ( bool ) \u2013 Indicates if an order is currently in process. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for this node. Returns: None \u2013 None Behavior The inventory node stocks the product in inventory to make it available to the consumer node or demand node (end customer). It orders product from its supplier node to maintain the right inventory levels according to the replenishment policy. The inventory node can have multiple suppliers. It chooses a supplier based on the specified supplier selection policy. The product buy and sell prices are set during initialization. The inventory node is expected to sell the product at a higher price than the buy price, but this is user-configured. Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, node_type: str, capacity: float, initial_level: float, inventory_holding_cost:float, replenishment_policy:InventoryReplenishment, policy_param: dict, product_sell_price: float, product_buy_price: float, inventory_type:str = \"non-perishable\", shelf_life:float = 0.0, manufacture_date:callable = None, product:Product = None, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = \"fixed\", **kwargs) -> None: \"\"\" Initialize the inventory node object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique identifier for the node. name (str): Name of the inventory node. node_type (str): Type of the inventory node (e.g., retailer or distributor). capacity (float): Maximum capacity of the inventory. initial_level (float): Initial inventory level. inventory_holding_cost (float): Inventory holding cost per unit. replenishment_policy (InventoryReplenishment): Replenishment policy object for the inventory. policy_param (dict): Parameters for the replenishment policy. product_sell_price (float): Selling price of the product. product_buy_price (float): Buying price of the product. inventory_type (str): Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life (float): Shelf life of the product for perishable items. manufacture_date (callable): Function to model manufacturing date (used for perishable inventories). product (Product): Product managed by the inventory node. supplier_selection_policy (SupplierSelectionPolicy): Supplier selection policy class. supplier_selection_mode (str): Mode for supplier selection (default is \"fixed\"). **kwargs: Additional keyword arguments for the Node class and logger. Attributes: _info_keys (list): List of keys to include in the info dictionary. replenishment_policy (InventoryReplenishment): Replenishment policy object. inventory (Inventory): Inventory object managing stock. inventory_drop (simpy.Event): Event triggered when inventory drops. inventory_raised (simpy.Event): Event triggered when inventory is replenished. manufacture_date (callable): Manufacturing date generation function. sell_price (float): Selling price of the product. buy_price (float): Buying price of the product. product (Product): Product managed by the node. suppliers (list): List of supplier links connected to this node. ongoing_order (bool): Indicates if an order is currently in process. selection_policy (SupplierSelectionPolicy): Supplier selection policy object. stats (Statistics): Statistics tracking object for this node. Returns: None Behavior: The inventory node stocks the product in inventory to make it available to the consumer node or demand node (end customer). It orders product from its supplier node to maintain the right inventory levels according to the replenishment policy. The inventory node can have multiple suppliers. It chooses a supplier based on the specified supplier selection policy. The product buy and sell prices are set during initialization. The inventory node is expected to sell the product at a higher price than the buy price, but this is user-configured. \"\"\" super().__init__(env=env,ID=ID,name=name,node_type=node_type,**kwargs) validate_non_negative(\"Product Sell Price\", product_sell_price) validate_non_negative(\"Product Buy Price\", product_buy_price) self._info_keys.extend([\"sell_price\", \"buy_price\", \"ongoing_order\", \"selection_policy\"]) self.replenishment_policy = None if(replenishment_policy): self.replenishment_policy = replenishment_policy(env = self.env, node = self, params = policy_param) self.env.process(self.replenishment_policy.run()) self.inventory = Inventory(env=self.env, capacity=capacity, initial_level=initial_level, node=self, inv_type=inventory_type, holding_cost=inventory_holding_cost, replenishment_policy=self.replenishment_policy, shelf_life=shelf_life) self.inventory_drop = self.env.event() # event to signal when inventory is dropped self.inventory_raised = self.env.event() # signal to indicate that inventory has been raised self.manufacture_date = manufacture_date self.sell_price = product_sell_price # set the sell price of the product self.buy_price = product_buy_price # set the buy price of the product if product is not None: self.product = copy.deepcopy(product) # product that the inventory node sells self.product.sell_price = product_sell_price self.product.buy_price = product_buy_price # set the buy price of the product to the product buy price self.suppliers = [] self.ongoing_order = False # flag to check if the order is placed self.selection_policy = supplier_selection_policy(self,supplier_selection_mode) self.stats = Statistics(self, periodic_update=True, period=1) # create a statistics object for the inventory node process_order process_order(supplier, reorder_quantity) Place an order for the product from the suppliers. Parameters: supplier ( Link ) \u2013 The supplier link from which the order is placed. reorder_quantity ( float ) \u2013 The quantity of the product to reorder. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def process_order(self, supplier, reorder_quantity): \"\"\" Place an order for the product from the suppliers. Parameters: supplier (Link): The supplier link from which the order is placed. reorder_quantity (float): The quantity of the product to reorder. Attributes: None Returns: None \"\"\" if(self.inventory.on_hand + reorder_quantity > self.inventory.inventory.capacity): # check if the inventory can accommodate the reordered quantity reorder_quantity = self.inventory.inventory.capacity - self.inventory.on_hand # if not, adjust reorder quantity to order only what can fit if reorder_quantity <= 0: self.ongoing_order = False return # no need to place an order if reorder quantity is zero if supplier.source.inventory.inventory.level < reorder_quantity: # check if the supplier is able to fulfill the order, record shortage shortage = reorder_quantity - supplier.source.inventory.inventory.level supplier.source.stats.update_stats(orders_shortage=[1,shortage], backorder=[1,reorder_quantity]) if(not supplier.source.inventory_drop.triggered): supplier.source.inventory_drop.succeed() # signal that inventory has been dropped (since backorder is created) if(supplier.source.node_status == \"active\"): self.stats.update_stats(demand_placed=[1,reorder_quantity],transportation_cost=supplier.cost) supplier.source.stats.update_stats(demand_received=[1,reorder_quantity]) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Replenishing inventory from supplier:{supplier.source.name}, order placed for {reorder_quantity} units.\") event, man_date_ls = supplier.source.inventory.get(reorder_quantity) self.inventory.on_hand += reorder_quantity yield event self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:shipment in transit from supplier:{supplier.source.name}.\") # log the shipment lead_time = supplier.lead_time() # get the lead time from the supplier validate_non_negative(name=\"lead_time\", value=lead_time) # check if lead_time is non-negative yield self.env.timeout(lead_time) # lead time for the order if(man_date_ls): for ele in man_date_ls: # get manufacturing date from the supplier self.inventory.put(ele[1],ele[0]) elif(self.inventory.inv_type==\"perishable\"): # if self inventory is perishable but manufacture date is not provided if(self.manufacture_date): # calculate the manufacturing date using the function if provided self.inventory.put(reorder_quantity,self.manufacture_date(self.env.now)) else: # else put the product in the inventory with current time as manufacturing date self.inventory.put(reorder_quantity,self.env.now) else: self.inventory.put(reorder_quantity) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Inventory replenished. reorder_quantity={reorder_quantity}, Inventory levels:{self.inventory.inventory.level}\") self.stats.update_stats(fulfillment_received=[1,reorder_quantity],inventory_spend_cost=reorder_quantity*self.buy_price) supplier.source.stats.update_stats(demand_fulfilled=[1,reorder_quantity]) else: self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Supplier:{supplier.source.name} is disrupted. Order not placed.\") self.ongoing_order = False Manufacturer Manufacturer(env: Environment, ID: str, name: str, capacity: float, initial_level: float, inventory_holding_cost: float, product_sell_price: float, replenishment_policy: InventoryReplenishment, policy_param: dict, product: Product = None, inventory_type: str = 'non-perishable', shelf_life: float = 0.0, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = 'fixed', **kwargs) Bases: Node The Manufacturer class models a production unit in the supply network that consumes raw materials to manufacture finished products. It maintains separate inventories for raw materials and finished goods, applies replenishment policies to the product inventory, and places orders to suppliers dynamically. The manufacturer can be connected to multiple suppliers and automatically produces products based on raw material availability. It continuously updates real-time statistics such as production volume, manufacturing cost, and revenue. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the manufacturer. name ( str ) \u2013 Name of the manufacturer. capacity ( float ) \u2013 Maximum capacity of the finished product inventory. initial_level ( float ) \u2013 Initial inventory level for finished products. inventory_holding_cost ( float ) \u2013 Holding cost per unit for finished products. product_sell_price ( float ) \u2013 Selling price per unit of the finished product. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product ( Product , default: None ) \u2013 Product manufactured by the manufacturer. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Supplier selection mode (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. inventory ( Inventory ) \u2013 Inventory object managing finished product stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. product ( Product ) \u2013 Product manufactured by the manufacturer. suppliers ( list ) \u2013 List of supplier links connected to this manufacturer. sell_price ( float ) \u2013 Selling price per unit of the product. production_cycle ( bool ) \u2013 Indicates whether the production cycle is currently active. raw_inventory_counts ( dict ) \u2013 Inventory levels of raw materials by raw material ID. ongoing_order_raw ( dict ) \u2013 Indicates whether a raw material order is currently in progress. ongoing_order ( bool ) \u2013 Indicates whether a product order is currently in progress. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for the manufacturer. Methods: Name Description manufacture_product Manufactures the product by consuming raw materials and updating product inventory. behavior Main behavior loop that checks inventory and triggers production if raw materials are available. process_order Places an order for raw materials based on the quantity of products to be manufactured. process_order_raw Places an individual order for a specific raw material from a supplier. Behavior The manufacturer continuously monitors raw material inventory levels and initiates production when raw materials are available. Finished products are added to the inventory upon completion of a manufacturing cycle. If raw materials are insufficient, the manufacturer places replenishment orders with connected suppliers. Assumptions The manufacturer produces only a single type of product. Separate inventories are maintained for raw materials and finished products. Only the finished product inventory is actively monitored by the replenishment policy. Raw material inventories are replenished based on product inventory requirements. The raw material inventory is initially empty. Initialize the manufacturer object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the manufacturer. name ( str ) \u2013 Name of the manufacturer. capacity ( float ) \u2013 Maximum capacity of the finished product inventory. initial_level ( float ) \u2013 Initial inventory level for finished products. inventory_holding_cost ( float ) \u2013 Holding cost per unit for finished products. product_sell_price ( float ) \u2013 Selling price per unit of the finished product. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product ( Product , default: None ) \u2013 Product manufactured by the manufacturer. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Supplier selection mode (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. inventory ( Inventory ) \u2013 Inventory object managing finished product stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. product ( Product ) \u2013 Product manufactured by the manufacturer. suppliers ( list ) \u2013 List of supplier links connected to this manufacturer. sell_price ( float ) \u2013 Selling price per unit of the product. production_cycle ( bool ) \u2013 Indicates whether the production cycle is currently active. raw_inventory_counts ( dict ) \u2013 Inventory levels of raw materials by raw material ID. ongoing_order_raw ( dict ) \u2013 Indicates whether a raw material order is currently in progress. ongoing_order ( bool ) \u2013 Indicates whether a product order is currently in progress. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for the manufacturer. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, capacity: float, initial_level: float, inventory_holding_cost: float, product_sell_price: float, replenishment_policy: InventoryReplenishment, policy_param: dict, product: Product = None, inventory_type: str = \"non-perishable\", shelf_life: float = 0.0, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = \"fixed\", **kwargs) -> None: \"\"\" Initialize the manufacturer object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique identifier for the manufacturer. name (str): Name of the manufacturer. capacity (float): Maximum capacity of the finished product inventory. initial_level (float): Initial inventory level for finished products. inventory_holding_cost (float): Holding cost per unit for finished products. product_sell_price (float): Selling price per unit of the finished product. replenishment_policy (InventoryReplenishment): Replenishment policy object for the product inventory. policy_param (dict): Parameters for the replenishment policy. product (Product): Product manufactured by the manufacturer. inventory_type (str): Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life (float): Shelf life of the product. supplier_selection_policy (SupplierSelectionPolicy): Supplier selection policy class. supplier_selection_mode (str): Supplier selection mode (default is \"fixed\"). **kwargs: Additional keyword arguments for the Node class and logger. Attributes: _info_keys (list): List of keys to include in the info dictionary. replenishment_policy (InventoryReplenishment): Replenishment policy object for the product inventory. inventory (Inventory): Inventory object managing finished product stock. inventory_drop (simpy.Event): Event triggered when inventory drops. inventory_raised (simpy.Event): Event triggered when inventory is replenished. product (Product): Product manufactured by the manufacturer. suppliers (list): List of supplier links connected to this manufacturer. sell_price (float): Selling price per unit of the product. production_cycle (bool): Indicates whether the production cycle is currently active. raw_inventory_counts (dict): Inventory levels of raw materials by raw material ID. ongoing_order_raw (dict): Indicates whether a raw material order is currently in progress. ongoing_order (bool): Indicates whether a product order is currently in progress. selection_policy (SupplierSelectionPolicy): Supplier selection policy object. stats (Statistics): Statistics tracking object for the manufacturer. Returns: None \"\"\" super().__init__(env=env,ID=ID,name=name,node_type=\"manufacturer\",**kwargs) if product == None: global_logger.logger.error(\"Product not provided for the manufacturer.\") raise ValueError(\"Product not provided for the manufacturer.\") elif not isinstance(product, Product): raise ValueError(\"Invalid product type. Expected a Product instance.\") validate_positive(\"Product Sell Price\", product_sell_price) self._info_keys.extend([\"replenishment_policy\", \"product_sell_price\"]) self.replenishment_policy = None if(replenishment_policy): self.replenishment_policy = replenishment_policy(env = self.env, node = self, params = policy_param) self.env.process(self.replenishment_policy.run()) self.inventory = Inventory(env=self.env, capacity=capacity, initial_level=initial_level, node=self, inv_type=inventory_type, holding_cost=inventory_holding_cost, replenishment_policy=self.replenishment_policy, shelf_life=shelf_life) self.inventory_drop = self.env.event() # event to signal when inventory is dropped self.inventory_raised = self.env.event() # signal to indicate that inventory has been raised self.product = product # product manufactured by the manufacturer self.suppliers = [] self.product.sell_price = product_sell_price self.sell_price = product_sell_price # set the sell price of the product self.production_cycle = False # production cycle status self.raw_inventory_counts = {} # dictionary to store inventory counts for raw products inventory self.ongoing_order_raw = {} # dictionary to store order status self.ongoing_order = False # order status for the product if(self.product.buy_price <= 0): # if the product buy price is not given, calculate it self.product.buy_price = self.product.manufacturing_cost for raw_material in self.product.raw_materials: self.product.buy_price += raw_material[0].cost * raw_material[1] # calculate total cost of the product (per unit) self.env.process(self.behavior()) # start the behavior process self.selection_policy = supplier_selection_policy(self,supplier_selection_mode) self.stats = Statistics(self, periodic_update=True, period=1) # create a statistics object for the manufacturer setattr(self.stats,\"total_products_manufactured\",0) # adding specific statistics for the manufacturer setattr(self.stats,\"total_manufacturing_cost\",0) # adding specific statistics for the manufacturer self.stats._stats_keys.extend([\"total_products_manufactured\", \"total_manufacturing_cost\"]) manufacture_product manufacture_product() Manufacture the product. This method handles the production of the product, consuming raw materials and adding the manufactured product to the inventory. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def manufacture_product(self): \"\"\" Manufacture the product. This method handles the production of the product, consuming raw materials and adding the manufactured product to the inventory. Parameters: None Attributes: None Returns: None \"\"\" max_producible_units = self.product.batch_size for raw_material in self.product.raw_materials: raw_mat_id = raw_material[0].ID required_amount = raw_material[1] current_raw_material_level = self.raw_inventory_counts[raw_mat_id] max_producible_units = min(max_producible_units,int(current_raw_material_level/required_amount)) if((self.inventory.inventory.level + max_producible_units)>self.inventory.inventory.capacity): # check if the inventory can accommodate the maximum producible units max_producible_units = self.inventory.inventory.capacity - self.inventory.inventory.level if(max_producible_units>0): self.inventory.on_hand += max_producible_units # update the on-hand inventory level self.production_cycle = True # produce the product for raw_material in self.product.raw_materials: # consume raw materials raw_mat_id = raw_material[0].ID required_amount = raw_material[1] self.raw_inventory_counts[raw_mat_id] -= raw_material[1]*max_producible_units yield self.env.timeout(self.product.manufacturing_time) # take manufacturing time to produce the product self.inventory.put(max_producible_units, manufacturing_date=self.env.now) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}: {max_producible_units} units manufactured.\") self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}: Product inventory levels:{self.inventory.inventory.level}\") self.stats.update_stats(total_products_manufactured=max_producible_units, total_manufacturing_cost=max_producible_units*self.product.manufacturing_cost) # update statistics self.production_cycle = False behavior behavior() The manufacturer consumes raw materials and produces the product if raw materials are available. It maintains inventory levels for both raw materials and the product. Depending on the replenishment policy for product inventory, manufacturer decides when to replenish the raw material inventory. The manufacturer can be connected to multiple suppliers. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def behavior(self): \"\"\" The manufacturer consumes raw materials and produces the product if raw materials are available. It maintains inventory levels for both raw materials and the product. Depending on the replenishment policy for product inventory, manufacturer decides when to replenish the raw material inventory. The manufacturer can be connected to multiple suppliers. Parameters: None Attributes: None Returns: None \"\"\" if(len(self.suppliers)==0): self.logger.logger.error(\"No suppliers connected to the manufacturer.\") raise ValueError(\"No suppliers connected to the manufacturer.\") if(len(self.suppliers)>0): # create an inventory for storing raw materials as a dictionary. Key: raw material ID, Value: inventory level for supplier in self.suppliers: # iterate over supplier links if(supplier.source.raw_material is None): # check if the supplier has a raw material self.logger.logger.error(f\"{self.ID}:Supplier {supplier.source.ID} does not have a raw material. Please provide a raw material for the supplier.\") raise ValueError(f\"Supplier {supplier.source.ID} does not have a raw material.\") self.raw_inventory_counts[supplier.source.raw_material.ID] = 0 # store initial levels self.ongoing_order_raw[supplier.source.raw_material.ID] = False # store order status if(len(self.suppliers)<len(self.product.raw_materials)): self.logger.logger.warning(f\"{self.ID}: {self.name}: The number of suppliers are less than the number of raw materials required to manufacture the product! This leads to no products being manufactured.\") while True: # behavior of the manufacturer: consume raw materials, produce the product, and put the product in the inventory if(len(self.suppliers)>=len(self.product.raw_materials)): # check if required number of suppliers are connected if(not self.production_cycle): self.env.process(self.manufacture_product()) # produce the product yield self.env.timeout(1) process_order_raw process_order_raw(raw_mat_id, supplier, reorder_quantity) Place an order for given raw material from the given supplier for replenishment. Parameters: supplier ( Link ) \u2013 The supplier link from which the order is placed. reorder_quantity ( float ) \u2013 The quantity of the raw material to reorder. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def process_order_raw(self, raw_mat_id, supplier, reorder_quantity): \"\"\" Place an order for given raw material from the given supplier for replenishment. Parameters: supplier (Link): The supplier link from which the order is placed. reorder_quantity (float): The quantity of the raw material to reorder. Attributes: None Returns: None \"\"\" if supplier.source.inventory.inventory.level < reorder_quantity: # check if the supplier is able to fulfill the order, record shortage shortage = reorder_quantity - supplier.source.inventory.inventory.level supplier.source.stats.update_stats(orders_shortage=[1,shortage], backorder=[1,reorder_quantity]) if(supplier.source.node_status == \"active\"): # check if the supplier is active and has enough inventory if(self.raw_inventory_counts[raw_mat_id]>= reorder_quantity): # dont order if enough inventory is available (reorder_quantity depends on the number of product units that needs to be manufactured, there is no capcacity defined for raw material inventory) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Sufficient raw material inventory for {supplier.source.raw_material.name}, no order placed. Current inventory level: {self.raw_inventory_counts}.\") self.ongoing_order_raw[raw_mat_id] = False self.ongoing_order = False # set the order status to False return self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Replenishing raw material:{supplier.source.raw_material.name} from supplier:{supplier.source.ID}, order placed for {reorder_quantity} units. Current inventory level: {self.raw_inventory_counts}.\") event, man_date_ls = supplier.source.inventory.get(reorder_quantity) supplier.source.stats.update_stats(demand_received=[1,reorder_quantity]) # update the supplier statistics for demand received yield event self.stats.update_stats(demand_placed=[1,reorder_quantity],transportation_cost=supplier.cost) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:shipment in transit from supplier:{supplier.source.name}.\") lead_time = supplier.lead_time() # get the lead time from the supplier validate_non_negative(name=\"lead_time\", value=lead_time) # check if lead_time is non-negative yield self.env.timeout(lead_time) # lead time for the order self.stats.update_stats(fulfillment_received=[1,reorder_quantity],inventory_spend_cost=reorder_quantity*supplier.source.sell_price) supplier.source.stats.update_stats(demand_fulfilled=[1,reorder_quantity]) # update the supplier statistics for demand fulfilled self.ongoing_order_raw[raw_mat_id] = False self.raw_inventory_counts[raw_mat_id] += reorder_quantity self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Order received from supplier:{supplier.source.name}, inventory levels: {self.raw_inventory_counts}\") self.ongoing_order = False # set the order status to False else: self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Supplier:{supplier.source.name} is disrupted.\") yield self.env.timeout(1) # wait for 1 time unit before checking again self.ongoing_order_raw[raw_mat_id] = False process_order process_order(supplier, reorder_quantity) Place an order for raw materials and replenish raw materials inventory. Parameters: supplier ( Link ) \u2013 Supplier link reorder_quantity ( float ) \u2013 The quantity of the raw material to reorder. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def process_order(self, supplier, reorder_quantity): \"\"\" Place an order for raw materials and replenish raw materials inventory. Parameters: supplier (Link): Supplier link reorder_quantity (float): The quantity of the raw material to reorder. Attributes: None Returns: None \"\"\" self.ongoing_order = True # set the order status to True if(self.inventory.on_hand + reorder_quantity > self.inventory.inventory.capacity): # check if the inventory can accommodate the reordered quantity reorder_quantity = self.inventory.inventory.capacity - self.inventory.on_hand # if not, adjust reorder quantity to order only what can fit if reorder_quantity <= 0: self.ongoing_order = False return # no need to place an order if reorder quantity is zero for raw_mat in self.product.raw_materials: # place order for all raw materials required to produce the product raw_mat_id = raw_mat[0].ID raw_mat_reorder_sz = raw_mat[1]*reorder_quantity for supplier in self.suppliers: if(supplier.source.raw_material.ID == raw_mat_id and self.ongoing_order_raw[raw_mat_id] == False): # check if the supplier has the raw material and order is not already placed self.ongoing_order_raw[raw_mat_id] = True # set the order status to True self.env.process(self.process_order_raw(raw_mat_id, supplier, raw_mat_reorder_sz)) # place the order for the raw material yield self.env.timeout(1) # wait for the order to be placed Demand Demand(env: Environment, ID: str, name: str, order_arrival_model: callable, order_quantity_model: callable, demand_node: Node, tolerance: float = 0.0, order_min_split_ratio: float = 1.0, delivery_cost: callable = lambda: 0, lead_time: callable = lambda: 0, consume_available: bool = False, **kwargs) Bases: Node The Demand class represents a demand node that generates product orders within the supply network. It models dynamic demand patterns using user-defined functions for order arrival times and order quantities, and manages customer tolerance for waiting in case of product unavailability. The demand node automatically places customer orders at configurable intervals and can handle situations where the requested quantity is not immediately available. Customers can either wait (if tolerance is set) or leave the system unfulfilled. The class supports: Customizable lead time and delivery cost per order, Dynamic order splitting based on the minimum split ratio, Backorder management and real-time inventory check. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the demand node. name ( str ) \u2013 Name of the demand node. order_arrival_model ( callable ) \u2013 Function that models inter-arrival times between customer orders. order_quantity_model ( callable ) \u2013 Function that models the quantity per customer order. demand_node ( Node ) \u2013 Upstream node from which the demand node sources products. tolerance ( float , default: 0.0 ) \u2013 Maximum time customers are willing to wait if required quantity is unavailable. order_min_split_ratio ( float , default: 1.0 ) \u2013 Minimum allowable fraction of the order that can be delivered in split deliveries. delivery_cost ( callable , default: lambda: 0 ) \u2013 Function that models the delivery cost per order. lead_time ( callable , default: lambda: 0 ) \u2013 Function that models the delivery lead time per order. consume_available ( bool , default: False ) \u2013 If True, the demand node consumes available inventory immediately and leaves. **kwargs \u2013 Additional keyword arguments for Node and GlobalLogger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. order_arrival_model ( callable ) \u2013 Function defining the order arrival process. order_quantity_model ( callable ) \u2013 Function defining the order quantity distribution. demand_node ( Node ) \u2013 Upstream node supplying the demand. customer_tolerance ( float ) \u2013 Maximum waiting time allowed for customer orders. delivery_cost ( callable ) \u2013 Delivery cost function for each order. lead_time ( callable ) \u2013 Delivery lead time function for each order. min_split ( float ) \u2013 Minimum allowed split ratio for partially fulfilled orders. consume_available ( bool ) \u2013 If True, partial fulfillment is allowed and available inventory is consumed immediately. stats ( Statistics ) \u2013 Tracks various performance metrics like demand placed, fulfilled, and shortages. Methods: Name Description _process_delivery Handles the delivery process, including lead time and delivery cost updates. wait_for_order Waits for required units based on customer tolerance when immediate fulfillment is not possible. customer Simulates customer order placement and fulfillment behavior. behavior Generates continuous customer demand based on the arrival and quantity models. Behavior The demand node generates customer orders at random intervals and quantities using the specified arrival and quantity models. If the upstream inventory can satisfy the order, delivery is processed immediately. If not, the customer may leave immediately (if tolerance is zero) else, the customer waits for the order to be fulfilled within their tolerance time, possibly accepting partial deliveries if a split ratio is allowed. If the tolerance is exceeded, the unmet demand is recorded as a shortage. Assumptions Customer orders arrive following the provided stochastic arrival model. Order quantities follow the specified stochastic quantity model. Customers may wait for the fulfillment of their orders up to the defined tolerance time. Customers can accept split deliveries based on the minimum split ratio. If customer tolerance is zero, customer returns without waiting for fulfillment. Delivery cost and lead time are sampled dynamically for each order (if specified). The connected upstream node must not be a supplier; it should typically be a retailer or distributor node. Initialize the demand node object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the demand node. name ( str ) \u2013 Name of the demand node. order_arrival_model ( callable ) \u2013 Function that models inter-arrival times between customer orders. order_quantity_model ( callable ) \u2013 Function that models the quantity per customer order. demand_node ( Node ) \u2013 Upstream node from which the demand node sources products. tolerance ( float , default: 0.0 ) \u2013 Maximum time customers are willing to wait if required quantity is unavailable. order_min_split_ratio ( float , default: 1.0 ) \u2013 Minimum allowable fraction of the order that can be delivered in split deliveries. delivery_cost ( callable , default: lambda: 0 ) \u2013 Function that models the delivery cost per order. lead_time ( callable , default: lambda: 0 ) \u2013 Function that models the delivery lead time per order. consume_available ( bool , default: False ) \u2013 If True, the demand node consumes available inventory immediately and leaves. **kwargs \u2013 Additional keyword arguments for Node and GlobalLogger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. order_arrival_model ( callable ) \u2013 Function defining the order arrival process. order_quantity_model ( callable ) \u2013 Function defining the order quantity distribution. demand_node ( Node ) \u2013 Upstream node supplying the demand. customer_tolerance ( float ) \u2013 Maximum waiting time allowed for customer orders. delivery_cost ( callable ) \u2013 Delivery cost function for each order. lead_time ( callable ) \u2013 Delivery lead time function for each order. min_split ( float ) \u2013 Minimum allowed split ratio for partially fulfilled orders. consume_available ( bool ) \u2013 If True, partial fulfillment is allowed and available inventory is consumed immediately. stats ( Statistics ) \u2013 Tracks various performance metrics like demand placed, fulfilled, and shortages. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, order_arrival_model: callable, order_quantity_model: callable, demand_node: Node, tolerance: float = 0.0, order_min_split_ratio: float = 1.0, delivery_cost: callable = lambda: 0, lead_time: callable = lambda: 0, consume_available: bool = False, **kwargs) -> None: \"\"\" Initialize the demand node object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique identifier for the demand node. name (str): Name of the demand node. order_arrival_model (callable): Function that models inter-arrival times between customer orders. order_quantity_model (callable): Function that models the quantity per customer order. demand_node (Node): Upstream node from which the demand node sources products. tolerance (float): Maximum time customers are willing to wait if required quantity is unavailable. order_min_split_ratio (float): Minimum allowable fraction of the order that can be delivered in split deliveries. delivery_cost (callable): Function that models the delivery cost per order. lead_time (callable): Function that models the delivery lead time per order. consume_available (bool): If True, the demand node consumes available inventory immediately and leaves. **kwargs: Additional keyword arguments for Node and GlobalLogger. Attributes: _info_keys (list): List of keys to include in the info dictionary. order_arrival_model (callable): Function defining the order arrival process. order_quantity_model (callable): Function defining the order quantity distribution. demand_node (Node): Upstream node supplying the demand. customer_tolerance (float): Maximum waiting time allowed for customer orders. delivery_cost (callable): Delivery cost function for each order. lead_time (callable): Delivery lead time function for each order. min_split (float): Minimum allowed split ratio for partially fulfilled orders. consume_available (bool): If True, partial fulfillment is allowed and available inventory is consumed immediately. stats (Statistics): Tracks various performance metrics like demand placed, fulfilled, and shortages. Returns: None \"\"\" if order_arrival_model is None or order_quantity_model is None: raise ValueError(\"Order arrival and quantity models cannot be None.\") if not callable(order_arrival_model): order_arrival_model = lambda val=order_arrival_model: val # convert into callable if not callable(order_quantity_model): order_quantity_model = lambda val=order_quantity_model: val # convert into callable if not callable(delivery_cost): delivery_cost = lambda val=delivery_cost: val # convert into callable if not callable(lead_time): lead_time = lambda val=lead_time: val # convert into callable if demand_node is None or \"supplier\" in demand_node.node_type: raise ValueError(\"Demand node must be a valid non-supplier node.\") validate_non_negative(\"Customer tolerance\", tolerance) validate_positive(\"Order Min Split Ratio\", order_min_split_ratio) if order_min_split_ratio > 1: self.logger.logger.error(\"Order Min Split Ratio is greater than 1. It will be set to 1.\") raise ValueError(\"Order Min Split Ratio must be in the range [0, 1].\") validate_number(name=\"order_time\", value=order_arrival_model()) validate_number(name=\"order_quantity\", value=order_quantity_model()) validate_number(name=\"delivery_cost\", value=delivery_cost()) # check if delivery_cost is a number validate_number(name=\"lead_time\", value=lead_time()) # check if lead_time is a number super().__init__(env=env,ID=ID,name=name,node_type=\"demand\",**kwargs) self._info_keys.extend([\"order_arrival_model\", \"order_quantity_model\", \"demand_node\", \"customer_tolerance\", \"delivery_cost\", \"lead_time\"]) self.order_arrival_model = order_arrival_model self.order_quantity_model = order_quantity_model self.demand_node = demand_node self.customer_tolerance = tolerance self.delivery_cost = delivery_cost self.lead_time = lead_time self.min_split = order_min_split_ratio self.consume_available = consume_available # if True, the demand node consumes available inventory immediately and leaves self.env.process(self.behavior()) self.stats = Statistics(self, periodic_update=True, period=1) # create a statistics object for the demand node wait_for_order wait_for_order(customer_id, order_quantity) Wait for the required number of units based on customer tolerance. If the customer tolerance is infinite, the method waits until the order is fulfilled. Otherwise, it waits for the specified tolerance time and updates the unsatisfied demand if the order is not fulfilled. Parameters: order_quantity ( float ) \u2013 The quantity of the product ordered. customer_id ( int ) \u2013 Customer ID for logging purposes. Attributes: customer_id ( int ) \u2013 Customer ID for logging purposes. order_quantity ( float ) \u2013 The quantity of the product ordered. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def wait_for_order(self,customer_id,order_quantity): \"\"\" Wait for the required number of units based on customer tolerance. If the customer tolerance is infinite, the method waits until the order is fulfilled. Otherwise, it waits for the specified tolerance time and updates the unsatisfied demand if the order is not fulfilled. Parameters: order_quantity (float): The quantity of the product ordered. customer_id (int): Customer ID for logging purposes. Attributes: customer_id (int): Customer ID for logging purposes. order_quantity (float): The quantity of the product ordered. Returns: None \"\"\" self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}:Order quantity:{order_quantity} not available! Order will be split if split ratio is provided.\") self.demand_node.stats.update_stats(backorder=[1,order_quantity]) if(not self.demand_node.inventory_drop.triggered): self.demand_node.inventory_drop.succeed() # signal that inventory has been dropped (since backorder is created) partial = order_quantity if self.min_split < 1: partial = int(order_quantity * self.min_split) waited = 0 available = 0 while order_quantity>0 and waited<=self.customer_tolerance: waiting_time = self.env.now available = self.demand_node.inventory.inventory.level if order_quantity <= available: # check if remaining order quantity is available self.env.process(self._process_delivery(order_quantity, customer_id)) self.demand_node.stats.update_stats(backorder=[-1,-order_quantity]) order_quantity = 0 break elif available >= partial: # or else at least min required 'partial' is available self.env.process(self._process_delivery(available, customer_id)) self.demand_node.stats.update_stats(backorder=[0,-available]) self.stats.update_stats(fulfillment_received=[-1,0]) order_quantity -= available # update order quantity else: self.demand_node.stats.update_stats(orders_shortage=[1,order_quantity-available]) yield self.demand_node.inventory_raised # wait until inventory is replenished self.demand_node.inventory_raised = self.env.event() # reset the event for the next iteration waited += self.env.now - waiting_time # update the waited time if order_quantity > 0: # if the order quantity is still greater than 0, it means the order was not fulfilled self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}: remaining order quantity:{order_quantity} not available!\") customer customer(customer_id, order_quantity) Simulate the customer behavior, ordering products from demand node, consume and return. Parameters: customer_id ( int ) \u2013 Customer ID for logging purposes. order_quantity ( float ) \u2013 The quantity of the product ordered. Attributes: customer_id ( int ) \u2013 Customer ID for logging purposes. order_quantity ( float ) \u2013 The quantity of the product ordered. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def customer(self,customer_id,order_quantity): \"\"\" Simulate the customer behavior, ordering products from demand node, consume and return. Parameters: customer_id (int): Customer ID for logging purposes. order_quantity (float): The quantity of the product ordered. Attributes: customer_id (int): Customer ID for logging purposes. order_quantity (float): The quantity of the product ordered. Returns: None \"\"\" available = self.demand_node.inventory.inventory.level self.stats.update_stats(demand_placed=[1,order_quantity]) # update the demand placed statistics if order_quantity <= available: self.demand_node.stats.update_stats(demand_received=[1,order_quantity]) yield from self._process_delivery(order_quantity, customer_id) elif self.consume_available and available > 0: # consume available inventory if order quantity is not available (backorder policy = allowed partial) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}: Order quantity:{order_quantity} not available, inventory level:{available}. Consuming available inventory.\") self.demand_node.stats.update_stats(demand_received=[1,available],orders_shortage=[1,order_quantity-available]) yield from self._process_delivery(available, customer_id) elif self.customer_tolerance > 0: # wait for tolerance time if order quantity is not available (backorder policy = allowed total) self.demand_node.stats.update_stats(demand_received=[1,order_quantity],orders_shortage=[1,order_quantity-available]) # update the orders shortage statistics self.env.process(self.wait_for_order(customer_id, order_quantity)) else: # No tolerance, leave without placing an order (backorder policy = not allowed) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}: Order quantity:{order_quantity} not available, inventory level:{self.demand_node.inventory.inventory.level}. No tolerance! Shortage:{order_quantity-available}.\") self.demand_node.stats.update_stats(orders_shortage=[1,order_quantity-available]) # update the orders shortage statistics behavior behavior() Generate demand by calling the order arrival and order quantity models. This method simulates the demand generation process, including order placement and handling shortages or unsatisfied demand. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def behavior(self): \"\"\" Generate demand by calling the order arrival and order quantity models. This method simulates the demand generation process, including order placement and handling shortages or unsatisfied demand. Parameters: None Attributes: None Returns: None \"\"\" customer_id = 1 # customer ID while True: order_time = self.order_arrival_model() order_quantity = self.order_quantity_model() validate_non_negative(name=f\"{self.ID}:order_arrival_model()\", value=order_time) validate_positive(name=f\"{self.ID}:order_quantity_model()\", value=order_quantity) self.env.process(self.customer(f\"{customer_id}\", order_quantity)) # create a customer customer_id += 1 # increment customer ID yield self.env.timeout(order_time) # wait for the next order arrival validate_positive validate_positive(name: str, value) Check if the value is positive and raise ValueError if not. Parameters: name ( str ) \u2013 name of the variable value \u2013 value to check Raises: ValueError \u2013 if value is not positive Source code in src/SupplyNetPy/Components/core.py def validate_positive(name: str, value): \"\"\" Check if the value is positive and raise ValueError if not. Parameters: name (str): name of the variable value: value to check Raises: ValueError: if value is not positive \"\"\" if value <= 0: global_logger.logger.error(f\"{name} must be positive.\") raise ValueError(f\"{name} must be positive.\") validate_non_negative validate_non_negative(name: str, value) Check if the value is non-negative and raise ValueError if not. Parameters: name ( str ) \u2013 name of the variable value \u2013 value to check Raises: ValueError \u2013 if value is negative Source code in src/SupplyNetPy/Components/core.py def validate_non_negative(name: str, value): \"\"\" Check if the value is non-negative and raise ValueError if not. Parameters: name (str): name of the variable value: value to check Raises: ValueError: if value is negative \"\"\" if value < 0: global_logger.logger.error(f\"{name} cannot be negative.\") raise ValueError(f\"{name} cannot be negative.\") validate_number validate_number(name: str, value) -> None Check if the value is a number and raise ValueError if not. Parameters: name ( str ) \u2013 name of the variable value \u2013 value to check Raises: ValueError \u2013 if value is not a number Source code in src/SupplyNetPy/Components/core.py def validate_number(name: str, value) -> None: \"\"\" Check if the value is a number and raise ValueError if not. Parameters: name (str): name of the variable value: value to check Raises: ValueError: if value is not a number \"\"\" if not isinstance(value, numbers.Number): global_logger.logger.error(f\"function {name}() must return a number (an int or a float).\") raise ValueError(f\"function {name}() must be a number (an int or a float).\")","title":"Core Components"},{"location":"api-reference/api-ref-core/#supplynetpy-componentscore-module","text":"The Components.core module provides the foundational building blocks for modeling and simulating supply chain networks in SupplyNetPy. It defines key classes representing entities and their interactions within a supply chain.","title":"SupplyNetPy Components.core Module"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core","text":"","title":"core"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.NamedEntity","text":"The NamedEntity class provides a standardized way to display names of the objects in the supply chain model. When printed or displayed, the object will show its name (if defined), otherwise its ID , or the class name as a fallback. This improves the readability and interpretability of simulation outputs by ensuring objects are easily identifiable. Methods: Name Description __str__ returns the name of the object if available, otherwise returns the class name __repr__ returns the name of the object if available, otherwise returns the class name","title":"NamedEntity"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.NamedEntity.__str__","text":"__str__() -> str Returns the name of the object if available, otherwise returns the class name. Source code in src/SupplyNetPy/Components/core.py def __str__(self) -> str: \"\"\"Returns the name of the object if available, otherwise returns the class name.\"\"\" return getattr(self, 'name', getattr(self, 'ID', self.__class__.__name__))","title":"__str__"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.NamedEntity.__repr__","text":"__repr__() -> str Returns the name of the object if available, otherwise returns the class name. Source code in src/SupplyNetPy/Components/core.py def __repr__(self) -> str: \"\"\"Returns the name of the object if available, otherwise returns the class name.\"\"\" return getattr(self, 'name', getattr(self, 'ID', self.__class__.__name__))","title":"__repr__"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InfoMixin","text":"The InfoMixin class allows objects to easily provide their key details and statistics as dictionaries. This helps in quickly summarizing, logging, or analyzing object data in a structured and consistent way across the simulation. Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary _stats_keys ( list ) \u2013 list of keys to include in the statistics dictionary Methods: Name Description get_info returns a dictionary containing details of the object get_statistics returns a dictionary containing statistics of the object","title":"InfoMixin"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InfoMixin.get_info","text":"get_info() -> dict Returns a dictionary containing details of the object. Returns: dict ( dict ) \u2013 dictionary containing details of the object Source code in src/SupplyNetPy/Components/core.py def get_info(self) -> dict: \"\"\" Returns a dictionary containing details of the object. Parameters: None Attributes: None Returns: dict: dictionary containing details of the object \"\"\" if self._info_keys: return {key: getattr(self, key, None) for key in self._info_keys} return self.__dict__","title":"get_info"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InfoMixin.get_statistics","text":"get_statistics() -> dict Returns a dictionary containing statistics of the object. Returns: dict ( dict ) \u2013 dictionary containing statistics of the object Source code in src/SupplyNetPy/Components/core.py def get_statistics(self) -> dict: \"\"\" Returns a dictionary containing statistics of the object. Parameters: None Attributes: None Returns: dict: dictionary containing statistics of the object \"\"\" if self._stats_keys: return {key: getattr(self, key, None) for key in self._stats_keys} return self.__dict__","title":"get_statistics"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Statistics","text":"Statistics(node: object, periodic_update: bool = False, period: float = 1) Bases: InfoMixin The Statistics class tracks and summarizes key performance indicators for each node in the supply chain. It monitors essential metrics such as demand, inventory levels, shortages, backorders, costs, revenue, and profit. The class supports both automatic periodic updates and manual updates through the update_stats method, which can be called at any point in the simulation to immediately record changes. Parameters: node ( object ) \u2013 The node for which statistics are tracked. periodic_update ( bool , default: False ) \u2013 Whether to update statistics periodically. Default is False. period ( float , default: 1 ) \u2013 Time interval for periodic updates. Default is 1. Attributes: node ( object ) \u2013 The node to which this statistics object belongs. name ( str ) \u2013 Name of the statistics object. By default, it is the node's name post-fix \" statistics\". demand_placed ( list ) \u2013 Orders and quantities placed by this node. fulfillment_received ( list ) \u2013 Orders and quantities received by this node. demand_received ( list ) \u2013 Orders and quantities demanded at this node. demand_fulfilled ( list ) \u2013 Orders and quantities fulfilled by this node. orders_shortage ( list ) \u2013 Orders and quantities that faced shortage. backorder ( list ) \u2013 Backorders at this node. inventory_level ( float ) \u2013 Current inventory level. inventory_waste ( float ) \u2013 Inventory waste. inventory_carry_cost ( float ) \u2013 Inventory carrying cost. inventory_spend_cost ( float ) \u2013 Inventory replenishment cost. transportation_cost ( float ) \u2013 Transportation cost. node_cost ( float ) \u2013 Total cost at this node. revenue ( float ) \u2013 Revenue generated by this node. profit ( float ) \u2013 Profit generated by this node. _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. Methods: Name Description reset Resets all statistics to initial values. update_stats Updates statistics based on provided values. update_stats_periodically Periodically updates statistics during simulation. Initialize the statistics object. Parameters: node ( object ) \u2013 The node for which statistics are tracked. periodic_update ( bool , default: False ) \u2013 Whether to update statistics periodically. Default is False. period ( float , default: 1 ) \u2013 Time interval for periodic updates. Default is 1. Attributes: node ( object ) \u2013 The node to which this statistics object belongs. name ( str ) \u2013 Name of the statistics object. demand_placed ( list ) \u2013 Orders and quantities placed by this node. fulfillment_received ( list ) \u2013 Orders and quantities received by this node. demand_received ( list ) \u2013 Orders and quantities demanded at this node. demand_fulfilled ( list ) \u2013 Orders and quantities fulfilled by this node. orders_shortage ( list ) \u2013 Orders and quantities that faced shortage. backorder ( list ) \u2013 Backorders at this node. inventory_level ( float ) \u2013 Current inventory level. inventory_waste ( float ) \u2013 Inventory waste. inventory_carry_cost ( float ) \u2013 Inventory carrying cost. inventory_spend_cost ( float ) \u2013 Inventory replenishment cost. transportation_cost ( float ) \u2013 Transportation cost. node_cost ( float ) \u2013 Total cost at this node. revenue ( float ) \u2013 Revenue generated by this node. profit ( float ) \u2013 Profit generated by this node. _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node:object, periodic_update:bool=False, period:float=1): \"\"\" Initialize the statistics object. Parameters: node (object): The node for which statistics are tracked. periodic_update (bool, optional): Whether to update statistics periodically. Default is False. period (float, optional): Time interval for periodic updates. Default is 1. Attributes: node (object): The node to which this statistics object belongs. name (str): Name of the statistics object. demand_placed (list): Orders and quantities placed by this node. fulfillment_received (list): Orders and quantities received by this node. demand_received (list): Orders and quantities demanded at this node. demand_fulfilled (list): Orders and quantities fulfilled by this node. orders_shortage (list): Orders and quantities that faced shortage. backorder (list): Backorders at this node. inventory_level (float): Current inventory level. inventory_waste (float): Inventory waste. inventory_carry_cost (float): Inventory carrying cost. inventory_spend_cost (float): Inventory replenishment cost. transportation_cost (float): Transportation cost. node_cost (float): Total cost at this node. revenue (float): Revenue generated by this node. profit (float): Profit generated by this node. _info_keys (list): Keys to include in the info dictionary. _stats_keys (list): Keys to include in the statistics dictionary. Returns: None \"\"\" self._info_keys = [\"name\"] self._stats_keys = [\"demand_placed\", \"fulfillment_received\", \"demand_received\", \"demand_fulfilled\", \"orders_shortage\", \"backorder\", \"inventory_level\", \"inventory_waste\", \"inventory_carry_cost\", \"inventory_spend_cost\", \"transportation_cost\", \"node_cost\", \"revenue\", \"profit\"] self.node = node # the node to which this statistics object belongs self.name = f\"{self.node.ID} statistics\" self.demand_placed = [0,0] # demand placed by this node [total orders placed, total quantity] self.fulfillment_received = [0,0] # fulfillment received by this node self.demand_received = [0,0] # demand received by this node (demand at this node) self.demand_fulfilled = [0,0] # demand fulfilled by this node (demand that was served by this node) self.orders_shortage = [0,0] # shortage of products at this node self.backorder = [0,0] # any backorders at this node self.inventory_level = 0 # current inventory level at this node self.inventory_waste = 0 # inventory waste at this node self.inventory_carry_cost = 0 # inventory carrying cost at this node self.inventory_spend_cost = 0 # inventory replenishment cost at this node self.transportation_cost = 0 # transportation cost at this node self.node_cost = 0 # total cost at this node self.revenue = 0 # revenue generated by this node self.profit = 0 # profit generated by this node (revenue - total cost) if(periodic_update): self.node.env.process(self.update_stats_periodically(period=period))","title":"Statistics"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Statistics.reset","text":"reset() Reset the statistics to their initial values. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def reset(self): \"\"\" Reset the statistics to their initial values. Parameters: None Attributes: None Returns: None \"\"\" for key, value in vars(self).items(): if isinstance(value, list): if \"_keys\" in key: continue setattr(self, key, [0,0]) elif isinstance(value, (int, float)): setattr(self, key, 0) if hasattr(self.node, 'inventory'): self.node.inventory.carry_cost = 0 self.node.inventory.waste = 0","title":"reset"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Statistics.update_stats","text":"update_stats(**kwargs) Update the statistics with the given keyword arguments. Parameters: **kwargs \u2013 keyword arguments containing the statistics to update Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def update_stats(self,**kwargs): \"\"\" Update the statistics with the given keyword arguments. Parameters: **kwargs: keyword arguments containing the statistics to update Attributes: None Returns: None \"\"\" for key, value in kwargs.items(): if hasattr(self, key): attr = getattr(self, key) if isinstance(attr, list): # value = [v1,v2] attr[0] += value[0] attr[1] += value[1] setattr(self, key, attr) # update the attribute with the new value else: attr += value setattr(self, key, attr) # update the attribute with the new value else: global_logger.logger.warning(f\"{self.node.ID}: (Updaing stats) Attribute {key} not found in Statistics class.\") if hasattr(self.node, 'inventory'): if self.node.inventory.level != float('inf'): self.inventory_level = self.node.inventory.inventory.level if hasattr(self.node, 'inventory') else 0 self.node.inventory.update_carry_cost() self.inventory_carry_cost = self.node.inventory.carry_cost self.inventory_waste = self.node.inventory.waste if hasattr(self.node.inventory, 'waste') else 0 total_cost = 0 for key,value in vars(self).items(): if key == \"node_cost\": # exclude node_cost from the total cost calculation continue if \"cost\" in key: # consider all cost attributes total_cost += value self.node_cost = total_cost self.revenue = self.demand_fulfilled[1] * self.node.sell_price if hasattr(self.node, 'sell_price') else 0 self.profit = self.revenue - self.node_cost","title":"update_stats"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Statistics.update_stats_periodically","text":"update_stats_periodically(period) Update the statistics periodically. Parameters: period ( float ) \u2013 period for periodic update of statistics Returns: generator \u2013 a generator that yields after the specified period Source code in src/SupplyNetPy/Components/core.py def update_stats_periodically(self, period): \"\"\" Update the statistics periodically. Parameters: period (float): period for periodic update of statistics Attributes: None Returns: generator: a generator that yields after the specified period \"\"\" while True: yield self.node.env.timeout(period) self.update_stats()","title":"update_stats_periodically"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.RawMaterial","text":"RawMaterial(ID: str, name: str, extraction_quantity: float, extraction_time: float, mining_cost: float, cost: float) Bases: NamedEntity , InfoMixin The RawMaterial class represents a raw material in a supply chain. It defines key properties of a raw material, including extraction rate, extraction time, mining cost, and selling price. This class helps model the extraction processes at a raw material supplier node in the network. Parameters: ID ( str ) \u2013 ID of the raw material. name ( str ) \u2013 Name of the raw material. extraction_quantity ( float ) \u2013 Quantity extracted per extraction cycle. extraction_time ( float ) \u2013 Time required to extract the specified quantity. mining_cost ( float ) \u2013 Mining cost per item. cost ( float ) \u2013 Selling price per item. Attributes: _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. ID ( str ) \u2013 ID of the raw material. name ( str ) \u2013 Name of the raw material. extraction_quantity ( float ) \u2013 Quantity extracted per extraction cycle. extraction_time ( float ) \u2013 Time required for extraction. mining_cost ( float ) \u2013 Mining cost per item. cost ( float ) \u2013 Selling price per item. Methods: Name Description Initialize the raw material object. Parameters: ID ( str ) \u2013 ID of the raw material (alphanumeric) name ( str ) \u2013 name of the raw material extraction_quantity ( float ) \u2013 quantity of the raw material that is extracted in extraction_time extraction_time ( float ) \u2013 time to extract 'extraction_quantity' units of raw material mining_cost ( float ) \u2013 mining cost of the raw material (per item) cost ( float ) \u2013 selling cost of the raw material (per item) Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary _stats_keys ( list ) \u2013 list of keys to include in the statistics dictionary ID ( str ) \u2013 ID of the raw material (alphanumeric) name ( str ) \u2013 name of the raw material extraction_quantity ( float ) \u2013 quantity of the raw material that is extracted in extraction_time extraction_time ( float ) \u2013 time to extract 'extraction_quantity' units of raw material mining_cost ( float ) \u2013 mining cost of the raw material (per item) cost ( float ) \u2013 selling cost of the raw material (per item) Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, ID: str, name: str, extraction_quantity: float, extraction_time: float, mining_cost: float, cost: float) -> None: \"\"\" Initialize the raw material object. Parameters: ID (str): ID of the raw material (alphanumeric) name (str): name of the raw material extraction_quantity (float): quantity of the raw material that is extracted in extraction_time extraction_time (float): time to extract 'extraction_quantity' units of raw material mining_cost (float): mining cost of the raw material (per item) cost (float): selling cost of the raw material (per item) Attributes: _info_keys (list): list of keys to include in the info dictionary _stats_keys (list): list of keys to include in the statistics dictionary ID (str): ID of the raw material (alphanumeric) name (str): name of the raw material extraction_quantity (float): quantity of the raw material that is extracted in extraction_time extraction_time (float): time to extract 'extraction_quantity' units of raw material mining_cost (float): mining cost of the raw material (per item) cost (float): selling cost of the raw material (per item) Returns: None \"\"\" validate_positive(\"Extraction quantity\", extraction_quantity) validate_non_negative(\"Extraction time\", extraction_time) validate_non_negative(\"Mining Cost\", mining_cost) validate_positive(\"Cost\", cost) self._info_keys = [\"ID\", \"name\", \"extraction_quantity\", \"extraction_time\", \"mining_cost\", \"cost\"] self._stats_keys = [] self.ID = ID # ID of the raw material (alphanumeric) self.name = name # name of the raw material self.extraction_quantity = extraction_quantity # quantity of the raw material that is extracted in extraction_time self.extraction_time = extraction_time # time to extract 'extraction_quantity' units of raw material self.mining_cost = mining_cost # mining cost of the raw material (per item) self.cost = cost # selling cost of the raw material (per item)","title":"RawMaterial"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Product","text":"Product(ID: str, name: str, manufacturing_cost: float, manufacturing_time: float, sell_price: float, raw_materials: list, batch_size: int, buy_price: float = 0) Bases: NamedEntity , InfoMixin The Product class models a finished good in the supply chain. It defines essential properties such as manufacturing cost, manufacturing time, selling price, and the raw materials required to produce it. The class supports both buying and manufacturing workflows, allowing nodes to either purchase the product directly or produce it using defined raw material combinations. Products are typically manufactured in batches, with each batch size and cycle time configurable, making it easy to model real-world production processes. Parameters: ID ( str ) \u2013 ID of the product. name ( str ) \u2013 Name of the product. manufacturing_cost ( float ) \u2013 Manufacturing cost per unit. manufacturing_time ( float ) \u2013 Time to manufacture one batch. sell_price ( float ) \u2013 Selling price per unit. raw_materials ( list ) \u2013 List of (raw material object, quantity) tuples required to produce one unit. batch_size ( int ) \u2013 Number of units manufactured per cycle. buy_price ( float , default: 0 ) \u2013 Buying price per unit (default is 0). Attributes: _info_keys ( list ) \u2013 Keys to include in the info dictionary. _stats_keys ( list ) \u2013 Keys to include in the statistics dictionary. ID ( str ) \u2013 ID of the product. name ( str ) \u2013 Name of the product. manufacturing_cost ( float ) \u2013 Manufacturing cost per unit. manufacturing_time ( float ) \u2013 Manufacturing time for one batch. sell_price ( float ) \u2013 Selling price per unit. buy_price ( float ) \u2013 Buying price per unit. raw_materials ( list ) \u2013 List of (raw material, quantity) tuples required to produce one unit. batch_size ( int ) \u2013 Units manufactured per cycle. Methods: Name Description Initialize the product object. Performs input validation for positive and non-negative values, and ensures raw materials are provided. Parameters: ID ( str ) \u2013 ID of the product (alphanumeric) name ( str ) \u2013 Name of the product manufacturing_cost ( float ) \u2013 Manufacturing cost of the product per unit manufacturing_time ( float ) \u2013 Time to manufacture one batch of products sell_price ( float ) \u2013 Price at which the product is sold buy_price ( float , default: 0 ) \u2013 Price at which the product is bought (default is 0) raw_materials ( list ) \u2013 List of tuples containing (raw material object, quantity required) to manufacture one unit of the product batch_size ( int ) \u2013 Number of units manufactured per manufacturing cycle Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary _stats_keys ( list ) \u2013 List of keys to include in the statistics dictionary ID ( str ) \u2013 ID of the product name ( str ) \u2013 Name of the product manufacturing_cost ( float ) \u2013 Manufacturing cost per unit manufacturing_time ( float ) \u2013 Time to manufacture one batch sell_price ( float ) \u2013 Selling price of the product buy_price ( float ) \u2013 Buying price of the product (default is 0) raw_materials ( list ) \u2013 List of (raw material, quantity) required for one unit batch_size ( int ) \u2013 Number of units produced per manufacturing cycle Returns: None \u2013 None Raises: ValueError \u2013 If validations fail for positive values, non-negative values, or empty raw materials list. Source code in src/SupplyNetPy/Components/core.py def __init__(self, ID: str, name: str, manufacturing_cost: float, manufacturing_time: float, sell_price: float, raw_materials: list, batch_size: int, buy_price: float = 0) -> None: \"\"\" Initialize the product object. Performs input validation for positive and non-negative values, and ensures raw materials are provided. Parameters: ID (str): ID of the product (alphanumeric) name (str): Name of the product manufacturing_cost (float): Manufacturing cost of the product per unit manufacturing_time (float): Time to manufacture one batch of products sell_price (float): Price at which the product is sold buy_price (float, optional): Price at which the product is bought (default is 0) raw_materials (list): List of tuples containing (raw material object, quantity required) to manufacture one unit of the product batch_size (int): Number of units manufactured per manufacturing cycle Attributes: _info_keys (list): List of keys to include in the info dictionary _stats_keys (list): List of keys to include in the statistics dictionary ID (str): ID of the product name (str): Name of the product manufacturing_cost (float): Manufacturing cost per unit manufacturing_time (float): Time to manufacture one batch sell_price (float): Selling price of the product buy_price (float): Buying price of the product (default is 0) raw_materials (list): List of (raw material, quantity) required for one unit batch_size (int): Number of units produced per manufacturing cycle Returns: None Raises: ValueError: If validations fail for positive values, non-negative values, or empty raw materials list. \"\"\" validate_positive(\"Manufacturing cost\", manufacturing_cost) validate_non_negative(\"Manufacturing time\", manufacturing_time) validate_positive(\"Sell price\", sell_price) validate_non_negative(\"Buy price\", buy_price) validate_positive(\"Units per cycle\", batch_size) if raw_materials is None or len(raw_materials) == 0: global_logger.logger.error(\"Raw materials cannot be empty.\") raise ValueError(\"Raw materials cannot be empty.\") for raw_mat in raw_materials: if not isinstance(raw_mat[0], RawMaterial): raise ValueError(\"Invalid raw material.\") if raw_mat[1] <= 0: raise ValueError(\"Invalid quantity for raw material.\") self._info_keys = [\"ID\", \"name\", \"manufacturing_cost\", \"manufacturing_time\", \"sell_price\", \"buy_price\", \"raw_materials\", \"batch_size\"] self._stats_keys = [] self.ID = ID # ID of the product (alphanumeric) self.name = name # name of the product self.manufacturing_cost = manufacturing_cost # manufacturing cost of the product (per unit) self.manufacturing_time = manufacturing_time # time (days) to manufacture 'batch_size' units of product self.sell_price = sell_price # price at which the product is sold self.buy_price = buy_price # price at which the product is bought, (default: 0). It is used by InventoryNode buy the product at some price and sell it at a higher price. self.raw_materials = raw_materials # list of raw materials and quantity required to manufacture a single product unit self.batch_size = batch_size # number of units manufactured per cycle","title":"Product"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InventoryReplenishment","text":"InventoryReplenishment(env: Environment, node: object, params: dict) Bases: InfoMixin , NamedEntity The InventoryReplenishment class defines the abstract structure for inventory replenishment policies within SupplyNetPy. It provides a common interface for managing how nodes place replenishment orders during the simulation. This class is not intended for direct use. It must be subclassed to implement specific replenishment strategies, such as min-max (s, S), reorder point, quantity (RQ), or periodic review (TQ) policies. The run method should be overridden to define the replenishment logic for the policy. The class integrates with the SimPy environment to support time-driven inventory management. The inventory_drop event is used to signal stock depletion, enabling the replenishment process to respond to changes in inventory levels in real time. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy. Methods: Name Description run Placeholder method to be overridden by subclasses. Initialize the replenishment policy object. Parameters: env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, node: object, params: dict) -> None: \"\"\" Initialize the replenishment policy object. Parameters: env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy Attributes: _info_keys (list): list of keys to include in the info dictionary env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy Returns: None \"\"\" if not isinstance(env, simpy.Environment): raise ValueError(\"Invalid environment. Provide a valid SimPy environment.\") self._info_keys = [\"node\", \"params\"] self.env = env # simulation environment self.node = node # node to which this policy applies self.params = params # parameters for the replenishment policy","title":"InventoryReplenishment"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InventoryReplenishment.run","text":"run() This method should be overridden by subclasses to implement the specific replenishment policy logic. Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" This method should be overridden by subclasses to implement the specific replenishment policy logic. \"\"\" pass","title":"run"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SSReplenishment","text":"SSReplenishment(env, node, params) Bases: InventoryReplenishment Implements the (s, S) or min-max inventory replenishment policy with optional safety stock support. When the inventory level falls to or below the reorder point (s), an order is placed to replenish stock up to the order-up-to level (S). If safety stock is provided, both the reorder point and the order-up-to level are adjusted accordingly. The policy supports both event-driven and periodic inventory checks, with an optional initial review delay. Supplier selection is automatically managed using the node\u2019s supplier selection policy. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters (s, S) and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters. name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check begins. period ( float ) \u2013 Time interval for periodic inventory checks. Methods: Name Description run Monitors inventory and places orders based on the (s, S) policy. Initialize the replenishment policy object. Parameters: env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (s, S) Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (s, S) name ( str ) \u2013 replenishment policy name first_review_delay ( float ) \u2013 delay before the first inventory check is performed period ( float ) \u2013 period for periodic inventory check Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env, node, params): \"\"\" Initialize the replenishment policy object. Parameters: env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (s, S) Attributes: _info_keys (list): list of keys to include in the info dictionary env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (s, S) name (str): replenishment policy name first_review_delay (float): delay before the first inventory check is performed period (float): period for periodic inventory check Returns: None \"\"\" validate_non_negative(\"Reorder point (s)\", params['s']) # this assertion ensures that the reorder point is positive validate_positive(\"Order-up-to level (S)\", params['S']) # this assertion ensures that the order-up-to level is non-negative if 's' not in params or 'S' not in params: raise ValueError(\"Parameters 's' and 'S' must be provided for the (s, S) replenishment policy.\") if params['s'] > params['S']: raise ValueError(\"Reorder point (s) must be less than or equal to order-up-to level (S).\") super().__init__(env, node, params) self._info_keys.extend([\"name\",\"first_review_delay\",\"period\"]) self.name = \"min-max replenishment (s, S)\" self.first_review_delay = params.get('first_review_delay', 0) self.period = params.get('period',0)","title":"SSReplenishment"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SSReplenishment.run","text":"run() Replenishes the inventory based on the sS policy. Attributes: s ( float ) \u2013 reorder point S ( float ) \u2013 order-up-to level Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" Replenishes the inventory based on the sS policy. Parameters: None Attributes: s (float): reorder point S (float): order-up-to level Returns: None \"\"\" s, S = self.params['s'], self.params['S'] # get the reorder point and order-up-to level if s > S: self.node.logger.logger.error(\"Reorder point (s) must be less than or equal to order-up-to level (S).\") raise ValueError(\"Reorder point (s) must be less than or equal to order-up-to level (S).\") if 'safety_stock' in self.params: # check if safety_stock is specified validate_positive(\"Safety stock\", self.params['safety_stock']) self.name = \"min-max with safety replenishment (s, S, safety_stock)\" s += self.params['safety_stock'] S += self.params['safety_stock'] if self.first_review_delay > 0: # if first review delay is specified, wait for the specified time before starting the replenishment process yield self.env.timeout(self.first_review_delay) while True: # run the replenishment process indefinitely self.node.logger.logger.info(f\"{self.env.now:.4f}:{self.node.ID}: Inventory levels:{self.node.inventory.inventory.level}, on hand:{self.node.inventory.on_hand}\") if (self.node.inventory.on_hand - self.node.stats.backorder[1] <= s): order_quantity = S - (self.node.inventory.on_hand - self.node.stats.backorder[1]) # calculate the order quantity supplier = self.node.selection_policy.select(order_quantity) # select a supplier based on the supplier selection policy self.node.ongoing_order = True self.env.process(self.node.process_order(supplier, order_quantity)) if self.period==0: # if periodic check is OFF yield self.node.inventory_drop # wait for the inventory to be dropped self.node.inventory_drop = self.env.event() # reset the event for the next iteration elif(self.period): # if periodic check is ON yield self.env.timeout(self.period)","title":"run"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.RQReplenishment","text":"RQReplenishment(env, node, params) Bases: InventoryReplenishment Implements a Reorder Quantity (RQ) Inventory Replenishment Policy with optional safety stock support. This policy continuously monitors inventory levels and places a replenishment order when the inventory falls to or below the reorder point (R). The replenishment quantity is fixed at Q units per order. The inventory can be checked continuously (event-based) if 'period' is set to 0 (default) and periodically if a positive 'period' is provided. An optional first review delay can be configured to introduce a delay before the first inventory check begins. Supplier selection is managed automatically using the node's supplier selection policy. If the selected supplier does not have sufficient inventory, the shortage is recorded. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy: R, Q, and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters (R, Q, optional delays and period). name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check begins. period ( float ) \u2013 Time interval for periodic inventory checks. If 0, continuous checking is used. Methods: Name Description run Continuously monitors inventory and places replenishment orders when the reorder point is reached. Initialize the RQ replenishment policy object. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters R, Q, and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Replenishment policy parameters (R, Q, optional delays and period). name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check begins. period ( float ) \u2013 Time interval for periodic inventory checks. If 0, continuous checking is used. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env, node, params): \"\"\" Initialize the RQ replenishment policy object. Parameters: env (simpy.Environment): Simulation environment. node (object): Node to which this policy applies. params (dict): Replenishment policy parameters R, Q, and optional parameters (safety_stock, first_review_delay, period). Attributes: _info_keys (list): List of keys to include in the info dictionary. env (simpy.Environment): Simulation environment. node (object): Node to which this policy applies. params (dict): Replenishment policy parameters (R, Q, optional delays and period). name (str): Replenishment policy name. first_review_delay (float): Delay before the first inventory check begins. period (float): Time interval for periodic inventory checks. If 0, continuous checking is used. Returns: None \"\"\" validate_non_negative(\"Reorder point (R)\", params['R']) # this assertion ensures that the reorder point is non-negative validate_positive(\"Order quantity (Q)\", params['Q']) # this assertion ensures that the order quantity is positive super().__init__(env, node, params) self._info_keys.extend([\"name\", \"first_review_delay\", \"period\"]) # add the keys to the info dictionary self.name = \"RQ replenishment (R, Q)\" self.first_review_delay = params.get('first_review_delay', 0) self.period = params.get('period', 0)","title":"RQReplenishment"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.RQReplenishment.run","text":"run() Continuously monitors the inventory and places replenishment orders when the inventory level falls to or below the reorder point (R). If a periodic review interval is provided, inventory is checked at that interval. Otherwise, the system waits for inventory drop events to trigger the next check. Attributes: R ( float ) \u2013 Reorder point. Q ( float ) \u2013 Replenishment quantity. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" Continuously monitors the inventory and places replenishment orders when the inventory level falls to or below the reorder point (R). If a periodic review interval is provided, inventory is checked at that interval. Otherwise, the system waits for inventory drop events to trigger the next check. Parameters: None Attributes: R (float): Reorder point. Q (float): Replenishment quantity. Returns: None \"\"\" R, Q = self.params['R'], self.params['Q'] if self.first_review_delay > 0: yield self.env.timeout(self.first_review_delay) while True: self.node.logger.logger.info(f\"{self.env.now:.4f}:{self.node.ID}: Inventory levels: {self.node.inventory.inventory.level}, on hand: {self.node.inventory.on_hand}\") if (self.node.inventory.on_hand - self.node.stats.backorder[1] <= R): supplier = self.node.selection_policy.select(Q) self.node.ongoing_order = True self.env.process(self.node.process_order(supplier, Q)) if self.period == 0: yield self.node.inventory_drop self.node.inventory_drop = self.env.event() else: yield self.env.timeout(self.period)","title":"run"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.PeriodicReplenishment","text":"PeriodicReplenishment(env, node, params) Bases: InventoryReplenishment Implements a time-based inventory replenishment policy where a fixed quantity Q is ordered at regular intervals T with optional safety stock support. This policy ensures consistent inventory reviews and replenishment, independent of the current stock level. Supports an optional initial review delay before starting periodic checks. Supplier selection is automatically managed using the node\u2019s defined supplier selection policy. Shortages are recorded if the supplier does not have enough stock. Parameters: env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Dictionary containing replenishment parameters: T, Q, and optional parameters (safety_stock, first_review_delay). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 Simulation environment. node ( object ) \u2013 Node to which this policy applies. params ( dict ) \u2013 Parameters for the replenishment policy. name ( str ) \u2013 Replenishment policy name. first_review_delay ( float ) \u2013 Delay before the first inventory check. Methods: Name Description run Continuously manages periodic replenishment by placing orders of size Q every T time units. Initialize the replenishment policy object. Parameters: env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (T, Q), and optional parameters (safety_stock, first_review_delay). Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary env ( Environment ) \u2013 simulation environment node ( object ) \u2013 node to which this policy applies params ( dict ) \u2013 parameters for the replenishment policy (T, Q) name ( str ) \u2013 replenishment policy name first_review_delay ( float ) \u2013 delay before the first inventory check is performed Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env, node, params): \"\"\" Initialize the replenishment policy object. Parameters: env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (T, Q), and optional parameters (safety_stock, first_review_delay). Attributes: _info_keys (list): list of keys to include in the info dictionary env (simpy.Environment): simulation environment node (object): node to which this policy applies params (dict): parameters for the replenishment policy (T, Q) name (str): replenishment policy name first_review_delay (float): delay before the first inventory check is performed Returns: None \"\"\" validate_positive(\"Replenishment period (T)\", params['T']) # this assertion ensures that the replenishment period is positive validate_positive(\"Replenishment quantity (Q)\", params['Q']) # this assertion ensures that the replenishment quantity is positive super().__init__(env, node, params) self._info_keys.extend([\"name\", \"first_review_delay\"]) # add the keys to the info dictionary self.name = \"Periodic replenishment (T, Q)\" self.first_review_delay = params.get('first_review_delay', 0)","title":"PeriodicReplenishment"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.PeriodicReplenishment.run","text":"run() Replenishes the inventory based on the periodic policy. Attributes: name ( str ) \u2013 replenishment policy name _info_keys ( list ) \u2013 list of keys to include in the info dictionary Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def run(self): \"\"\" Replenishes the inventory based on the periodic policy. Parameters: None Attributes: name (str): replenishment policy name _info_keys (list): list of keys to include in the info dictionary Returns: None \"\"\" T, Q = self.params['T'], self.params['Q'] # get the period and quantity ss = 0 if 'safety_stock' in self.params: # check if safety_stock is specified validate_non_negative(\"Safety stock\", self.params['safety_stock']) self.name = \"Periodic with safety replenishment (T, Q, safety_stock)\" ss = self.params['safety_stock'] if self.first_review_delay > 0: yield self.env.timeout(self.first_review_delay) while True: self.node.logger.logger.info(f\"{self.env.now:.4f}:{self.node.ID}: Inventory levels:{self.node.inventory.inventory.level}, on hand:{self.node.inventory.on_hand}\") reorder_quantity = Q if (self.node.inventory.level < ss): reorder_quantity += ss - self.node.inventory.level supplier = self.node.selection_policy.select(reorder_quantity) # select a supplier based on the supplier selection policy self.node.ongoing_order = True self.env.process(self.node.process_order(supplier, reorder_quantity)) yield self.env.timeout(T) # periodic replenishment, wait for the next period","title":"run"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SupplierSelectionPolicy","text":"SupplierSelectionPolicy(node, mode='dynamic') Bases: InfoMixin , NamedEntity Defines the framework for supplier selection strategies in the supply chain. Supports two modes: (1) \"dynamic\": Supplier selection is flexible and can change based on real-time conditions. (2) \"fixed\": Always selects a pre-assigned supplier. The policy is applied at the node level, and this class serves as a base for implementing custom supplier selection policies. The 'select' method must be overridden in subclasses to define specific supplier selection logic. Parameters: node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode. Must be \"dynamic\" or \"fixed\". Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier ( object ) \u2013 Fixed supplier if the mode is set to \"fixed\". Methods: Name Description select Supplier selection logic to be implemented by subclasses. validate_suppliers Validates that the node has at least one connected supplier. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. node ( object ) \u2013 Node for which the supplier selection policy is applied. mode ( str ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier ( object ) \u2013 Fixed supplier if the mode is set to \"fixed\". Returns: \u2013 None Raises: ValueError \u2013 If the mode is not \"dynamic\" or \"fixed\". TypeError \u2013 If the node is not an instance of Node class. Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node for which the supplier selection policy is applied. mode (str): Supplier selection mode (\"dynamic\" or \"fixed\"). Attributes: _info_keys (list): List of keys to include in the info dictionary. node (object): Node for which the supplier selection policy is applied. mode (str): Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier (object): Fixed supplier if the mode is set to \"fixed\". Returns: None Raises: ValueError: If the mode is not \"dynamic\" or \"fixed\". TypeError: If the node is not an instance of Node class. \"\"\" if mode not in [\"dynamic\", \"fixed\"]: global_logger.logger.error(f\"Invalid mode: {mode}. Mode must be either 'dynamic' or 'fixed'.\") raise ValueError(\"Mode must be either 'dynamic' or 'fixed'.\") if not isinstance(node, Node): global_logger.logger.error(\"Node must be an instance of Node class.\") raise TypeError(\"Node must be an instance of Node class.\") self._info_keys = [\"node\", \"mode\"] self.node = node self.mode = mode self.fixed_supplier = None","title":"SupplierSelectionPolicy"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SupplierSelectionPolicy.select","text":"select(order_quantity) Supplier selection logic to be implemented by subclasses. Parameters: order_quantity ( float ) \u2013 Quantity to be ordered. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Supplier selection logic to be implemented by subclasses. Parameters: order_quantity (float): Quantity to be ordered. Returns: None \"\"\" raise NotImplementedError(\"Subclasses must implement this method.\")","title":"select"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SupplierSelectionPolicy.validate_suppliers","text":"validate_suppliers() Validates that the node has at least one connected supplier. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def validate_suppliers(self): \"\"\" Validates that the node has at least one connected supplier. Returns: None \"\"\" if not self.node.suppliers: global_logger.logger.error(f\"{self.node.ID} must have at least one supplier.\") raise ValueError(f\"{self.node.ID} must have at least one supplier.\")","title":"validate_suppliers"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectFirst","text":"SelectFirst(node, mode='fixed') Bases: SupplierSelectionPolicy Implements a supplier selection policy that always selects the first supplier in the supplier list. In dynamic mode, the first supplier is selected at each order event. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'fixed' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"fixed\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode. fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the first supplier, either dynamically or as a fixed supplier. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'fixed' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"fixed\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"fixed\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"fixed\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"First fixed supplier\" self._info_keys.extend([\"name\"])","title":"SelectFirst"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectFirst.select","text":"select(order_quantity) Selects the first supplier in the supplier list. In dynamic mode, the selection is evaluated for each order. In fixed mode, the first supplier is locked for all subsequent selections. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the first supplier in the supplier list. In dynamic mode, the selection is evaluated for each order. In fixed mode, the first supplier is locked for all subsequent selections. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = self.node.suppliers[0] if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected","title":"select"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectAvailable","text":"SelectAvailable(node, mode='dynamic') Bases: SupplierSelectionPolicy Selects the first supplier that has sufficient available inventory to fulfill the requested order quantity. If no supplier can fully meet the order, it defaults to the first supplier in the list. Supports both dynamic selection (evaluated at each order event) and fixed selection (locks the first selected supplier). Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode. fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the first available supplier with sufficient inventory. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"First available supplier\" self._info_keys.extend([\"name\"])","title":"SelectAvailable"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectAvailable.select","text":"select(order_quantity) Selects the first supplier with sufficient available inventory. If no supplier can fully meet the requested order quantity, defaults to the first supplier in the list. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the first supplier with sufficient available inventory. If no supplier can fully meet the requested order quantity, defaults to the first supplier in the list. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = self.node.suppliers[0] suppliers = [s for s in self.node.suppliers if s.source.inventory.inventory.level >= order_quantity] if suppliers: selected = suppliers[0] if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected","title":"select"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectCheapest","text":"SelectCheapest(node, mode='dynamic') Bases: SupplierSelectionPolicy Selects the supplier offering the lowest transportation cost for the order. The supplier is chosen based on the minimum transportation cost among all connected suppliers. Supports both dynamic selection (evaluated at each order event) and fixed selection (locks the first selected supplier). Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode. fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the supplier with the lowest transportation cost. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"Cheapest supplier (Transportation cost)\" self._info_keys.extend([\"name\"])","title":"SelectCheapest"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectCheapest.select","text":"select(order_quantity) Selects the supplier with the lowest transportation cost. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the supplier with the lowest transportation cost. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = min(self.node.suppliers, key=lambda s: s.cost) if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected","title":"select"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectFastest","text":"SelectFastest(node, mode='dynamic') Bases: SupplierSelectionPolicy Selects the supplier with the shortest lead time to deliver the product. The selection is based on minimizing lead time among all connected suppliers. Supports both dynamic selection (evaluated at each order event) and fixed selection (locks the first selected supplier for all subsequent orders). Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: node ( object ) \u2013 Node to which this policy applies. mode ( str ) \u2013 Supplier selection mode (\"dynamic\" or \"fixed\"). fixed_supplier ( object ) \u2013 Locked supplier if mode is \"fixed\". name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Methods: Name Description select Selects the supplier with the shortest lead time based on the configured mode. Initialize the supplier selection policy object. Parameters: node ( object ) \u2013 Node to which this supplier selection policy applies. mode ( str , default: 'dynamic' ) \u2013 Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name ( str ) \u2013 Name of the selection policy. _info_keys ( list ) \u2013 List of keys to include in the info dictionary. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, node, mode=\"dynamic\"): \"\"\" Initialize the supplier selection policy object. Parameters: node (object): Node to which this supplier selection policy applies. mode (str, optional): Supplier selection mode, either \"dynamic\" or \"fixed\" (default: \"dynamic\"). Attributes: name (str): Name of the selection policy. _info_keys (list): List of keys to include in the info dictionary. Returns: None \"\"\" super().__init__(node, mode) self.name = \"Fastest supplier (Lead time)\" self._info_keys.extend([\"name\"])","title":"SelectFastest"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.SelectFastest.select","text":"select(order_quantity) Selects the supplier with the shortest lead time. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity ( float ) \u2013 The quantity to order. Returns: object \u2013 The selected supplier. Source code in src/SupplyNetPy/Components/core.py def select(self, order_quantity): \"\"\" Selects the supplier with the shortest lead time. In fixed mode, the first selected supplier is locked for all subsequent orders. Parameters: order_quantity (float): The quantity to order. Returns: object: The selected supplier. \"\"\" self.validate_suppliers() selected = min(self.node.suppliers, key=lambda s: s.lead_time()) if self.mode == \"fixed\" and self.fixed_supplier is None: self.fixed_supplier = selected return self.fixed_supplier if self.mode == \"fixed\" else selected","title":"select"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Node","text":"Node(env: Environment, ID: str, name: str, node_type: str, failure_p: float = 0.0, node_disrupt_time: callable = None, node_recovery_time: callable = lambda: 1, logging: bool = True, **kwargs) Bases: NamedEntity , InfoMixin Represents a node in the supply network, such as a supplier, manufacturer, warehouse, distributor, retailer, or demand point. Supports automatic disruption and recovery, dynamic logging, and performance tracking. Each node can experience disruptions either probabilistically or based on custom-defined disruption and recovery times. During disruptions, the node becomes inactive and resumes operations after the specified recovery period. Tracks key performance metrics like transportation costs, node-specific costs, profit and net profit, products sold, demand placed, and shortages. Supports integration with inbuilt replenishment policies: SS, RQ, Periodic and any custom policy created by extending the ReplenishmentPolicy class. Supplier selection policies: Available, Cheapest, Fastest and any custom policy created by extending the SupplierSelectionPolicy class. Supported node types: \"infinite_supplier\", \"supplier\", \"manufacturer\", \"factory\", \"warehouse\", \"distributor\", \"retailer\", \"store\", \"demand\" Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique node ID. name ( str ) \u2013 Node name. node_type ( str ) \u2013 Type of the node. failure_p ( float , default: 0.0 ) \u2013 Probability of node failure. node_disrupt_time ( callable , default: None ) \u2013 Function to generate disruption time. node_recovery_time ( callable , default: lambda: 1 ) \u2013 Function to generate recovery time. logging ( bool , default: True ) \u2013 Flag to enable/disable logging. **kwargs \u2013 Additional arguments for the logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 ID of the node (alphanumeric) name ( str ) \u2013 name of the node node_type ( str ) \u2013 type of the node node_failure_p ( float ) \u2013 node failure probability node_status ( str ) \u2013 status of the node (active/inactive) node_disrupt_time ( callable ) \u2013 function to model node disruption time node_recovery_time ( callable ) \u2013 function to model node recovery time logger ( GlobalLogger ) \u2013 logger object Methods: Name Description disruption Simulates node disruption and automatic recovery over time. Initialize the node object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique node ID. name ( str ) \u2013 Node name. node_type ( str ) \u2013 Type of the node. failure_p ( float , default: 0.0 ) \u2013 Probability of node failure. node_disrupt_time ( callable , default: None ) \u2013 Function to generate disruption time. node_recovery_time ( callable , default: lambda: 1 ) \u2013 Function to generate recovery time. logging ( bool , default: True ) \u2013 Flag to enable/disable logging. **kwargs \u2013 Additional arguments for the logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 ID of the node (alphanumeric) name ( str ) \u2013 name of the node node_type ( str ) \u2013 type of the node node_failure_p ( float ) \u2013 node failure probability node_status ( str ) \u2013 status of the node (active/inactive) node_disrupt_time ( callable ) \u2013 function to model node disruption time node_recovery_time ( callable ) \u2013 function to model node recovery time logger ( GlobalLogger ) \u2013 logger object Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, node_type: str, failure_p:float = 0.0, node_disrupt_time:callable = None, node_recovery_time:callable = lambda: 1, logging: bool = True, **kwargs) -> None: \"\"\" Initialize the node object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique node ID. name (str): Node name. node_type (str): Type of the node. failure_p (float, optional): Probability of node failure. node_disrupt_time (callable, optional): Function to generate disruption time. node_recovery_time (callable, optional): Function to generate recovery time. logging (bool, optional): Flag to enable/disable logging. **kwargs: Additional arguments for the logger. Attributes: _info_keys (list): List of keys to include in the info dictionary. env (simpy.Environment): simulation environment ID (str): ID of the node (alphanumeric) name (str): name of the node node_type (str): type of the node node_failure_p (float): node failure probability node_status (str): status of the node (active/inactive) node_disrupt_time (callable): function to model node disruption time node_recovery_time (callable): function to model node recovery time logger (GlobalLogger): logger object Returns: None \"\"\" if not isinstance(env, simpy.Environment): raise ValueError(\"Invalid environment. Provide a valid SimPy environment.\") if(node_type.lower() not in [\"infinite_supplier\",\"supplier\", \"manufacturer\", \"factory\", \"warehouse\", \"distributor\", \"retailer\", \"store\", \"demand\"]): global_logger.logger.error(f\"Invalid node type. Node type: {node_type}\") raise ValueError(\"Invalid node type.\") if not callable(node_recovery_time): node_recovery_time = lambda val=node_recovery_time: val # convert to a callable function if node_disrupt_time is not None: if not callable(node_disrupt_time): node_disrupt_time = lambda val=node_disrupt_time: val # convert to a callable function validate_number(name=\"node_disrupt_time\", value=node_disrupt_time()) # check if disrupt_time is a number if node_recovery_time is not None: validate_number(name=\"node_recovery_time\", value=node_recovery_time()) # check if disrupt_time is a number self._info_keys = [\"ID\", \"name\", \"node_type\", \"failure_p\", \"node_status\", \"logging\"] self.env = env # simulation environment self.ID = ID # ID of the node (alphanumeric) self.name = name # name of the node self.node_type = node_type # type of the node (supplier, manufacturer, warehouse, distributor, retailer, demand) self.node_failure_p = failure_p # node failure probability self.node_status = \"active\" # node status (active/inactive) self.node_disrupt_time = node_disrupt_time # callable function to model node disruption time self.node_recovery_time = node_recovery_time # callable function to model node recovery time logger_name = self.ID # default logger name is the node ID if 'logger_name' in kwargs.keys(): logger_name = kwargs['logger_name'] self.logger = GlobalLogger(logger_name=logger_name, **kwargs) # create a logger if not logging: self.logger.disable_logging() # disable logging if logging is False else: self.logger.enable_logging() if(self.node_failure_p>0 or self.node_disrupt_time): # start self disruption if failure probability > 0 self.env.process(self.disruption())","title":"Node"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Node.disruption","text":"disruption() This method disrupts the node by changing the node status to \"inactive\" and recovers it after the specified recovery time. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def disruption(self): \"\"\" This method disrupts the node by changing the node status to \"inactive\" and recovers it after the specified recovery time. Parameters: None Attributes: None Returns: None \"\"\" # TODO: interrupt all ongoing processes spawned by this node on disruption, and resume them after recovery. while True: if(self.node_status==\"active\"): if(self.node_disrupt_time): # if node_disrupt_time is provided, wait for the disruption time disrupt_time = self.node_disrupt_time() # get the disruption time validate_positive(name=\"node_disrupt_time\", value=disrupt_time) # check if disrupt_time is positive yield self.env.timeout(disrupt_time) self.node_status = \"inactive\" # change the node status to inactive self.logger.logger.info(f\"{self.env.now}:{self.ID}: Node disrupted.\") elif(random.random() < self.node_failure_p): self.node_status = \"inactive\" self.logger.logger.info(f\"{self.env.now}:{self.ID}: Node disrupted.\") yield self.env.timeout(1) else: recovery_time = self.node_recovery_time() # get the recovery time validate_positive(name=\"node_recovery_time\", value=recovery_time) # check if disrupt_time is positive yield self.env.timeout(recovery_time) self.node_status = \"active\" self.logger.logger.info(f\"{self.env.now}:{self.ID}: Node recovered from disruption.\")","title":"disruption"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Link","text":"Link(env: Environment, ID: str, source: Node, sink: Node, cost: float, lead_time: callable, link_failure_p: float = 0.0, link_disrupt_time: callable = None, link_recovery_time: callable = lambda: 1) Bases: NamedEntity , InfoMixin Represents a transportation connection between two nodes in the supply network. Each link carries a transportation cost and lead time. Links can experience disruptions based on a failure probability or a disruption time distribution and will automatically recover after a specified recovery time. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 ID of the link. source ( Node ) \u2013 Source node of the link. sink ( Node ) \u2013 Sink node of the link. cost ( float ) \u2013 Transportation cost of the link. lead_time ( callable ) \u2013 Function returning lead time for the link. link_failure_p ( float , default: 0.0 ) \u2013 Probability of random link failure. link_disrupt_time ( callable , default: None ) \u2013 Function returning time to next disruption. link_recovery_time ( callable , default: lambda: 1 ) \u2013 Function returning recovery time after disruption. Attributes: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 ID of the link. source ( Node ) \u2013 Source node. sink ( Node ) \u2013 Sink node. cost ( float ) \u2013 Transportation cost. lead_time ( callable ) \u2013 Function for stochastic lead time. link_failure_p ( float ) \u2013 Failure probability. status ( str ) \u2013 Current status of the link (\"active\" or \"inactive\"). link_disrupt_time ( callable ) \u2013 Disruption time function. link_recovery_time ( callable ) \u2013 Recovery time function. Methods: Name Description disruption Simulates link disruption and automatic recovery. Initialize the Link object representing a transportation connection between two nodes. Parameters: env ( Environment ) \u2013 The simulation environment. ID ( str ) \u2013 Unique identifier for the link. source ( Node ) \u2013 The source node of the link. Cannot be a demand node. sink ( Node ) \u2013 The sink node of the link. Cannot be a supplier node. cost ( float ) \u2013 Transportation cost associated with the link. Must be non-negative. lead_time ( callable ) \u2013 Function returning the stochastic lead time. Cannot be None. link_failure_p ( float , default: 0.0 ) \u2013 Probability of random link failure. Default is 0.0. link_disrupt_time ( callable , default: None ) \u2013 Function returning the time to the next disruption. If provided, overrides link_failure_p. link_recovery_time ( callable , default: lambda: 1 ) \u2013 Function returning the time required for link recovery after disruption. Default is a constant 1 unit. Attributes: env ( Environment ) \u2013 The simulation environment. ID ( str ) \u2013 The ID of the link. source ( Node ) \u2013 The source node. sink ( Node ) \u2013 The sink node. name ( str ) \u2013 Readable name of the link combining source and sink IDs. cost ( float ) \u2013 Transportation cost. lead_time ( callable ) \u2013 Lead time function. link_failure_p ( float ) \u2013 Link failure probability. status ( str ) \u2013 Link status (\"active\" or \"inactive\"). link_recovery_time ( callable ) \u2013 Link recovery time function. link_disrupt_time ( callable ) \u2013 Disruption time function. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, source: Node, sink: Node, cost: float, # transportation cost lead_time: callable, link_failure_p: float = 0.0, link_disrupt_time: callable = None, link_recovery_time: callable = lambda: 1) -> None: \"\"\" Initialize the Link object representing a transportation connection between two nodes. Parameters: env (simpy.Environment): The simulation environment. ID (str): Unique identifier for the link. source (Node): The source node of the link. Cannot be a demand node. sink (Node): The sink node of the link. Cannot be a supplier node. cost (float): Transportation cost associated with the link. Must be non-negative. lead_time (callable): Function returning the stochastic lead time. Cannot be None. link_failure_p (float, optional): Probability of random link failure. Default is 0.0. link_disrupt_time (callable, optional): Function returning the time to the next disruption. If provided, overrides link_failure_p. link_recovery_time (callable, optional): Function returning the time required for link recovery after disruption. Default is a constant 1 unit. Attributes: env (simpy.Environment): The simulation environment. ID (str): The ID of the link. source (Node): The source node. sink (Node): The sink node. name (str): Readable name of the link combining source and sink IDs. cost (float): Transportation cost. lead_time (callable): Lead time function. link_failure_p (float): Link failure probability. status (str): Link status (\"active\" or \"inactive\"). link_recovery_time (callable): Link recovery time function. link_disrupt_time (callable): Disruption time function. Returns: None \"\"\" self._info_keys = [\"ID\", \"source\", \"sink\", \"cost\", \"lead_time\", \"link_failure_p\"] self._stats_keys = [\"status\"] if not isinstance(env, simpy.Environment): raise ValueError(\"Invalid environment. Provide a valid SimPy environment.\") if not isinstance(source, Node) or not isinstance(sink, Node): raise ValueError(\"Invalid source or sink node. Provide valid Node instances.\") if not callable(lead_time): lead_time = lambda val=lead_time: val # convert to callable if(lead_time == None): global_logger.logger.error(\"Lead time cannot be None. Provide a function to model stochastic lead time.\") raise ValueError(\"Lead time cannot be None. Provide a function to model stochastic lead time.\") if(source == sink): global_logger.logger.error(\"Source and sink nodes cannot be the same.\") raise ValueError(\"Source and sink nodes cannot be the same.\") if(source.node_type == \"demand\"): global_logger.logger.error(\"Demand node cannot be a source node.\") raise ValueError(\"Demand node cannot be a source node.\") if(\"supplier\" in sink.node_type): global_logger.logger.error(\"Supplier node cannot be a sink node.\") raise ValueError(\"Supplier node cannot be a sink node.\") if(\"supplier\" in source.node_type and \"supplier\" in sink.node_type): global_logger.logger.error(\"Supplier nodes cannot be connected.\") raise ValueError(\"Supplier nodes cannot be connected.\") if(\"supplier\" in source.node_type and sink.node_type == \"demand\"): global_logger.logger.error(\"Supplier node cannot be connected to a demand node.\") raise ValueError(\"Supplier node cannot be connected to a demand node.\") validate_non_negative(\"Cost\", cost) if (link_disrupt_time is not None): validate_number(name=\"link_disrupt_time\", value=link_disrupt_time()) # check if disrupt_time is a number if (link_recovery_time is not None): validate_number(name=\"link_recovery_time\", value=link_recovery_time()) # check if disrupt_time is a number self.env = env # simulation environment self.ID = ID # ID of the link (alphanumeric) self.source = source # source node of the link self.sink = sink # sink node of the link self.name = f\"{self.source.ID} to {self.sink.ID}\" # name of the link self.cost = cost # cost of the link self.lead_time = lead_time # lead time of the link self.link_failure_p = link_failure_p # link failure probability self.status = \"active\" # link status (active/inactive) self.link_recovery_time = link_recovery_time # link recovery time self.link_disrupt_time = link_disrupt_time # link disruption time, if provided self.sink.suppliers.append(self) # add the link as a supplier link to the sink node if(self.link_failure_p>0 or self.link_disrupt_time): # disrupt the link if link_failure_p > 0 self.env.process(self.disruption())","title":"Link"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Link.disruption","text":"disruption() This method disrupts the link by changing the link status to \"inactive\" and recovers it after the specified recovery time. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def disruption(self): \"\"\" This method disrupts the link by changing the link status to \"inactive\" and recovers it after the specified recovery time. Parameters: None Attributes: None Returns: None \"\"\" # TODO: interrupt all ongoing transports by this link on disruption. while True: if(self.status==\"active\"): if(self.link_disrupt_time): # if link_disrupt_time is provided, wait for the disruption time disrupt_time = self.link_disrupt_time() # get the disruption time validate_positive(name=\"link_disrupt_time\", value=disrupt_time) # check if disrupt_time is positive yield self.env.timeout(disrupt_time) self.status = \"inactive\" # change the link status to inactive global_logger.logger.info(f\"{self.env.now}:{self.ID}: Link disrupted.\") elif(random.random() < self.link_failure_p): self.status = \"inactive\" global_logger.logger.info(f\"{self.env.now}:{self.ID}: Link disrupted.\") yield self.env.timeout(1) else: recovery_time = self.link_recovery_time() # get the recovery time validate_positive(name=\"link_recovery_time\", value=recovery_time) # check if disrupt_time is positive yield self.env.timeout(recovery_time) self.status = \"active\" global_logger.logger.info(f\"{self.env.now}:{self.ID}: Link recovered from disruption.\")","title":"disruption"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Inventory","text":"Inventory(env: Environment, capacity: float, initial_level: float, node: Node, replenishment_policy: InventoryReplenishment, holding_cost: float = 0.0, shelf_life: float = 0, inv_type: str = 'non-perishable') Bases: NamedEntity , InfoMixin The Inventory class models stock management within a node in the supply network. It supports both perishable and non-perishable items, enforces capacity limits, tracks on-hand levels, and notifies replenishment policy whenever inventory levels drops. For perishable inventories, it manages product shelf life and automatically removes expired items. The class also records inventory levels and calculates carrying costs over time. Parameters: env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. node ( Node ) \u2013 Node to which this inventory belongs. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy for the inventory. holding_cost ( float , default: 0.0 ) \u2013 Holding cost per unit per time period. shelf_life ( float , default: 0 ) \u2013 Shelf life for perishable items. inv_type ( str , default: 'non-perishable' ) \u2013 Type of the inventory, either \"non-perishable\" or \"perishable\". Attributes: _info_keys ( list ) \u2013 Keys included in the information dictionary. _stats_keys ( list ) \u2013 Keys included in the statistics dictionary. env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum inventory capacity. init_level ( float ) \u2013 Initial inventory level. level ( float ) \u2013 Current inventory level. on_hand ( float ) \u2013 Current on-hand inventory. inv_type ( str ) \u2013 Inventory type (\"non-perishable\" or \"perishable\"). holding_cost ( float ) \u2013 Holding cost per unit. carry_cost ( float ) \u2013 Total accumulated carrying cost. replenishment_policy ( InventoryReplenishment ) \u2013 Inventory replenishment policy. inventory ( Container ) \u2013 SimPy container managing inventory levels. last_update_t ( float ) \u2013 Last timestamp when carrying cost was updated. shelf_life ( float ) \u2013 Shelf life of perishable items (if applicable). perish_queue ( list ) \u2013 Queue managing perishable items as (manufacturing_date, quantity). waste ( float ) \u2013 Total quantity of expired items. instantaneous_levels ( list ) \u2013 Recorded inventory levels over time. Methods: Name Description record_inventory_levels Records inventory levels at regular time intervals. put Adds items to the inventory, handling perishable item tracking. get Removes items from inventory, using FIFO for perishables. remove_expired Automatically removes expired items from perishable inventory. update_carry_cost Updates carrying cost based on inventory level and holding time. Initialize the Inventory object. Parameters: env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. node ( Node ) \u2013 Node to which this inventory belongs. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy for the inventory. holding_cost ( float , default: 0.0 ) \u2013 Holding cost per unit per time period. shelf_life ( float , default: 0 ) \u2013 Shelf life for perishable items. inv_type ( str , default: 'non-perishable' ) \u2013 Type of the inventory, either \"non-perishable\" or \"perishable\". Attributes: _info_keys ( list ) \u2013 Keys included in the information dictionary. _stats_keys ( list ) \u2013 Keys included in the statistics dictionary. env ( Environment ) \u2013 Simulation environment. capacity ( float ) \u2013 Maximum inventory capacity. init_level ( float ) \u2013 Initial inventory level. level ( float ) \u2013 Current inventory level. on_hand ( float ) \u2013 Current on-hand inventory. inv_type ( str ) \u2013 Inventory type (\"non-perishable\" or \"perishable\"). holding_cost ( float ) \u2013 Holding cost per unit. carry_cost ( float ) \u2013 Total accumulated carrying cost. replenishment_policy ( InventoryReplenishment ) \u2013 Inventory replenishment policy. inventory ( Container ) \u2013 SimPy container managing inventory levels. last_update_t ( float ) \u2013 Last timestamp when carrying cost was updated. shelf_life ( float ) \u2013 Shelf life of perishable items (if applicable). perish_queue ( list ) \u2013 Queue managing perishable items as (manufacturing_date, quantity). waste ( float ) \u2013 Total quantity of expired items. instantaneous_levels ( list ) \u2013 Recorded inventory levels over time. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, capacity: float, initial_level: float, node: Node, replenishment_policy: InventoryReplenishment, holding_cost: float = 0.0, shelf_life: float = 0, inv_type: str = \"non-perishable\") -> None: \"\"\" Initialize the Inventory object. Parameters: env (simpy.Environment): Simulation environment. capacity (float): Maximum capacity of the inventory. initial_level (float): Initial inventory level. node (Node): Node to which this inventory belongs. replenishment_policy (InventoryReplenishment): Replenishment policy for the inventory. holding_cost (float): Holding cost per unit per time period. shelf_life (float): Shelf life for perishable items. inv_type (str): Type of the inventory, either \"non-perishable\" or \"perishable\". Attributes: _info_keys (list): Keys included in the information dictionary. _stats_keys (list): Keys included in the statistics dictionary. env (simpy.Environment): Simulation environment. capacity (float): Maximum inventory capacity. init_level (float): Initial inventory level. level (float): Current inventory level. on_hand (float): Current on-hand inventory. inv_type (str): Inventory type (\"non-perishable\" or \"perishable\"). holding_cost (float): Holding cost per unit. carry_cost (float): Total accumulated carrying cost. replenishment_policy (InventoryReplenishment): Inventory replenishment policy. inventory (simpy.Container): SimPy container managing inventory levels. last_update_t (float): Last timestamp when carrying cost was updated. shelf_life (float): Shelf life of perishable items (if applicable). perish_queue (list): Queue managing perishable items as (manufacturing_date, quantity). waste (float): Total quantity of expired items. instantaneous_levels (list): Recorded inventory levels over time. Returns: None \"\"\" if not isinstance(node, Node): global_logger.logger.error(\"Node must be an instance of Node class.\") raise TypeError(\"Node must be an instance of Node class.\") self.node = node # node to which this inventory belongs if initial_level > capacity: self.node.logger.logger.error(\"Initial level cannot be greater than capacity.\") raise ValueError(\"Initial level cannot be greater than capacity.\") if replenishment_policy is not None: if not issubclass(replenishment_policy.__class__, InventoryReplenishment): self.node.logger.logger.error(f\"{replenishment_policy.__name__} must inherit from InventoryReplenishment\") raise TypeError(f\"{replenishment_policy.__name__} must inherit from InventoryReplenishment\") if inv_type not in [\"non-perishable\", \"perishable\"]: self.node.logger.logger.error(f\"Invalid inventory type. {inv_type} is not yet available.\") raise ValueError(f\"Invalid inventory type. {inv_type} is not yet available.\") validate_positive(\"Capacity\", capacity) validate_non_negative(\"Initial level\", initial_level) validate_non_negative(\"Inventory holding cost\",holding_cost) validate_non_negative(\"Shelf life\", shelf_life) self._info_keys = [\"capacity\", \"initial_level\", \"replenishment_policy\", \"holding_cost\", \"shelf_life\", \"inv_type\"] self._stats_keys = [\"level\", \"carry_cost\", \"instantaneous_levels\"] self.env = env self.capacity = capacity self.init_level = initial_level self.level = initial_level self.on_hand = initial_level # current inventory level self.inv_type = inv_type self.holding_cost = holding_cost self.carry_cost = 0 # initial carrying cost based on the initial inventory level self.replenishment_policy = replenishment_policy self.inventory = simpy.Container(env=self.env, capacity=self.capacity, init=self.init_level) # Inventory container setup self.last_update_t = self.env.now # last time the carrying cost was updated if self.inv_type == \"perishable\": validate_positive(\"Shelf life\", shelf_life) self.shelf_life = shelf_life self.perish_queue = [(0, initial_level)] self.waste = 0 self.env.process(self.remove_expired()) self.instantaneous_levels = [] self.env.process(self.record_inventory_levels()) # record inventory levels at regular intervals","title":"Inventory"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Inventory.record_inventory_levels","text":"record_inventory_levels() Record inventory levels at regular intervals. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def record_inventory_levels(self): \"\"\" Record inventory levels at regular intervals. Parameters: None Attributes: None Returns: None \"\"\" while True: self.instantaneous_levels.append((self.env.now,self.inventory.level)) # record the current inventory level yield self.env.timeout(1)","title":"record_inventory_levels"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Inventory.put","text":"put(amount: float, manufacturing_date: float = None) Add items to inventory. For perishable items, tracks manufacturing date. Parameters: amount ( float ) \u2013 amount to add manufacturing_date ( float , default: None ) \u2013 only required for perishable inventories Source code in src/SupplyNetPy/Components/core.py def put(self, amount: float, manufacturing_date: float = None): \"\"\" Add items to inventory. For perishable items, tracks manufacturing date. Parameters: amount (float): amount to add manufacturing_date (float): only required for perishable inventories \"\"\" if self.inventory.level == float('inf') or amount <=0: return if self.inv_type == \"perishable\": if manufacturing_date is None: self.node.logger.logger.error(\"Manufacturing date must be provided for perishable inventory.\") raise ValueError(\"Manufacturing date must be provided for perishable inventory.\") inserted = False for i in range(len(self.perish_queue)): if self.perish_queue[i][0] > manufacturing_date: self.perish_queue.insert(i, (manufacturing_date, amount)) inserted = True break if not inserted: self.perish_queue.append((manufacturing_date, amount)) self.update_carry_cost() # Update carrying cost based on the amount added self.inventory.put(amount) self.level = self.inventory.level # Update the current inventory level if(not self.node.inventory_raised.triggered): self.node.inventory_raised.succeed() # signal that inventory has been raised","title":"put"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Inventory.get","text":"get(amount: float) Remove items from inventory. For perishable items, oldest products are removed first. Parameters: amount ( float ) \u2013 amount to remove Returns: tuple \u2013 (SimPy get event, List of (manufacture_date, quantity)) for perishable items Source code in src/SupplyNetPy/Components/core.py def get(self, amount: float): \"\"\" Remove items from inventory. For perishable items, oldest products are removed first. Parameters: amount (float): amount to remove Returns: tuple: (SimPy get event, List of (manufacture_date, quantity)) for perishable items \"\"\" if self.inventory.level == float('inf'): return self.inventory.get(amount), [] man_date_ls = [] if self.inv_type == \"perishable\": x_amount = amount while x_amount > 0 and self.perish_queue: mfg_date, qty = self.perish_queue[0] if qty <= x_amount: man_date_ls.append((mfg_date, qty)) x_amount -= qty self.perish_queue.pop(0) else: man_date_ls.append((mfg_date, x_amount)) self.perish_queue[0] = (mfg_date, qty - x_amount) x_amount = 0 self.update_carry_cost() get_event = self.inventory.get(amount) self.level = self.inventory.level # Update the current inventory level self.on_hand -= amount # Update the on-hand inventory level if(self.replenishment_policy): if(not self.node.inventory_drop.triggered): self.node.inventory_drop.succeed() # signal that inventory has been dropped return get_event, man_date_ls","title":"get"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Inventory.remove_expired","text":"remove_expired() Remove expired items from perishable inventory. Source code in src/SupplyNetPy/Components/core.py def remove_expired(self): \"\"\" Remove expired items from perishable inventory. \"\"\" while True: yield self.env.timeout(1) while self.perish_queue and self.env.now - self.perish_queue[0][0] >= self.shelf_life: mfg_date, qty = self.perish_queue[0] # get first item in the queue self.node.logger.logger.info(f\"{self.env.now:.4f}: {qty} units expired (Mgf date:{mfg_date}).\") self.waste += qty if qty > 0: self.get(qty) # get/remove expired items from the inventory else: self.perish_queue.pop(0)","title":"remove_expired"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Inventory.update_carry_cost","text":"update_carry_cost() Update the carrying cost of the inventory based on the current level and holding cost. Source code in src/SupplyNetPy/Components/core.py def update_carry_cost(self): \"\"\" Update the carrying cost of the inventory based on the current level and holding cost. \"\"\" carry_period = self.env.now - self.last_update_t self.carry_cost += self.inventory.level * (carry_period) * self.holding_cost # update the carrying cost based on the current inventory level self.last_update_t = self.env.now # update the last update time","title":"update_carry_cost"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Supplier","text":"Supplier(env: Environment, ID: str, name: str, node_type: str = 'supplier', capacity: float = 0.0, initial_level: float = 0.0, inventory_holding_cost: float = 0.0, raw_material: RawMaterial = None, **kwargs) Bases: Node The Supplier class represents a supplier in the supply network that continuously extracts raw materials whenever the inventory is not full. Each supplier is associated with a specific raw material and can have either finite or infinite inventory capacity. For finite suppliers, raw materials are extracted in batches based on the extraction quantity and extraction time specified by the instance of RawMaterial class. For infinite suppliers, inventory is considered unlimited. Parameters: env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 unique identifier for the supplier name ( str ) \u2013 name of the supplier node_type ( str , default: 'supplier' ) \u2013 type of the node (supplier/infinite_supplier) capacity ( float , default: 0.0 ) \u2013 maximum capacity of the inventory initial_level ( float , default: 0.0 ) \u2013 initial inventory level inventory_holding_cost ( float , default: 0.0 ) \u2013 inventory holding cost raw_material ( RawMaterial , default: None ) \u2013 raw material supplied by the supplier **kwargs \u2013 any additional keyword arguments for the Node class and logger Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary. raw_material ( RawMaterial ) \u2013 raw material supplied by the supplier sell_price ( float ) \u2013 selling price of the raw material inventory ( Inventory ) \u2013 inventory of the supplier inventory_drop ( Event ) \u2013 event to signal when inventory is dropped inventory_raised ( Event ) \u2013 event to signal when inventory is raised stats ( Statistics ) \u2013 statistics object for the supplier Methods: Name Description behavior Simulates the continuous raw material extraction process. Initialize the supplier object. Parameters: env ( Environment ) \u2013 simulation environment ID ( str ) \u2013 unique identifier for the supplier name ( str ) \u2013 name of the supplier node_type ( str , default: 'supplier' ) \u2013 type of the node (supplier/infinite_supplier) capacity ( float , default: 0.0 ) \u2013 maximum capacity of the inventory initial_level ( float , default: 0.0 ) \u2013 initial inventory level inventory_holding_cost ( float , default: 0.0 ) \u2013 inventory holding cost raw_material ( RawMaterial , default: None ) \u2013 raw material supplied by the supplier **kwargs \u2013 any additional keyword arguments for the Node class and logger Attributes: _info_keys ( list ) \u2013 list of keys to include in the info dictionary. raw_material ( RawMaterial ) \u2013 raw material supplied by the supplier sell_price ( float ) \u2013 selling price of the raw material inventory ( Inventory ) \u2013 inventory of the supplier inventory_drop ( Event ) \u2013 event to signal when inventory is dropped inventory_raised ( Event ) \u2013 event to signal when inventory is raised stats ( Statistics ) \u2013 statistics object for the supplier Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, node_type: str = \"supplier\", capacity: float = 0.0, initial_level: float = 0.0, inventory_holding_cost:float = 0.0, raw_material: RawMaterial = None, **kwargs) -> None: \"\"\" Initialize the supplier object. Parameters: env (simpy.Environment): simulation environment ID (str): unique identifier for the supplier name (str): name of the supplier node_type (str): type of the node (supplier/infinite_supplier) capacity (float): maximum capacity of the inventory initial_level (float): initial inventory level inventory_holding_cost (float): inventory holding cost raw_material (RawMaterial): raw material supplied by the supplier **kwargs: any additional keyword arguments for the Node class and logger Attributes: _info_keys (list): list of keys to include in the info dictionary. raw_material (RawMaterial): raw material supplied by the supplier sell_price (float): selling price of the raw material inventory (Inventory): inventory of the supplier inventory_drop (simpy.Event): event to signal when inventory is dropped inventory_raised (simpy.Event): event to signal when inventory is raised stats (Statistics): statistics object for the supplier Returns: None \"\"\" super().__init__(env=env,ID=ID,name=name,node_type=node_type,**kwargs) self._info_keys.extend([\"raw_material\", \"sell_price\"]) self.raw_material = raw_material # raw material supplied by the supplier self.sell_price = 0 if(self.raw_material): self.sell_price = self.raw_material.cost # selling price of the raw material if(self.node_type!=\"infinite_supplier\"): self.inventory = Inventory(env=self.env, capacity=capacity, initial_level=initial_level, node=self, holding_cost=inventory_holding_cost, replenishment_policy=None) self.inventory_drop = self.env.event() # event to signal when inventory is dropped self.inventory_raised = self.env.event() # signal to indicate that inventory has been raised if(self.raw_material): self.env.process(self.behavior()) # start the behavior process else: self.logger.logger.error(f\"{self.ID}:Raw material not provided for this supplier. Recreate it with a raw material.\") raise ValueError(\"Raw material not provided.\") else: self.inventory = Inventory(env=self.env, capacity=float('inf'), initial_level=float('inf'), node=self, holding_cost=inventory_holding_cost, replenishment_policy=None) self.stats = Statistics(self) setattr(self.stats,\"total_raw_materials_mined\",0) setattr(self.stats,\"total_material_cost\",0) self.stats._stats_keys.extend([\"total_raw_materials_mined\", \"total_material_cost\"])","title":"Supplier"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Supplier.behavior","text":"behavior() Supplier behavior: The supplier keeps extracting raw material whenever the inventory is not full. Assume that a supplier can extract a single type of raw material. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def behavior(self): \"\"\" Supplier behavior: The supplier keeps extracting raw material whenever the inventory is not full. Assume that a supplier can extract a single type of raw material. Parameters: None Attributes: None Returns: None \"\"\" while True: if(self.inventory.inventory.level < self.inventory.inventory.capacity): # check if the inventory is not full mined_quantity = self.raw_material.extraction_quantity if((self.inventory.inventory.level+self.raw_material.extraction_quantity)>self.inventory.inventory.capacity): # check if the inventory can accommodate the extracted quantity mined_quantity = self.inventory.inventory.capacity - self.inventory.inventory.level # update statistics self.inventory.put(mined_quantity) self.stats.update_stats(total_raw_materials_mined=mined_quantity, total_material_cost=mined_quantity*self.raw_material.mining_cost) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Raw material mined/extracted. Inventory level:{self.inventory.inventory.level}\") yield self.env.timeout(self.raw_material.extraction_time) else: yield self.env.timeout(1) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}: Inventory level:{self.inventory.inventory.level}\") # log every day/period inventory level","title":"behavior"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InventoryNode","text":"InventoryNode(env: Environment, ID: str, name: str, node_type: str, capacity: float, initial_level: float, inventory_holding_cost: float, replenishment_policy: InventoryReplenishment, policy_param: dict, product_sell_price: float, product_buy_price: float, inventory_type: str = 'non-perishable', shelf_life: float = 0.0, manufacture_date: callable = None, product: Product = None, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = 'fixed', **kwargs) Bases: Node The InventoryNode class represents an inventory management node in the supply network, such as a retailer, a store, a warehouse, or distributor. It manages inventory levels, replenishment policies, supplier selection, and order processing dynamically. The node can handle both perishable and non-perishable inventories and supports automatic replenishment using various replenishment policies. The node can also interact with multiple supplier links and selects suppliers based on the configured selection policy. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the node. name ( str ) \u2013 Name of the inventory node. node_type ( str ) \u2013 Type of the inventory node (e.g., retailer or distributor). capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. inventory_holding_cost ( float ) \u2013 Inventory holding cost per unit. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product_sell_price ( float ) \u2013 Selling price of the product. product_buy_price ( float ) \u2013 Buying price of the product. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product for perishable items. manufacture_date ( callable , default: None ) \u2013 Function to model manufacturing date (used for perishable inventories). product ( Product , default: None ) \u2013 Product managed by the inventory node. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Mode for supplier selection (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object. inventory ( Inventory ) \u2013 Inventory object managing stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. manufacture_date ( callable ) \u2013 Manufacturing date generation function. sell_price ( float ) \u2013 Selling price of the product. buy_price ( float ) \u2013 Buying price of the product. product ( Product ) \u2013 Product managed by the node. suppliers ( list ) \u2013 List of supplier links connected to this node. ongoing_order ( bool ) \u2013 Indicates if an order is currently in process. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for this node. Methods: Name Description process_order Places an order with the selected supplier and updates inventory upon delivery. Initialize the inventory node object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the node. name ( str ) \u2013 Name of the inventory node. node_type ( str ) \u2013 Type of the inventory node (e.g., retailer or distributor). capacity ( float ) \u2013 Maximum capacity of the inventory. initial_level ( float ) \u2013 Initial inventory level. inventory_holding_cost ( float ) \u2013 Inventory holding cost per unit. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product_sell_price ( float ) \u2013 Selling price of the product. product_buy_price ( float ) \u2013 Buying price of the product. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product for perishable items. manufacture_date ( callable , default: None ) \u2013 Function to model manufacturing date (used for perishable inventories). product ( Product , default: None ) \u2013 Product managed by the inventory node. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Mode for supplier selection (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object. inventory ( Inventory ) \u2013 Inventory object managing stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. manufacture_date ( callable ) \u2013 Manufacturing date generation function. sell_price ( float ) \u2013 Selling price of the product. buy_price ( float ) \u2013 Buying price of the product. product ( Product ) \u2013 Product managed by the node. suppliers ( list ) \u2013 List of supplier links connected to this node. ongoing_order ( bool ) \u2013 Indicates if an order is currently in process. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for this node. Returns: None \u2013 None Behavior The inventory node stocks the product in inventory to make it available to the consumer node or demand node (end customer). It orders product from its supplier node to maintain the right inventory levels according to the replenishment policy. The inventory node can have multiple suppliers. It chooses a supplier based on the specified supplier selection policy. The product buy and sell prices are set during initialization. The inventory node is expected to sell the product at a higher price than the buy price, but this is user-configured. Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, node_type: str, capacity: float, initial_level: float, inventory_holding_cost:float, replenishment_policy:InventoryReplenishment, policy_param: dict, product_sell_price: float, product_buy_price: float, inventory_type:str = \"non-perishable\", shelf_life:float = 0.0, manufacture_date:callable = None, product:Product = None, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = \"fixed\", **kwargs) -> None: \"\"\" Initialize the inventory node object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique identifier for the node. name (str): Name of the inventory node. node_type (str): Type of the inventory node (e.g., retailer or distributor). capacity (float): Maximum capacity of the inventory. initial_level (float): Initial inventory level. inventory_holding_cost (float): Inventory holding cost per unit. replenishment_policy (InventoryReplenishment): Replenishment policy object for the inventory. policy_param (dict): Parameters for the replenishment policy. product_sell_price (float): Selling price of the product. product_buy_price (float): Buying price of the product. inventory_type (str): Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life (float): Shelf life of the product for perishable items. manufacture_date (callable): Function to model manufacturing date (used for perishable inventories). product (Product): Product managed by the inventory node. supplier_selection_policy (SupplierSelectionPolicy): Supplier selection policy class. supplier_selection_mode (str): Mode for supplier selection (default is \"fixed\"). **kwargs: Additional keyword arguments for the Node class and logger. Attributes: _info_keys (list): List of keys to include in the info dictionary. replenishment_policy (InventoryReplenishment): Replenishment policy object. inventory (Inventory): Inventory object managing stock. inventory_drop (simpy.Event): Event triggered when inventory drops. inventory_raised (simpy.Event): Event triggered when inventory is replenished. manufacture_date (callable): Manufacturing date generation function. sell_price (float): Selling price of the product. buy_price (float): Buying price of the product. product (Product): Product managed by the node. suppliers (list): List of supplier links connected to this node. ongoing_order (bool): Indicates if an order is currently in process. selection_policy (SupplierSelectionPolicy): Supplier selection policy object. stats (Statistics): Statistics tracking object for this node. Returns: None Behavior: The inventory node stocks the product in inventory to make it available to the consumer node or demand node (end customer). It orders product from its supplier node to maintain the right inventory levels according to the replenishment policy. The inventory node can have multiple suppliers. It chooses a supplier based on the specified supplier selection policy. The product buy and sell prices are set during initialization. The inventory node is expected to sell the product at a higher price than the buy price, but this is user-configured. \"\"\" super().__init__(env=env,ID=ID,name=name,node_type=node_type,**kwargs) validate_non_negative(\"Product Sell Price\", product_sell_price) validate_non_negative(\"Product Buy Price\", product_buy_price) self._info_keys.extend([\"sell_price\", \"buy_price\", \"ongoing_order\", \"selection_policy\"]) self.replenishment_policy = None if(replenishment_policy): self.replenishment_policy = replenishment_policy(env = self.env, node = self, params = policy_param) self.env.process(self.replenishment_policy.run()) self.inventory = Inventory(env=self.env, capacity=capacity, initial_level=initial_level, node=self, inv_type=inventory_type, holding_cost=inventory_holding_cost, replenishment_policy=self.replenishment_policy, shelf_life=shelf_life) self.inventory_drop = self.env.event() # event to signal when inventory is dropped self.inventory_raised = self.env.event() # signal to indicate that inventory has been raised self.manufacture_date = manufacture_date self.sell_price = product_sell_price # set the sell price of the product self.buy_price = product_buy_price # set the buy price of the product if product is not None: self.product = copy.deepcopy(product) # product that the inventory node sells self.product.sell_price = product_sell_price self.product.buy_price = product_buy_price # set the buy price of the product to the product buy price self.suppliers = [] self.ongoing_order = False # flag to check if the order is placed self.selection_policy = supplier_selection_policy(self,supplier_selection_mode) self.stats = Statistics(self, periodic_update=True, period=1) # create a statistics object for the inventory node","title":"InventoryNode"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.InventoryNode.process_order","text":"process_order(supplier, reorder_quantity) Place an order for the product from the suppliers. Parameters: supplier ( Link ) \u2013 The supplier link from which the order is placed. reorder_quantity ( float ) \u2013 The quantity of the product to reorder. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def process_order(self, supplier, reorder_quantity): \"\"\" Place an order for the product from the suppliers. Parameters: supplier (Link): The supplier link from which the order is placed. reorder_quantity (float): The quantity of the product to reorder. Attributes: None Returns: None \"\"\" if(self.inventory.on_hand + reorder_quantity > self.inventory.inventory.capacity): # check if the inventory can accommodate the reordered quantity reorder_quantity = self.inventory.inventory.capacity - self.inventory.on_hand # if not, adjust reorder quantity to order only what can fit if reorder_quantity <= 0: self.ongoing_order = False return # no need to place an order if reorder quantity is zero if supplier.source.inventory.inventory.level < reorder_quantity: # check if the supplier is able to fulfill the order, record shortage shortage = reorder_quantity - supplier.source.inventory.inventory.level supplier.source.stats.update_stats(orders_shortage=[1,shortage], backorder=[1,reorder_quantity]) if(not supplier.source.inventory_drop.triggered): supplier.source.inventory_drop.succeed() # signal that inventory has been dropped (since backorder is created) if(supplier.source.node_status == \"active\"): self.stats.update_stats(demand_placed=[1,reorder_quantity],transportation_cost=supplier.cost) supplier.source.stats.update_stats(demand_received=[1,reorder_quantity]) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Replenishing inventory from supplier:{supplier.source.name}, order placed for {reorder_quantity} units.\") event, man_date_ls = supplier.source.inventory.get(reorder_quantity) self.inventory.on_hand += reorder_quantity yield event self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:shipment in transit from supplier:{supplier.source.name}.\") # log the shipment lead_time = supplier.lead_time() # get the lead time from the supplier validate_non_negative(name=\"lead_time\", value=lead_time) # check if lead_time is non-negative yield self.env.timeout(lead_time) # lead time for the order if(man_date_ls): for ele in man_date_ls: # get manufacturing date from the supplier self.inventory.put(ele[1],ele[0]) elif(self.inventory.inv_type==\"perishable\"): # if self inventory is perishable but manufacture date is not provided if(self.manufacture_date): # calculate the manufacturing date using the function if provided self.inventory.put(reorder_quantity,self.manufacture_date(self.env.now)) else: # else put the product in the inventory with current time as manufacturing date self.inventory.put(reorder_quantity,self.env.now) else: self.inventory.put(reorder_quantity) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Inventory replenished. reorder_quantity={reorder_quantity}, Inventory levels:{self.inventory.inventory.level}\") self.stats.update_stats(fulfillment_received=[1,reorder_quantity],inventory_spend_cost=reorder_quantity*self.buy_price) supplier.source.stats.update_stats(demand_fulfilled=[1,reorder_quantity]) else: self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Supplier:{supplier.source.name} is disrupted. Order not placed.\") self.ongoing_order = False","title":"process_order"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Manufacturer","text":"Manufacturer(env: Environment, ID: str, name: str, capacity: float, initial_level: float, inventory_holding_cost: float, product_sell_price: float, replenishment_policy: InventoryReplenishment, policy_param: dict, product: Product = None, inventory_type: str = 'non-perishable', shelf_life: float = 0.0, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = 'fixed', **kwargs) Bases: Node The Manufacturer class models a production unit in the supply network that consumes raw materials to manufacture finished products. It maintains separate inventories for raw materials and finished goods, applies replenishment policies to the product inventory, and places orders to suppliers dynamically. The manufacturer can be connected to multiple suppliers and automatically produces products based on raw material availability. It continuously updates real-time statistics such as production volume, manufacturing cost, and revenue. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the manufacturer. name ( str ) \u2013 Name of the manufacturer. capacity ( float ) \u2013 Maximum capacity of the finished product inventory. initial_level ( float ) \u2013 Initial inventory level for finished products. inventory_holding_cost ( float ) \u2013 Holding cost per unit for finished products. product_sell_price ( float ) \u2013 Selling price per unit of the finished product. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product ( Product , default: None ) \u2013 Product manufactured by the manufacturer. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Supplier selection mode (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. inventory ( Inventory ) \u2013 Inventory object managing finished product stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. product ( Product ) \u2013 Product manufactured by the manufacturer. suppliers ( list ) \u2013 List of supplier links connected to this manufacturer. sell_price ( float ) \u2013 Selling price per unit of the product. production_cycle ( bool ) \u2013 Indicates whether the production cycle is currently active. raw_inventory_counts ( dict ) \u2013 Inventory levels of raw materials by raw material ID. ongoing_order_raw ( dict ) \u2013 Indicates whether a raw material order is currently in progress. ongoing_order ( bool ) \u2013 Indicates whether a product order is currently in progress. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for the manufacturer. Methods: Name Description manufacture_product Manufactures the product by consuming raw materials and updating product inventory. behavior Main behavior loop that checks inventory and triggers production if raw materials are available. process_order Places an order for raw materials based on the quantity of products to be manufactured. process_order_raw Places an individual order for a specific raw material from a supplier. Behavior The manufacturer continuously monitors raw material inventory levels and initiates production when raw materials are available. Finished products are added to the inventory upon completion of a manufacturing cycle. If raw materials are insufficient, the manufacturer places replenishment orders with connected suppliers. Assumptions The manufacturer produces only a single type of product. Separate inventories are maintained for raw materials and finished products. Only the finished product inventory is actively monitored by the replenishment policy. Raw material inventories are replenished based on product inventory requirements. The raw material inventory is initially empty. Initialize the manufacturer object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the manufacturer. name ( str ) \u2013 Name of the manufacturer. capacity ( float ) \u2013 Maximum capacity of the finished product inventory. initial_level ( float ) \u2013 Initial inventory level for finished products. inventory_holding_cost ( float ) \u2013 Holding cost per unit for finished products. product_sell_price ( float ) \u2013 Selling price per unit of the finished product. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. policy_param ( dict ) \u2013 Parameters for the replenishment policy. product ( Product , default: None ) \u2013 Product manufactured by the manufacturer. inventory_type ( str , default: 'non-perishable' ) \u2013 Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life ( float , default: 0.0 ) \u2013 Shelf life of the product. supplier_selection_policy ( SupplierSelectionPolicy , default: SelectFirst ) \u2013 Supplier selection policy class. supplier_selection_mode ( str , default: 'fixed' ) \u2013 Supplier selection mode (default is \"fixed\"). **kwargs \u2013 Additional keyword arguments for the Node class and logger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. replenishment_policy ( InventoryReplenishment ) \u2013 Replenishment policy object for the product inventory. inventory ( Inventory ) \u2013 Inventory object managing finished product stock. inventory_drop ( Event ) \u2013 Event triggered when inventory drops. inventory_raised ( Event ) \u2013 Event triggered when inventory is replenished. product ( Product ) \u2013 Product manufactured by the manufacturer. suppliers ( list ) \u2013 List of supplier links connected to this manufacturer. sell_price ( float ) \u2013 Selling price per unit of the product. production_cycle ( bool ) \u2013 Indicates whether the production cycle is currently active. raw_inventory_counts ( dict ) \u2013 Inventory levels of raw materials by raw material ID. ongoing_order_raw ( dict ) \u2013 Indicates whether a raw material order is currently in progress. ongoing_order ( bool ) \u2013 Indicates whether a product order is currently in progress. selection_policy ( SupplierSelectionPolicy ) \u2013 Supplier selection policy object. stats ( Statistics ) \u2013 Statistics tracking object for the manufacturer. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, capacity: float, initial_level: float, inventory_holding_cost: float, product_sell_price: float, replenishment_policy: InventoryReplenishment, policy_param: dict, product: Product = None, inventory_type: str = \"non-perishable\", shelf_life: float = 0.0, supplier_selection_policy: SupplierSelectionPolicy = SelectFirst, supplier_selection_mode: str = \"fixed\", **kwargs) -> None: \"\"\" Initialize the manufacturer object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique identifier for the manufacturer. name (str): Name of the manufacturer. capacity (float): Maximum capacity of the finished product inventory. initial_level (float): Initial inventory level for finished products. inventory_holding_cost (float): Holding cost per unit for finished products. product_sell_price (float): Selling price per unit of the finished product. replenishment_policy (InventoryReplenishment): Replenishment policy object for the product inventory. policy_param (dict): Parameters for the replenishment policy. product (Product): Product manufactured by the manufacturer. inventory_type (str): Type of inventory (\"non-perishable\" or \"perishable\"). shelf_life (float): Shelf life of the product. supplier_selection_policy (SupplierSelectionPolicy): Supplier selection policy class. supplier_selection_mode (str): Supplier selection mode (default is \"fixed\"). **kwargs: Additional keyword arguments for the Node class and logger. Attributes: _info_keys (list): List of keys to include in the info dictionary. replenishment_policy (InventoryReplenishment): Replenishment policy object for the product inventory. inventory (Inventory): Inventory object managing finished product stock. inventory_drop (simpy.Event): Event triggered when inventory drops. inventory_raised (simpy.Event): Event triggered when inventory is replenished. product (Product): Product manufactured by the manufacturer. suppliers (list): List of supplier links connected to this manufacturer. sell_price (float): Selling price per unit of the product. production_cycle (bool): Indicates whether the production cycle is currently active. raw_inventory_counts (dict): Inventory levels of raw materials by raw material ID. ongoing_order_raw (dict): Indicates whether a raw material order is currently in progress. ongoing_order (bool): Indicates whether a product order is currently in progress. selection_policy (SupplierSelectionPolicy): Supplier selection policy object. stats (Statistics): Statistics tracking object for the manufacturer. Returns: None \"\"\" super().__init__(env=env,ID=ID,name=name,node_type=\"manufacturer\",**kwargs) if product == None: global_logger.logger.error(\"Product not provided for the manufacturer.\") raise ValueError(\"Product not provided for the manufacturer.\") elif not isinstance(product, Product): raise ValueError(\"Invalid product type. Expected a Product instance.\") validate_positive(\"Product Sell Price\", product_sell_price) self._info_keys.extend([\"replenishment_policy\", \"product_sell_price\"]) self.replenishment_policy = None if(replenishment_policy): self.replenishment_policy = replenishment_policy(env = self.env, node = self, params = policy_param) self.env.process(self.replenishment_policy.run()) self.inventory = Inventory(env=self.env, capacity=capacity, initial_level=initial_level, node=self, inv_type=inventory_type, holding_cost=inventory_holding_cost, replenishment_policy=self.replenishment_policy, shelf_life=shelf_life) self.inventory_drop = self.env.event() # event to signal when inventory is dropped self.inventory_raised = self.env.event() # signal to indicate that inventory has been raised self.product = product # product manufactured by the manufacturer self.suppliers = [] self.product.sell_price = product_sell_price self.sell_price = product_sell_price # set the sell price of the product self.production_cycle = False # production cycle status self.raw_inventory_counts = {} # dictionary to store inventory counts for raw products inventory self.ongoing_order_raw = {} # dictionary to store order status self.ongoing_order = False # order status for the product if(self.product.buy_price <= 0): # if the product buy price is not given, calculate it self.product.buy_price = self.product.manufacturing_cost for raw_material in self.product.raw_materials: self.product.buy_price += raw_material[0].cost * raw_material[1] # calculate total cost of the product (per unit) self.env.process(self.behavior()) # start the behavior process self.selection_policy = supplier_selection_policy(self,supplier_selection_mode) self.stats = Statistics(self, periodic_update=True, period=1) # create a statistics object for the manufacturer setattr(self.stats,\"total_products_manufactured\",0) # adding specific statistics for the manufacturer setattr(self.stats,\"total_manufacturing_cost\",0) # adding specific statistics for the manufacturer self.stats._stats_keys.extend([\"total_products_manufactured\", \"total_manufacturing_cost\"])","title":"Manufacturer"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Manufacturer.manufacture_product","text":"manufacture_product() Manufacture the product. This method handles the production of the product, consuming raw materials and adding the manufactured product to the inventory. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def manufacture_product(self): \"\"\" Manufacture the product. This method handles the production of the product, consuming raw materials and adding the manufactured product to the inventory. Parameters: None Attributes: None Returns: None \"\"\" max_producible_units = self.product.batch_size for raw_material in self.product.raw_materials: raw_mat_id = raw_material[0].ID required_amount = raw_material[1] current_raw_material_level = self.raw_inventory_counts[raw_mat_id] max_producible_units = min(max_producible_units,int(current_raw_material_level/required_amount)) if((self.inventory.inventory.level + max_producible_units)>self.inventory.inventory.capacity): # check if the inventory can accommodate the maximum producible units max_producible_units = self.inventory.inventory.capacity - self.inventory.inventory.level if(max_producible_units>0): self.inventory.on_hand += max_producible_units # update the on-hand inventory level self.production_cycle = True # produce the product for raw_material in self.product.raw_materials: # consume raw materials raw_mat_id = raw_material[0].ID required_amount = raw_material[1] self.raw_inventory_counts[raw_mat_id] -= raw_material[1]*max_producible_units yield self.env.timeout(self.product.manufacturing_time) # take manufacturing time to produce the product self.inventory.put(max_producible_units, manufacturing_date=self.env.now) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}: {max_producible_units} units manufactured.\") self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}: Product inventory levels:{self.inventory.inventory.level}\") self.stats.update_stats(total_products_manufactured=max_producible_units, total_manufacturing_cost=max_producible_units*self.product.manufacturing_cost) # update statistics self.production_cycle = False","title":"manufacture_product"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Manufacturer.behavior","text":"behavior() The manufacturer consumes raw materials and produces the product if raw materials are available. It maintains inventory levels for both raw materials and the product. Depending on the replenishment policy for product inventory, manufacturer decides when to replenish the raw material inventory. The manufacturer can be connected to multiple suppliers. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def behavior(self): \"\"\" The manufacturer consumes raw materials and produces the product if raw materials are available. It maintains inventory levels for both raw materials and the product. Depending on the replenishment policy for product inventory, manufacturer decides when to replenish the raw material inventory. The manufacturer can be connected to multiple suppliers. Parameters: None Attributes: None Returns: None \"\"\" if(len(self.suppliers)==0): self.logger.logger.error(\"No suppliers connected to the manufacturer.\") raise ValueError(\"No suppliers connected to the manufacturer.\") if(len(self.suppliers)>0): # create an inventory for storing raw materials as a dictionary. Key: raw material ID, Value: inventory level for supplier in self.suppliers: # iterate over supplier links if(supplier.source.raw_material is None): # check if the supplier has a raw material self.logger.logger.error(f\"{self.ID}:Supplier {supplier.source.ID} does not have a raw material. Please provide a raw material for the supplier.\") raise ValueError(f\"Supplier {supplier.source.ID} does not have a raw material.\") self.raw_inventory_counts[supplier.source.raw_material.ID] = 0 # store initial levels self.ongoing_order_raw[supplier.source.raw_material.ID] = False # store order status if(len(self.suppliers)<len(self.product.raw_materials)): self.logger.logger.warning(f\"{self.ID}: {self.name}: The number of suppliers are less than the number of raw materials required to manufacture the product! This leads to no products being manufactured.\") while True: # behavior of the manufacturer: consume raw materials, produce the product, and put the product in the inventory if(len(self.suppliers)>=len(self.product.raw_materials)): # check if required number of suppliers are connected if(not self.production_cycle): self.env.process(self.manufacture_product()) # produce the product yield self.env.timeout(1)","title":"behavior"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Manufacturer.process_order_raw","text":"process_order_raw(raw_mat_id, supplier, reorder_quantity) Place an order for given raw material from the given supplier for replenishment. Parameters: supplier ( Link ) \u2013 The supplier link from which the order is placed. reorder_quantity ( float ) \u2013 The quantity of the raw material to reorder. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def process_order_raw(self, raw_mat_id, supplier, reorder_quantity): \"\"\" Place an order for given raw material from the given supplier for replenishment. Parameters: supplier (Link): The supplier link from which the order is placed. reorder_quantity (float): The quantity of the raw material to reorder. Attributes: None Returns: None \"\"\" if supplier.source.inventory.inventory.level < reorder_quantity: # check if the supplier is able to fulfill the order, record shortage shortage = reorder_quantity - supplier.source.inventory.inventory.level supplier.source.stats.update_stats(orders_shortage=[1,shortage], backorder=[1,reorder_quantity]) if(supplier.source.node_status == \"active\"): # check if the supplier is active and has enough inventory if(self.raw_inventory_counts[raw_mat_id]>= reorder_quantity): # dont order if enough inventory is available (reorder_quantity depends on the number of product units that needs to be manufactured, there is no capcacity defined for raw material inventory) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Sufficient raw material inventory for {supplier.source.raw_material.name}, no order placed. Current inventory level: {self.raw_inventory_counts}.\") self.ongoing_order_raw[raw_mat_id] = False self.ongoing_order = False # set the order status to False return self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Replenishing raw material:{supplier.source.raw_material.name} from supplier:{supplier.source.ID}, order placed for {reorder_quantity} units. Current inventory level: {self.raw_inventory_counts}.\") event, man_date_ls = supplier.source.inventory.get(reorder_quantity) supplier.source.stats.update_stats(demand_received=[1,reorder_quantity]) # update the supplier statistics for demand received yield event self.stats.update_stats(demand_placed=[1,reorder_quantity],transportation_cost=supplier.cost) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:shipment in transit from supplier:{supplier.source.name}.\") lead_time = supplier.lead_time() # get the lead time from the supplier validate_non_negative(name=\"lead_time\", value=lead_time) # check if lead_time is non-negative yield self.env.timeout(lead_time) # lead time for the order self.stats.update_stats(fulfillment_received=[1,reorder_quantity],inventory_spend_cost=reorder_quantity*supplier.source.sell_price) supplier.source.stats.update_stats(demand_fulfilled=[1,reorder_quantity]) # update the supplier statistics for demand fulfilled self.ongoing_order_raw[raw_mat_id] = False self.raw_inventory_counts[raw_mat_id] += reorder_quantity self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Order received from supplier:{supplier.source.name}, inventory levels: {self.raw_inventory_counts}\") self.ongoing_order = False # set the order status to False else: self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Supplier:{supplier.source.name} is disrupted.\") yield self.env.timeout(1) # wait for 1 time unit before checking again self.ongoing_order_raw[raw_mat_id] = False","title":"process_order_raw"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Manufacturer.process_order","text":"process_order(supplier, reorder_quantity) Place an order for raw materials and replenish raw materials inventory. Parameters: supplier ( Link ) \u2013 Supplier link reorder_quantity ( float ) \u2013 The quantity of the raw material to reorder. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def process_order(self, supplier, reorder_quantity): \"\"\" Place an order for raw materials and replenish raw materials inventory. Parameters: supplier (Link): Supplier link reorder_quantity (float): The quantity of the raw material to reorder. Attributes: None Returns: None \"\"\" self.ongoing_order = True # set the order status to True if(self.inventory.on_hand + reorder_quantity > self.inventory.inventory.capacity): # check if the inventory can accommodate the reordered quantity reorder_quantity = self.inventory.inventory.capacity - self.inventory.on_hand # if not, adjust reorder quantity to order only what can fit if reorder_quantity <= 0: self.ongoing_order = False return # no need to place an order if reorder quantity is zero for raw_mat in self.product.raw_materials: # place order for all raw materials required to produce the product raw_mat_id = raw_mat[0].ID raw_mat_reorder_sz = raw_mat[1]*reorder_quantity for supplier in self.suppliers: if(supplier.source.raw_material.ID == raw_mat_id and self.ongoing_order_raw[raw_mat_id] == False): # check if the supplier has the raw material and order is not already placed self.ongoing_order_raw[raw_mat_id] = True # set the order status to True self.env.process(self.process_order_raw(raw_mat_id, supplier, raw_mat_reorder_sz)) # place the order for the raw material yield self.env.timeout(1) # wait for the order to be placed","title":"process_order"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Demand","text":"Demand(env: Environment, ID: str, name: str, order_arrival_model: callable, order_quantity_model: callable, demand_node: Node, tolerance: float = 0.0, order_min_split_ratio: float = 1.0, delivery_cost: callable = lambda: 0, lead_time: callable = lambda: 0, consume_available: bool = False, **kwargs) Bases: Node The Demand class represents a demand node that generates product orders within the supply network. It models dynamic demand patterns using user-defined functions for order arrival times and order quantities, and manages customer tolerance for waiting in case of product unavailability. The demand node automatically places customer orders at configurable intervals and can handle situations where the requested quantity is not immediately available. Customers can either wait (if tolerance is set) or leave the system unfulfilled. The class supports: Customizable lead time and delivery cost per order, Dynamic order splitting based on the minimum split ratio, Backorder management and real-time inventory check. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the demand node. name ( str ) \u2013 Name of the demand node. order_arrival_model ( callable ) \u2013 Function that models inter-arrival times between customer orders. order_quantity_model ( callable ) \u2013 Function that models the quantity per customer order. demand_node ( Node ) \u2013 Upstream node from which the demand node sources products. tolerance ( float , default: 0.0 ) \u2013 Maximum time customers are willing to wait if required quantity is unavailable. order_min_split_ratio ( float , default: 1.0 ) \u2013 Minimum allowable fraction of the order that can be delivered in split deliveries. delivery_cost ( callable , default: lambda: 0 ) \u2013 Function that models the delivery cost per order. lead_time ( callable , default: lambda: 0 ) \u2013 Function that models the delivery lead time per order. consume_available ( bool , default: False ) \u2013 If True, the demand node consumes available inventory immediately and leaves. **kwargs \u2013 Additional keyword arguments for Node and GlobalLogger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. order_arrival_model ( callable ) \u2013 Function defining the order arrival process. order_quantity_model ( callable ) \u2013 Function defining the order quantity distribution. demand_node ( Node ) \u2013 Upstream node supplying the demand. customer_tolerance ( float ) \u2013 Maximum waiting time allowed for customer orders. delivery_cost ( callable ) \u2013 Delivery cost function for each order. lead_time ( callable ) \u2013 Delivery lead time function for each order. min_split ( float ) \u2013 Minimum allowed split ratio for partially fulfilled orders. consume_available ( bool ) \u2013 If True, partial fulfillment is allowed and available inventory is consumed immediately. stats ( Statistics ) \u2013 Tracks various performance metrics like demand placed, fulfilled, and shortages. Methods: Name Description _process_delivery Handles the delivery process, including lead time and delivery cost updates. wait_for_order Waits for required units based on customer tolerance when immediate fulfillment is not possible. customer Simulates customer order placement and fulfillment behavior. behavior Generates continuous customer demand based on the arrival and quantity models. Behavior The demand node generates customer orders at random intervals and quantities using the specified arrival and quantity models. If the upstream inventory can satisfy the order, delivery is processed immediately. If not, the customer may leave immediately (if tolerance is zero) else, the customer waits for the order to be fulfilled within their tolerance time, possibly accepting partial deliveries if a split ratio is allowed. If the tolerance is exceeded, the unmet demand is recorded as a shortage. Assumptions Customer orders arrive following the provided stochastic arrival model. Order quantities follow the specified stochastic quantity model. Customers may wait for the fulfillment of their orders up to the defined tolerance time. Customers can accept split deliveries based on the minimum split ratio. If customer tolerance is zero, customer returns without waiting for fulfillment. Delivery cost and lead time are sampled dynamically for each order (if specified). The connected upstream node must not be a supplier; it should typically be a retailer or distributor node. Initialize the demand node object. Parameters: env ( Environment ) \u2013 Simulation environment. ID ( str ) \u2013 Unique identifier for the demand node. name ( str ) \u2013 Name of the demand node. order_arrival_model ( callable ) \u2013 Function that models inter-arrival times between customer orders. order_quantity_model ( callable ) \u2013 Function that models the quantity per customer order. demand_node ( Node ) \u2013 Upstream node from which the demand node sources products. tolerance ( float , default: 0.0 ) \u2013 Maximum time customers are willing to wait if required quantity is unavailable. order_min_split_ratio ( float , default: 1.0 ) \u2013 Minimum allowable fraction of the order that can be delivered in split deliveries. delivery_cost ( callable , default: lambda: 0 ) \u2013 Function that models the delivery cost per order. lead_time ( callable , default: lambda: 0 ) \u2013 Function that models the delivery lead time per order. consume_available ( bool , default: False ) \u2013 If True, the demand node consumes available inventory immediately and leaves. **kwargs \u2013 Additional keyword arguments for Node and GlobalLogger. Attributes: _info_keys ( list ) \u2013 List of keys to include in the info dictionary. order_arrival_model ( callable ) \u2013 Function defining the order arrival process. order_quantity_model ( callable ) \u2013 Function defining the order quantity distribution. demand_node ( Node ) \u2013 Upstream node supplying the demand. customer_tolerance ( float ) \u2013 Maximum waiting time allowed for customer orders. delivery_cost ( callable ) \u2013 Delivery cost function for each order. lead_time ( callable ) \u2013 Delivery lead time function for each order. min_split ( float ) \u2013 Minimum allowed split ratio for partially fulfilled orders. consume_available ( bool ) \u2013 If True, partial fulfillment is allowed and available inventory is consumed immediately. stats ( Statistics ) \u2013 Tracks various performance metrics like demand placed, fulfilled, and shortages. Returns: None \u2013 None Source code in src/SupplyNetPy/Components/core.py def __init__(self, env: simpy.Environment, ID: str, name: str, order_arrival_model: callable, order_quantity_model: callable, demand_node: Node, tolerance: float = 0.0, order_min_split_ratio: float = 1.0, delivery_cost: callable = lambda: 0, lead_time: callable = lambda: 0, consume_available: bool = False, **kwargs) -> None: \"\"\" Initialize the demand node object. Parameters: env (simpy.Environment): Simulation environment. ID (str): Unique identifier for the demand node. name (str): Name of the demand node. order_arrival_model (callable): Function that models inter-arrival times between customer orders. order_quantity_model (callable): Function that models the quantity per customer order. demand_node (Node): Upstream node from which the demand node sources products. tolerance (float): Maximum time customers are willing to wait if required quantity is unavailable. order_min_split_ratio (float): Minimum allowable fraction of the order that can be delivered in split deliveries. delivery_cost (callable): Function that models the delivery cost per order. lead_time (callable): Function that models the delivery lead time per order. consume_available (bool): If True, the demand node consumes available inventory immediately and leaves. **kwargs: Additional keyword arguments for Node and GlobalLogger. Attributes: _info_keys (list): List of keys to include in the info dictionary. order_arrival_model (callable): Function defining the order arrival process. order_quantity_model (callable): Function defining the order quantity distribution. demand_node (Node): Upstream node supplying the demand. customer_tolerance (float): Maximum waiting time allowed for customer orders. delivery_cost (callable): Delivery cost function for each order. lead_time (callable): Delivery lead time function for each order. min_split (float): Minimum allowed split ratio for partially fulfilled orders. consume_available (bool): If True, partial fulfillment is allowed and available inventory is consumed immediately. stats (Statistics): Tracks various performance metrics like demand placed, fulfilled, and shortages. Returns: None \"\"\" if order_arrival_model is None or order_quantity_model is None: raise ValueError(\"Order arrival and quantity models cannot be None.\") if not callable(order_arrival_model): order_arrival_model = lambda val=order_arrival_model: val # convert into callable if not callable(order_quantity_model): order_quantity_model = lambda val=order_quantity_model: val # convert into callable if not callable(delivery_cost): delivery_cost = lambda val=delivery_cost: val # convert into callable if not callable(lead_time): lead_time = lambda val=lead_time: val # convert into callable if demand_node is None or \"supplier\" in demand_node.node_type: raise ValueError(\"Demand node must be a valid non-supplier node.\") validate_non_negative(\"Customer tolerance\", tolerance) validate_positive(\"Order Min Split Ratio\", order_min_split_ratio) if order_min_split_ratio > 1: self.logger.logger.error(\"Order Min Split Ratio is greater than 1. It will be set to 1.\") raise ValueError(\"Order Min Split Ratio must be in the range [0, 1].\") validate_number(name=\"order_time\", value=order_arrival_model()) validate_number(name=\"order_quantity\", value=order_quantity_model()) validate_number(name=\"delivery_cost\", value=delivery_cost()) # check if delivery_cost is a number validate_number(name=\"lead_time\", value=lead_time()) # check if lead_time is a number super().__init__(env=env,ID=ID,name=name,node_type=\"demand\",**kwargs) self._info_keys.extend([\"order_arrival_model\", \"order_quantity_model\", \"demand_node\", \"customer_tolerance\", \"delivery_cost\", \"lead_time\"]) self.order_arrival_model = order_arrival_model self.order_quantity_model = order_quantity_model self.demand_node = demand_node self.customer_tolerance = tolerance self.delivery_cost = delivery_cost self.lead_time = lead_time self.min_split = order_min_split_ratio self.consume_available = consume_available # if True, the demand node consumes available inventory immediately and leaves self.env.process(self.behavior()) self.stats = Statistics(self, periodic_update=True, period=1) # create a statistics object for the demand node","title":"Demand"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Demand.wait_for_order","text":"wait_for_order(customer_id, order_quantity) Wait for the required number of units based on customer tolerance. If the customer tolerance is infinite, the method waits until the order is fulfilled. Otherwise, it waits for the specified tolerance time and updates the unsatisfied demand if the order is not fulfilled. Parameters: order_quantity ( float ) \u2013 The quantity of the product ordered. customer_id ( int ) \u2013 Customer ID for logging purposes. Attributes: customer_id ( int ) \u2013 Customer ID for logging purposes. order_quantity ( float ) \u2013 The quantity of the product ordered. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def wait_for_order(self,customer_id,order_quantity): \"\"\" Wait for the required number of units based on customer tolerance. If the customer tolerance is infinite, the method waits until the order is fulfilled. Otherwise, it waits for the specified tolerance time and updates the unsatisfied demand if the order is not fulfilled. Parameters: order_quantity (float): The quantity of the product ordered. customer_id (int): Customer ID for logging purposes. Attributes: customer_id (int): Customer ID for logging purposes. order_quantity (float): The quantity of the product ordered. Returns: None \"\"\" self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}:Order quantity:{order_quantity} not available! Order will be split if split ratio is provided.\") self.demand_node.stats.update_stats(backorder=[1,order_quantity]) if(not self.demand_node.inventory_drop.triggered): self.demand_node.inventory_drop.succeed() # signal that inventory has been dropped (since backorder is created) partial = order_quantity if self.min_split < 1: partial = int(order_quantity * self.min_split) waited = 0 available = 0 while order_quantity>0 and waited<=self.customer_tolerance: waiting_time = self.env.now available = self.demand_node.inventory.inventory.level if order_quantity <= available: # check if remaining order quantity is available self.env.process(self._process_delivery(order_quantity, customer_id)) self.demand_node.stats.update_stats(backorder=[-1,-order_quantity]) order_quantity = 0 break elif available >= partial: # or else at least min required 'partial' is available self.env.process(self._process_delivery(available, customer_id)) self.demand_node.stats.update_stats(backorder=[0,-available]) self.stats.update_stats(fulfillment_received=[-1,0]) order_quantity -= available # update order quantity else: self.demand_node.stats.update_stats(orders_shortage=[1,order_quantity-available]) yield self.demand_node.inventory_raised # wait until inventory is replenished self.demand_node.inventory_raised = self.env.event() # reset the event for the next iteration waited += self.env.now - waiting_time # update the waited time if order_quantity > 0: # if the order quantity is still greater than 0, it means the order was not fulfilled self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}: remaining order quantity:{order_quantity} not available!\")","title":"wait_for_order"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Demand.customer","text":"customer(customer_id, order_quantity) Simulate the customer behavior, ordering products from demand node, consume and return. Parameters: customer_id ( int ) \u2013 Customer ID for logging purposes. order_quantity ( float ) \u2013 The quantity of the product ordered. Attributes: customer_id ( int ) \u2013 Customer ID for logging purposes. order_quantity ( float ) \u2013 The quantity of the product ordered. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def customer(self,customer_id,order_quantity): \"\"\" Simulate the customer behavior, ordering products from demand node, consume and return. Parameters: customer_id (int): Customer ID for logging purposes. order_quantity (float): The quantity of the product ordered. Attributes: customer_id (int): Customer ID for logging purposes. order_quantity (float): The quantity of the product ordered. Returns: None \"\"\" available = self.demand_node.inventory.inventory.level self.stats.update_stats(demand_placed=[1,order_quantity]) # update the demand placed statistics if order_quantity <= available: self.demand_node.stats.update_stats(demand_received=[1,order_quantity]) yield from self._process_delivery(order_quantity, customer_id) elif self.consume_available and available > 0: # consume available inventory if order quantity is not available (backorder policy = allowed partial) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}: Order quantity:{order_quantity} not available, inventory level:{available}. Consuming available inventory.\") self.demand_node.stats.update_stats(demand_received=[1,available],orders_shortage=[1,order_quantity-available]) yield from self._process_delivery(available, customer_id) elif self.customer_tolerance > 0: # wait for tolerance time if order quantity is not available (backorder policy = allowed total) self.demand_node.stats.update_stats(demand_received=[1,order_quantity],orders_shortage=[1,order_quantity-available]) # update the orders shortage statistics self.env.process(self.wait_for_order(customer_id, order_quantity)) else: # No tolerance, leave without placing an order (backorder policy = not allowed) self.logger.logger.info(f\"{self.env.now:.4f}:{self.ID}:Customer{customer_id}: Order quantity:{order_quantity} not available, inventory level:{self.demand_node.inventory.inventory.level}. No tolerance! Shortage:{order_quantity-available}.\") self.demand_node.stats.update_stats(orders_shortage=[1,order_quantity-available]) # update the orders shortage statistics","title":"customer"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.Demand.behavior","text":"behavior() Generate demand by calling the order arrival and order quantity models. This method simulates the demand generation process, including order placement and handling shortages or unsatisfied demand. Returns: \u2013 None Source code in src/SupplyNetPy/Components/core.py def behavior(self): \"\"\" Generate demand by calling the order arrival and order quantity models. This method simulates the demand generation process, including order placement and handling shortages or unsatisfied demand. Parameters: None Attributes: None Returns: None \"\"\" customer_id = 1 # customer ID while True: order_time = self.order_arrival_model() order_quantity = self.order_quantity_model() validate_non_negative(name=f\"{self.ID}:order_arrival_model()\", value=order_time) validate_positive(name=f\"{self.ID}:order_quantity_model()\", value=order_quantity) self.env.process(self.customer(f\"{customer_id}\", order_quantity)) # create a customer customer_id += 1 # increment customer ID yield self.env.timeout(order_time) # wait for the next order arrival","title":"behavior"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.validate_positive","text":"validate_positive(name: str, value) Check if the value is positive and raise ValueError if not. Parameters: name ( str ) \u2013 name of the variable value \u2013 value to check Raises: ValueError \u2013 if value is not positive Source code in src/SupplyNetPy/Components/core.py def validate_positive(name: str, value): \"\"\" Check if the value is positive and raise ValueError if not. Parameters: name (str): name of the variable value: value to check Raises: ValueError: if value is not positive \"\"\" if value <= 0: global_logger.logger.error(f\"{name} must be positive.\") raise ValueError(f\"{name} must be positive.\")","title":"validate_positive"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.validate_non_negative","text":"validate_non_negative(name: str, value) Check if the value is non-negative and raise ValueError if not. Parameters: name ( str ) \u2013 name of the variable value \u2013 value to check Raises: ValueError \u2013 if value is negative Source code in src/SupplyNetPy/Components/core.py def validate_non_negative(name: str, value): \"\"\" Check if the value is non-negative and raise ValueError if not. Parameters: name (str): name of the variable value: value to check Raises: ValueError: if value is negative \"\"\" if value < 0: global_logger.logger.error(f\"{name} cannot be negative.\") raise ValueError(f\"{name} cannot be negative.\")","title":"validate_non_negative"},{"location":"api-reference/api-ref-core/#SupplyNetPy.Components.core.validate_number","text":"validate_number(name: str, value) -> None Check if the value is a number and raise ValueError if not. Parameters: name ( str ) \u2013 name of the variable value \u2013 value to check Raises: ValueError \u2013 if value is not a number Source code in src/SupplyNetPy/Components/core.py def validate_number(name: str, value) -> None: \"\"\" Check if the value is a number and raise ValueError if not. Parameters: name (str): name of the variable value: value to check Raises: ValueError: if value is not a number \"\"\" if not isinstance(value, numbers.Number): global_logger.logger.error(f\"function {name}() must return a number (an int or a float).\") raise ValueError(f\"function {name}() must be a number (an int or a float).\")","title":"validate_number"},{"location":"api-reference/api-ref-logger/","text":"The GlobalLogger class provides a flexible logging system for the SupplyNetPy simulations. It allows logging messages to both the console and a file, and can be easily enabled or disabled during runtime. SupplyNetPy.Components.logger GlobalLogger GlobalLogger(logger_name='sim_trace', log_to_file=True, log_file='simulation_trace.log', log_to_screen=True) A simple logger class that allows logging messages to the screen or to a file. Logging can be turned on or off. Parameters: log_to_file ( bool , default: True ) \u2013 Whether to log messages to a file. log_file ( str , default: 'simulation_trace.log' ) \u2013 The file to which log messages will be written. log_to_screen ( bool , default: True ) \u2013 Whether to log messages to the screen. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Methods: Name Description set_log_file Sets the log file to write simulation logs. get_log_file Returns the current log file name (path) in which simulation logs are written. set_logger Sets the logger name to write simulation logs. configure_logger Configures the logger by adding handlers based on user preferences. log Logs a message at the specified level. enable_logging Enables logging by configuring the logger with the appropriate handlers. disable_logging Disables logging by clearing all handlers from the logger. Initializes the Logger with options to log to file, log file name, and log to screen. Parameters: log_to_file ( bool , default: True ) \u2013 Whether to log messages to a file. Defaults to False. log_file ( str , default: 'simulation_trace.log' ) \u2013 The file to which log messages will be written. Defaults to 'app.log'. log_to_screen ( bool , default: True ) \u2013 Whether to log messages to the screen. Defaults to True. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def __init__(self, logger_name='sim_trace', log_to_file=True, log_file='simulation_trace.log', log_to_screen=True): \"\"\" Initializes the Logger with options to log to file, log file name, and log to screen. Parameters: log_to_file (bool): Whether to log messages to a file. Defaults to False. log_file (str): The file to which log messages will be written. Defaults to 'app.log'. log_to_screen (bool): Whether to log messages to the screen. Defaults to True. Attributes: logger (logging.Logger): The logger instance used for logging messages. log_to_file (bool): Flag indicating whether to log to a file. log_to_screen (bool): Flag indicating whether to log to the screen. Returns: None \"\"\" self.logger = logging.getLogger(logger_name) self.logger.setLevel(logging.DEBUG) self.log_to_file = log_to_file self.log_to_screen = log_to_screen self.log_file = log_file self.configure_logger() set_log_file set_log_file(filename) Sets given log file to write simulation logs Parameters: filename ( str ) \u2013 The file to which log messages will be written. Attributes: log_file ( str ) \u2013 The file to which log messages will be written. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def set_log_file(self,filename): \"\"\" Sets given log file to write simulation logs Parameters: filename (str): The file to which log messages will be written. Attributes: log_file (str): The file to which log messages will be written. Returns: None \"\"\" self.log_file = filename self.configure_logger() get_log_file get_log_file() Returns current log file name (path) in which simulation logs are written Returns: str \u2013 The current log file name (path). Source code in src/SupplyNetPy/Components/logger.py def get_log_file(self): \"\"\" Returns current log file name (path) in which simulation logs are written Parameters: None Attributes: None Returns: str: The current log file name (path). \"\"\" return self.log_file set_logger set_logger(logger_name) Sets given logger name to write simulation logs Parameters: logger_name ( str ) \u2013 The name of the logger to be used for logging messages. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def set_logger(self,logger_name): \"\"\" Sets given logger name to write simulation logs Parameters: logger_name (str): The name of the logger to be used for logging messages. Attributes: logger (logging.Logger): The logger instance used for logging messages. Returns: None \"\"\" self.logger = logging.getLogger(logger_name) configure_logger configure_logger() Configures the logger by adding handlers based on user preferences. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def configure_logger(self): \"\"\" Configures the logger by adding handlers based on user preferences. Parameters: None Attributes: logger (logging.Logger): The logger instance used for logging messages. log_to_file (bool): Flag indicating whether to log to a file. log_to_screen (bool): Flag indicating whether to log to the screen. Returns: None \"\"\" self.logger.handlers = [] if self.log_to_screen: screen_handler = logging.StreamHandler() screen_handler.setLevel(logging.DEBUG) screen_format = logging.Formatter('%(levelname)s %(name)s - %(message)s') screen_handler.setFormatter(screen_format) self.logger.addHandler(screen_handler) if self.log_to_file: file_handler = logging.FileHandler(self.log_file, mode='w') file_handler.setLevel(logging.DEBUG) file_format = logging.Formatter('%(levelname)s %(name)s - %(message)s') file_handler.setFormatter(file_format) self.logger.addHandler(file_handler) log log(level, message) Logs a message at the specified level. Parameters: level ( str ) \u2013 The level at which to log the message. Can be 'debug', 'info', 'warning', 'error', or 'critical'. message ( str ) \u2013 The message to log. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def log(self, level, message): \"\"\" Logs a message at the specified level. Parameters: level (str): The level at which to log the message. Can be 'debug', 'info', 'warning', 'error', or 'critical'. message (str): The message to log. Attributes: logger (logging.Logger): The logger instance used for logging messages. Returns: None \"\"\" if self.logger.handlers: if level == 'debug': self.logger.debug(message) elif level == 'info': self.logger.info(message) elif level == 'warning': self.logger.warning(message) elif level == 'error': self.logger.error(message) elif level == 'critical': self.logger.critical(message) enable_logging enable_logging(log_to_file=True, log_to_screen=True) Enables logging by configuring the logger with the appropriate handlers. Parameters: log_to_file ( bool , default: True ) \u2013 Whether to log messages to a file. Defaults to True. log_to_screen ( bool , default: True ) \u2013 Whether to log messages to the screen. Defaults to True. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def enable_logging(self,log_to_file=True,log_to_screen=True): \"\"\" Enables logging by configuring the logger with the appropriate handlers. Parameters: log_to_file (bool): Whether to log messages to a file. Defaults to True. log_to_screen (bool): Whether to log messages to the screen. Defaults to True. Attributes: logger (logging.Logger): The logger instance used for logging messages. log_to_file (bool): Flag indicating whether to log to a file. log_to_screen (bool): Flag indicating whether to log to the screen. Returns: None \"\"\" logging.disable(logging.NOTSET) self.log_to_file = log_to_file self.log_to_screen = log_to_screen self.configure_logger() disable_logging disable_logging() Disables logging by clearing all handlers from the logger. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def disable_logging(self): \"\"\" Disables logging by clearing all handlers from the logger. Parameters: None Attributes: logger (logging.Logger): The logger instance used for logging messages. Returns: None \"\"\" logging.disable(logging.CRITICAL) self.logger.handlers = []","title":"Logger"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger","text":"","title":"logger"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger","text":"GlobalLogger(logger_name='sim_trace', log_to_file=True, log_file='simulation_trace.log', log_to_screen=True) A simple logger class that allows logging messages to the screen or to a file. Logging can be turned on or off. Parameters: log_to_file ( bool , default: True ) \u2013 Whether to log messages to a file. log_file ( str , default: 'simulation_trace.log' ) \u2013 The file to which log messages will be written. log_to_screen ( bool , default: True ) \u2013 Whether to log messages to the screen. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Methods: Name Description set_log_file Sets the log file to write simulation logs. get_log_file Returns the current log file name (path) in which simulation logs are written. set_logger Sets the logger name to write simulation logs. configure_logger Configures the logger by adding handlers based on user preferences. log Logs a message at the specified level. enable_logging Enables logging by configuring the logger with the appropriate handlers. disable_logging Disables logging by clearing all handlers from the logger. Initializes the Logger with options to log to file, log file name, and log to screen. Parameters: log_to_file ( bool , default: True ) \u2013 Whether to log messages to a file. Defaults to False. log_file ( str , default: 'simulation_trace.log' ) \u2013 The file to which log messages will be written. Defaults to 'app.log'. log_to_screen ( bool , default: True ) \u2013 Whether to log messages to the screen. Defaults to True. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def __init__(self, logger_name='sim_trace', log_to_file=True, log_file='simulation_trace.log', log_to_screen=True): \"\"\" Initializes the Logger with options to log to file, log file name, and log to screen. Parameters: log_to_file (bool): Whether to log messages to a file. Defaults to False. log_file (str): The file to which log messages will be written. Defaults to 'app.log'. log_to_screen (bool): Whether to log messages to the screen. Defaults to True. Attributes: logger (logging.Logger): The logger instance used for logging messages. log_to_file (bool): Flag indicating whether to log to a file. log_to_screen (bool): Flag indicating whether to log to the screen. Returns: None \"\"\" self.logger = logging.getLogger(logger_name) self.logger.setLevel(logging.DEBUG) self.log_to_file = log_to_file self.log_to_screen = log_to_screen self.log_file = log_file self.configure_logger()","title":"GlobalLogger"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.set_log_file","text":"set_log_file(filename) Sets given log file to write simulation logs Parameters: filename ( str ) \u2013 The file to which log messages will be written. Attributes: log_file ( str ) \u2013 The file to which log messages will be written. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def set_log_file(self,filename): \"\"\" Sets given log file to write simulation logs Parameters: filename (str): The file to which log messages will be written. Attributes: log_file (str): The file to which log messages will be written. Returns: None \"\"\" self.log_file = filename self.configure_logger()","title":"set_log_file"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.get_log_file","text":"get_log_file() Returns current log file name (path) in which simulation logs are written Returns: str \u2013 The current log file name (path). Source code in src/SupplyNetPy/Components/logger.py def get_log_file(self): \"\"\" Returns current log file name (path) in which simulation logs are written Parameters: None Attributes: None Returns: str: The current log file name (path). \"\"\" return self.log_file","title":"get_log_file"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.set_logger","text":"set_logger(logger_name) Sets given logger name to write simulation logs Parameters: logger_name ( str ) \u2013 The name of the logger to be used for logging messages. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def set_logger(self,logger_name): \"\"\" Sets given logger name to write simulation logs Parameters: logger_name (str): The name of the logger to be used for logging messages. Attributes: logger (logging.Logger): The logger instance used for logging messages. Returns: None \"\"\" self.logger = logging.getLogger(logger_name)","title":"set_logger"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.configure_logger","text":"configure_logger() Configures the logger by adding handlers based on user preferences. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def configure_logger(self): \"\"\" Configures the logger by adding handlers based on user preferences. Parameters: None Attributes: logger (logging.Logger): The logger instance used for logging messages. log_to_file (bool): Flag indicating whether to log to a file. log_to_screen (bool): Flag indicating whether to log to the screen. Returns: None \"\"\" self.logger.handlers = [] if self.log_to_screen: screen_handler = logging.StreamHandler() screen_handler.setLevel(logging.DEBUG) screen_format = logging.Formatter('%(levelname)s %(name)s - %(message)s') screen_handler.setFormatter(screen_format) self.logger.addHandler(screen_handler) if self.log_to_file: file_handler = logging.FileHandler(self.log_file, mode='w') file_handler.setLevel(logging.DEBUG) file_format = logging.Formatter('%(levelname)s %(name)s - %(message)s') file_handler.setFormatter(file_format) self.logger.addHandler(file_handler)","title":"configure_logger"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.log","text":"log(level, message) Logs a message at the specified level. Parameters: level ( str ) \u2013 The level at which to log the message. Can be 'debug', 'info', 'warning', 'error', or 'critical'. message ( str ) \u2013 The message to log. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def log(self, level, message): \"\"\" Logs a message at the specified level. Parameters: level (str): The level at which to log the message. Can be 'debug', 'info', 'warning', 'error', or 'critical'. message (str): The message to log. Attributes: logger (logging.Logger): The logger instance used for logging messages. Returns: None \"\"\" if self.logger.handlers: if level == 'debug': self.logger.debug(message) elif level == 'info': self.logger.info(message) elif level == 'warning': self.logger.warning(message) elif level == 'error': self.logger.error(message) elif level == 'critical': self.logger.critical(message)","title":"log"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.enable_logging","text":"enable_logging(log_to_file=True, log_to_screen=True) Enables logging by configuring the logger with the appropriate handlers. Parameters: log_to_file ( bool , default: True ) \u2013 Whether to log messages to a file. Defaults to True. log_to_screen ( bool , default: True ) \u2013 Whether to log messages to the screen. Defaults to True. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. log_to_file ( bool ) \u2013 Flag indicating whether to log to a file. log_to_screen ( bool ) \u2013 Flag indicating whether to log to the screen. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def enable_logging(self,log_to_file=True,log_to_screen=True): \"\"\" Enables logging by configuring the logger with the appropriate handlers. Parameters: log_to_file (bool): Whether to log messages to a file. Defaults to True. log_to_screen (bool): Whether to log messages to the screen. Defaults to True. Attributes: logger (logging.Logger): The logger instance used for logging messages. log_to_file (bool): Flag indicating whether to log to a file. log_to_screen (bool): Flag indicating whether to log to the screen. Returns: None \"\"\" logging.disable(logging.NOTSET) self.log_to_file = log_to_file self.log_to_screen = log_to_screen self.configure_logger()","title":"enable_logging"},{"location":"api-reference/api-ref-logger/#SupplyNetPy.Components.logger.GlobalLogger.disable_logging","text":"disable_logging() Disables logging by clearing all handlers from the logger. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: \u2013 None Source code in src/SupplyNetPy/Components/logger.py def disable_logging(self): \"\"\" Disables logging by clearing all handlers from the logger. Parameters: None Attributes: logger (logging.Logger): The logger instance used for logging messages. Returns: None \"\"\" logging.disable(logging.CRITICAL) self.logger.handlers = []","title":"disable_logging"},{"location":"api-reference/api-ref-utilities/","text":"The utility module offers various functions to create, simulate, access information, and visualize the supply chain network more effectively. SupplyNetPy.Components.utilities create_sc_net create_sc_net(nodes: list, links: list, demands: list, env: Environment = None) This functions inputs the nodes, links and demand netlists and creates supply chain nodes, links and demand objects. It then creates a supply chain network by putting all the objects in a dictionary. Parameters: nodes ( list ) \u2013 A netlist of nodes in the supply chain network. links ( list ) \u2013 A netlist of links between the nodes. demand ( list ) \u2013 A netlist of demand nodes in the supply chain network. env ( Environment , default: None ) \u2013 A SimPy Environment object. If not provided, a new environment will be created. Attributes: global_logger ( GlobalLogger ) \u2013 The global logger instance used for logging messages. supplychainnet ( dict ) \u2013 A dictionary representing the supply chain network. used_ids ( list ) \u2013 A list to keep track of used IDs to avoid duplicates. num_suppliers ( int ) \u2013 Counter for the number of suppliers. num_manufacturers ( int ) \u2013 Counter for the number of manufacturers. num_distributors ( int ) \u2013 Counter for the number of distributors. num_retailers ( int ) \u2013 Counter for the number of retailers. Raises: ValueError \u2013 If the SimPy Environment object is not provided or if there are duplicate IDs in nodes, links, or demands. ValueError \u2013 If an invalid node type is encountered. ValueError \u2013 If an invalid source or sink node is specified in a link. ValueError \u2013 If an invalid demand node is specified in a demand. Returns: dict \u2013 A dictionary representing the supply chain network. Source code in src/SupplyNetPy/Components/utilities.py def create_sc_net(nodes: list, links: list, demands: list, env:simpy.Environment = None): \"\"\" This functions inputs the nodes, links and demand netlists and creates supply chain nodes, links and demand objects. It then creates a supply chain network by putting all the objects in a dictionary. Parameters: nodes (list): A netlist of nodes in the supply chain network. links (list): A netlist of links between the nodes. demand (list): A netlist of demand nodes in the supply chain network. env (simpy.Environment, optional): A SimPy Environment object. If not provided, a new environment will be created. Attributes: global_logger (GlobalLogger): The global logger instance used for logging messages. supplychainnet (dict): A dictionary representing the supply chain network. used_ids (list): A list to keep track of used IDs to avoid duplicates. num_suppliers (int): Counter for the number of suppliers. num_manufacturers (int): Counter for the number of manufacturers. num_distributors (int): Counter for the number of distributors. num_retailers (int): Counter for the number of retailers. Raises: ValueError: If the SimPy Environment object is not provided or if there are duplicate IDs in nodes, links, or demands. ValueError: If an invalid node type is encountered. ValueError: If an invalid source or sink node is specified in a link. ValueError: If an invalid demand node is specified in a demand. Returns: dict: A dictionary representing the supply chain network. \"\"\" if (isinstance(nodes[0],Node) or isinstance(links[0],Link) or isinstance(demands[0],Demand)) and env is None: global_logger.logger.error(\"Please provide SimPy Environment object env\") raise ValueError(\"A SimPy Environment object is required!\") if len(nodes)==0 or len(links)==0 or len(demands)==0: global_logger.logger.error(\"Nodes, links, and demands cannot be empty\") raise ValueError(\"Nodes, links, and demands cannot be empty\") if(env is None): env = simpy.Environment() supplychainnet = {\"nodes\":{},\"links\":{},\"demands\":{}} # create empty supply chain network used_ids = [] num_suppliers = 0 num_manufacturers = 0 num_distributors = 0 num_retailers = 0 for node in nodes: if isinstance(node, dict): check_duplicate_id(used_ids, node[\"ID\"], \"node ID\") node_id = node['ID'] if node[\"node_type\"].lower() in [\"supplier\", \"infinite_supplier\"]: supplychainnet[\"nodes\"][f\"{node_id}\"] = Supplier(env=env, **node) num_suppliers += 1 elif node[\"node_type\"].lower() in [\"manufacturer\", \"factory\"]: node_ex = {key: node[key] for key in node if key != 'node_type'} # excluding key 'node_type', Manufacturer do not take it supplychainnet[\"nodes\"][f\"{node_id}\"] = Manufacturer(env=env, **node_ex) num_manufacturers += 1 elif node[\"node_type\"].lower() in [\"distributor\", \"warehouse\"]: supplychainnet[\"nodes\"][f\"{node_id}\"] = InventoryNode(env=env, **node) num_distributors += 1 elif node[\"node_type\"].lower() in [\"retailer\", \"store\", \"shop\"]: supplychainnet[\"nodes\"][f\"{node_id}\"] = InventoryNode(env=env, **node) num_retailers += 1 else: used_ids.remove(node[\"ID\"]) global_logger.logger.error(f\"Invalid node type {node['node_type']}\") raise ValueError(\"Invalid node type\") elif isinstance(node, Node): if(node.ID in used_ids): global_logger.logger.error(f\"Duplicate node ID {node.ID}\") raise ValueError(\"Duplicate node ID\") used_ids.append(node.ID) node_id = node.ID supplychainnet[\"nodes\"][f\"{node_id}\"] = node if node.node_type.lower() in [\"supplier\", \"infinite_supplier\"]: num_suppliers += 1 elif node.node_type.lower() in [\"manufacturer\", \"factory\"]: num_manufacturers += 1 elif node.node_type.lower() in [\"distributor\", \"warehouse\"]: num_distributors += 1 elif node.node_type.lower() in [\"retailer\", \"store\", \"shop\"]: num_retailers += 1 else: used_ids.remove(node.ID) global_logger.logger.error(f\"Invalid node type {node.node_type}\") raise ValueError(\"Invalid node type\") for link in links: if isinstance(link, dict): check_duplicate_id(used_ids, link[\"ID\"], \"link ID\") source = None sink = None nodes = supplychainnet[\"nodes\"].keys() if(link[\"source\"] in nodes): source_id = link[\"source\"] source = supplychainnet[\"nodes\"][f\"{source_id}\"] if(link[\"sink\"] in nodes): sink_id = link[\"sink\"] sink = supplychainnet[\"nodes\"][f\"{sink_id}\"] if(source is None or sink is None): global_logger.logger.error(f\"Invalid source or sink node {link['source']} {link['sink']}\") raise ValueError(\"Invalid source or sink node\") exclude_keys = {'source', 'sink'} params = {k: v for k, v in link.items() if k not in exclude_keys} link_id = params['ID'] supplychainnet[\"links\"][f\"{link_id}\"] = Link(env=env,source=source,sink=sink,**params) elif isinstance(link, Link): if(link.ID in used_ids): global_logger.logger.error(f\"Duplicate link ID {link.ID}\") raise ValueError(\"Duplicate node ID\") used_ids.append(link.ID) supplychainnet[\"links\"][f\"{link.ID}\"] = link for d in demands: if isinstance(d, dict): check_duplicate_id(used_ids, d[\"ID\"], \"demand ID\") demand_node = None # check for which node the demand is nodes = supplychainnet[\"nodes\"].keys() if d['demand_node'] in nodes: demand_node_id = d['demand_node'] demand_node = supplychainnet[\"nodes\"][f\"{demand_node_id}\"] if(demand_node is None): global_logger.logger.error(f\"Invalid demand node {d['demand_node']}\") raise ValueError(\"Invalid demand node\") exclude_keys = {'demand_node','node_type'} params = {k: v for k, v in d.items() if k not in exclude_keys} demand_id = params['ID'] supplychainnet[\"demands\"][f\"{demand_id}\"] = Demand(env=env,demand_node=demand_node,**params) elif isinstance(d, Demand): if(d.ID in used_ids): global_logger.logger.error(f\"Duplicate demand ID {d.ID}\") raise ValueError(\"Duplicate demand ID\") used_ids.append(d.ID) supplychainnet[\"demands\"][f\"{d.ID}\"] = d supplychainnet[\"env\"] = env supplychainnet[\"num_of_nodes\"] = num_suppliers + num_manufacturers + num_distributors + num_retailers supplychainnet[\"num_of_links\"] = len(links) supplychainnet[\"num_suppliers\"] = num_suppliers supplychainnet[\"num_manufacturers\"] = num_manufacturers supplychainnet[\"num_distributors\"] = num_distributors supplychainnet[\"num_retailers\"] = num_retailers return supplychainnet check_duplicate_id check_duplicate_id(used_ids, new_id, entity_type='ID') Checks if the new_id is already in used_ids. If it is, logs an error and raises a ValueError. Parameters: used_ids ( list ) \u2013 List of already used IDs. new_id ( str ) \u2013 The new ID to check. entity_type ( str , default: 'ID' ) \u2013 Type of the entity for which the ID is being checked (e.g., \"node ID\", \"link ID\"). Returns: \u2013 None Raises: ValueError \u2013 If the new_id is already in used_ids. Source code in src/SupplyNetPy/Components/utilities.py def check_duplicate_id(used_ids, new_id, entity_type=\"ID\"): \"\"\" Checks if the new_id is already in used_ids. If it is, logs an error and raises a ValueError. Parameters: used_ids (list): List of already used IDs. new_id (str): The new ID to check. entity_type (str): Type of the entity for which the ID is being checked (e.g., \"node ID\", \"link ID\"). Attributes: None Returns: None Raises: ValueError: If the new_id is already in used_ids. \"\"\" if new_id in used_ids: global_logger.logger.error(f\"Duplicate {entity_type} {new_id}\") raise ValueError(f\"Duplicate {entity_type}\") used_ids.append(new_id) simulate_sc_net simulate_sc_net(supplychainnet, sim_time, logging=True) Simulate the supply chain network for a given time period, and calculate performance measures. Parameters: supplychainnet ( dict ) \u2013 A supply chain network. sim_time ( int ) \u2013 Simulation time. Returns: supplychainnet ( dict ) \u2013 Updated dict with listed performance measures. Source code in src/SupplyNetPy/Components/utilities.py def simulate_sc_net(supplychainnet, sim_time, logging=True): \"\"\" Simulate the supply chain network for a given time period, and calculate performance measures. Parameters: supplychainnet (dict): A supply chain network. sim_time (int): Simulation time. Returns: supplychainnet (dict): Updated dict with listed performance measures. \"\"\" logger = global_logger.logger env = supplychainnet[\"env\"] if(sim_time<=env.now): logger.warning(f\"You have already ran simulation for this network! \\n To create a new network use create_sc_net(), or specify the simulation time grater than {env.now} to run it further.\") logger.info(f\"Performance measures for the supply chain network are calculated and returned.\") elif isinstance(logging, tuple) and len(logging) == 2: assert logging[0] < logging[1], \"Start logging time should be less than stop logging time\" assert logging[0] >= 0, \"Start logging time should be greater than or equal to 0\" assert logging[1] <= sim_time, \"Stop logging time should be less than or equal to simulation time\" log_start = logging[0] log_stop = logging[1] global_logger.disable_logging() env.run(log_start) # Run the simulation global_logger.enable_logging() env.run(log_stop) # Run the simulation global_logger.disable_logging() if(sim_time > log_stop): env.run(sim_time) # Run the simulation elif isinstance(logging, bool) and logging: global_logger.enable_logging() env.run(sim_time) # Run the simulation else: global_logger.disable_logging() env.run(sim_time) # Run the simulation # Let's create some variables to store stats total_available_inv = 0 avg_available_inv = 0 total_inv_carry_cost = 0 total_inv_spend = 0 total_inv_waste = 0 total_transport_cost = 0 total_revenue = 0 total_cost = 0 total_profit = 0 total_demand_by_customers = [0, 0] # [orders, products] total_fulfillment_received_by_customers = [0, 0] # [orders, products] total_demand_by_site = [0, 0] # [orders, products] total_fulfillment_received_by_site = [0, 0] # [orders, products] total_demand_placed = [0, 0] # [orders, products] total_fulfillment_received = [0, 0] # [orders, products] total_shortage = [0, 0] # [orders, products] total_backorders = [0, 0] # [orders, products] for key, node in supplychainnet[\"nodes\"].items(): if(\"infinite\" in node.node_type.lower()): # skip infinite suppliers continue node.stats.update_stats() # update stats for the node total_available_inv += node.inventory.inventory.level if len(node.inventory.instantaneous_levels)>0: avg_available_inv += sum([x[1] for x in node.inventory.instantaneous_levels])/len(node.inventory.instantaneous_levels) total_inv_carry_cost += node.inventory.carry_cost total_inv_spend += node.stats.inventory_spend_cost total_inv_waste += node.stats.inventory_waste total_transport_cost += node.stats.transportation_cost total_cost += node.stats.node_cost total_revenue += node.stats.revenue total_demand_by_site[0] += node.stats.demand_placed[0] total_demand_by_site[1] += node.stats.demand_placed[1] total_fulfillment_received_by_site[0] += node.stats.fulfillment_received[0] total_fulfillment_received_by_site[1] += node.stats.fulfillment_received[1] total_shortage[0] += node.stats.orders_shortage[0] total_shortage[1] += node.stats.orders_shortage[1] total_backorders[0] += node.stats.backorder[0] total_backorders[1] += node.stats.backorder[1] for key, node in supplychainnet[\"demands\"].items(): node.stats.update_stats() # update stats for the node total_transport_cost += node.stats.transportation_cost total_cost += node.stats.node_cost total_revenue += node.stats.revenue total_demand_by_customers[0] += node.stats.demand_placed[0] # orders total_demand_by_customers[1] += node.stats.demand_placed[1] # products total_fulfillment_received_by_customers[0] += node.stats.fulfillment_received[0] total_fulfillment_received_by_customers[1] += node.stats.fulfillment_received[1] total_shortage[0] += node.stats.orders_shortage[0] total_shortage[1] += node.stats.orders_shortage[1] total_backorders[0] += node.stats.backorder[0] total_backorders[1] += node.stats.backorder[1] total_demand_placed[0] = total_demand_by_customers[0] + total_demand_by_site[0] total_demand_placed[1] = total_demand_by_customers[1] + total_demand_by_site[1] total_fulfillment_received[0] = total_fulfillment_received_by_customers[0] + total_fulfillment_received_by_site[0] total_fulfillment_received[1] = total_fulfillment_received_by_customers[1] + total_fulfillment_received_by_site[1] total_profit = total_revenue - total_cost supplychainnet[\"available_inv\"] = total_available_inv supplychainnet[\"avg_available_inv\"] = avg_available_inv supplychainnet[\"inventory_carry_cost\"] = total_inv_carry_cost supplychainnet[\"inventory_spend_cost\"] = total_inv_spend supplychainnet[\"inventory_waste\"] = total_inv_waste supplychainnet[\"transportation_cost\"] = total_transport_cost supplychainnet[\"revenue\"] = total_revenue supplychainnet[\"total_cost\"] = total_cost supplychainnet[\"profit\"] = total_profit supplychainnet[\"demand_by_customers\"] = total_demand_by_customers supplychainnet[\"fulfillment_received_by_customers\"] = total_fulfillment_received_by_customers supplychainnet[\"demand_by_site\"] = total_demand_by_site supplychainnet[\"fulfillment_received_by_site\"] = total_fulfillment_received_by_site supplychainnet[\"total_demand\"] = total_demand_placed supplychainnet[\"total_fulfillment_received\"] = total_fulfillment_received supplychainnet[\"shortage\"] = total_shortage supplychainnet[\"backorders\"] = total_backorders # Calculate average cost per order and per item if total_demand_placed[0] > 0: supplychainnet[\"avg_cost_per_order\"] = total_cost / total_demand_placed[0] else: supplychainnet[\"avg_cost_per_order\"] = 0 if total_demand_placed[1] > 0: supplychainnet[\"avg_cost_per_item\"] = total_cost / total_demand_placed[1] else: supplychainnet[\"avg_cost_per_item\"] = 0 if isinstance(logging, tuple): global_logger.enable_logging() max_key_length = max(len(key) for key in supplychainnet.keys()) + 1 logger.info(f\"Supply chain info:\") for key in sorted(supplychainnet.keys()): logger.info(f\"{key.ljust(max_key_length)}: {supplychainnet[key]}\") return supplychainnet visualize_sc_net visualize_sc_net(supplychainnet) Visualize the supply chain network as a graph. Parameters: supplychainnet ( dict ) \u2013 The supply chain network containing nodes and edges. Returns: \u2013 None Source code in src/SupplyNetPy/Components/utilities.py def visualize_sc_net(supplychainnet): \"\"\" Visualize the supply chain network as a graph. Parameters: supplychainnet (dict): The supply chain network containing nodes and edges. Attributes: None Returns: None \"\"\" G = nx.Graph() nodes = supplychainnet[\"nodes\"] edges = supplychainnet[\"links\"] # Add nodes to the graph for node_id, node in nodes.items(): G.add_node(node_id, level=node.node_type) # Add edges to the graph for edge_id, edge in edges.items(): from_node = edge.source.ID to_node = edge.sink.ID G.add_edge(from_node, to_node, weight=round(edge.lead_time(),2)) # Generate the layout of the graph pos = nx.spectral_layout(G) # Draw the graph nx.draw(G, pos, node_color='#CCCCCC', with_labels=True) # Add edge labels labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels=labels) # Set the title and display the graph plt.title(\"Supply chain network\") plt.show() print_node_wise_performance print_node_wise_performance(nodes_object_list) This function prints the performance metrics for each supply chain node provided in the nodes_object_list. Parameters: nodes_object_list ( list ) \u2013 List of supply chain node objects Returns: \u2013 None Source code in src/SupplyNetPy/Components/utilities.py def print_node_wise_performance(nodes_object_list): \"\"\" This function prints the performance metrics for each supply chain node provided in the nodes_object_list. Parameters: nodes_object_list (list): List of supply chain node objects Returns: None \"\"\" if not nodes_object_list: print(\"No nodes provided.\") return # Pre-fetch statistics from all nodes stats_per_node = {node.name: node.stats.get_statistics() for node in nodes_object_list} stat_keys = sorted(next(iter(stats_per_node.values())).keys()) # Determine column widths col_width = 25 header = \"Performance Metric\".ljust(col_width) for name in stats_per_node: header += name.ljust(col_width) print(header) # Print row-wise stats for key in stat_keys: row = key.ljust(col_width) for name in stats_per_node: value = stats_per_node[name].get(key, \"N/A\") row += str(value).ljust(col_width) print(row) get_sc_net_info get_sc_net_info(supplychainnet) Get supply chain network information. Parameters: supplychainnet ( dict ) \u2013 A dictionary representing the supply chain network. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. sc_info ( str ) \u2013 A string to accumulate the supply chain network information. info_keys ( list ) \u2013 A list of keys to extract information from the supply chain network. keys ( set ) \u2013 A set of keys in the supply chain network regarding performance of the network. Returns: str \u2013 A string containing the supply chain network information. Source code in src/SupplyNetPy/Components/utilities.py def get_sc_net_info(supplychainnet): \"\"\" Get supply chain network information. Parameters: supplychainnet (dict): A dictionary representing the supply chain network. Attributes: logger (logging.Logger): The logger instance used for logging messages. sc_info (str): A string to accumulate the supply chain network information. info_keys (list): A list of keys to extract information from the supply chain network. keys (set): A set of keys in the supply chain network regarding performance of the network. Returns: str: A string containing the supply chain network information. \"\"\" logger = global_logger.logger global_logger.enable_logging(log_to_screen=True) sc_info = \"Supply chain configuration: \\n\" info_keys = ['num_of_nodes', 'num_of_links', 'num_suppliers','num_manufacturers', 'num_distributors', 'num_retailers'] for key in info_keys: if key in supplychainnet.keys(): sc_info += f\"{key}: {supplychainnet[key]}\\n\" logger.info(f\"{key}: {supplychainnet[key]}\") logger.info(f\"Nodes in the network: {list(supplychainnet['nodes'].keys())}\") sc_info += \"Nodes in the network:\\n\" for node_id, node in supplychainnet[\"nodes\"].items(): sc_info += process_info_dict(node.get_info(), logger) logger.info(f\"Edges in the network: {list(supplychainnet['links'].keys())}\") sc_info += \"Edges in the network:\\n\" for edge_id, edge in supplychainnet[\"links\"].items(): sc_info += process_info_dict(edge.get_info(), logger) logger.info(f\"Demands in the network: {list(supplychainnet['demands'].keys())}\") sc_info += \"Demands in the network:\\n\" for demand_id, demand in supplychainnet[\"demands\"].items(): sc_info += process_info_dict(demand.get_info(), logger) keys = supplychainnet.keys() - {'nodes', 'links', 'demands', 'env', 'num_of_nodes', 'num_of_links', 'num_suppliers','num_manufacturers', 'num_distributors', 'num_retailers'} sc_info += \"Supply chain network performance:\\n\" logger.info(\"Supply chain network performance:\") for key in sorted(keys): sc_info += f\"{key}: {supplychainnet[key]}\\n\" logger.info(f\"{key}: {supplychainnet[key]}\") return sc_info process_info_dict process_info_dict(info_dict, logger) Processes the dictionary and logs the key-value pairs. Parameters: info_dict ( dict ) \u2013 The information dictionary to process. logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: str \u2013 A string representation of the processed information. Source code in src/SupplyNetPy/Components/utilities.py def process_info_dict(info_dict, logger): \"\"\" Processes the dictionary and logs the key-value pairs. Parameters: info_dict (dict): The information dictionary to process. logger (logging.Logger): The logger instance used for logging messages. Attributes: None Returns: str: A string representation of the processed information. \"\"\" info_string = \"\" for key, value in info_dict.items(): if isinstance(value, object): value = str(value) if callable(value): value = value.__name__ info_string += f\"{key}: {value}\\n\" logger.info(f\"{key}: {value}\") return info_string","title":"Utilities"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities","text":"","title":"utilities"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.create_sc_net","text":"create_sc_net(nodes: list, links: list, demands: list, env: Environment = None) This functions inputs the nodes, links and demand netlists and creates supply chain nodes, links and demand objects. It then creates a supply chain network by putting all the objects in a dictionary. Parameters: nodes ( list ) \u2013 A netlist of nodes in the supply chain network. links ( list ) \u2013 A netlist of links between the nodes. demand ( list ) \u2013 A netlist of demand nodes in the supply chain network. env ( Environment , default: None ) \u2013 A SimPy Environment object. If not provided, a new environment will be created. Attributes: global_logger ( GlobalLogger ) \u2013 The global logger instance used for logging messages. supplychainnet ( dict ) \u2013 A dictionary representing the supply chain network. used_ids ( list ) \u2013 A list to keep track of used IDs to avoid duplicates. num_suppliers ( int ) \u2013 Counter for the number of suppliers. num_manufacturers ( int ) \u2013 Counter for the number of manufacturers. num_distributors ( int ) \u2013 Counter for the number of distributors. num_retailers ( int ) \u2013 Counter for the number of retailers. Raises: ValueError \u2013 If the SimPy Environment object is not provided or if there are duplicate IDs in nodes, links, or demands. ValueError \u2013 If an invalid node type is encountered. ValueError \u2013 If an invalid source or sink node is specified in a link. ValueError \u2013 If an invalid demand node is specified in a demand. Returns: dict \u2013 A dictionary representing the supply chain network. Source code in src/SupplyNetPy/Components/utilities.py def create_sc_net(nodes: list, links: list, demands: list, env:simpy.Environment = None): \"\"\" This functions inputs the nodes, links and demand netlists and creates supply chain nodes, links and demand objects. It then creates a supply chain network by putting all the objects in a dictionary. Parameters: nodes (list): A netlist of nodes in the supply chain network. links (list): A netlist of links between the nodes. demand (list): A netlist of demand nodes in the supply chain network. env (simpy.Environment, optional): A SimPy Environment object. If not provided, a new environment will be created. Attributes: global_logger (GlobalLogger): The global logger instance used for logging messages. supplychainnet (dict): A dictionary representing the supply chain network. used_ids (list): A list to keep track of used IDs to avoid duplicates. num_suppliers (int): Counter for the number of suppliers. num_manufacturers (int): Counter for the number of manufacturers. num_distributors (int): Counter for the number of distributors. num_retailers (int): Counter for the number of retailers. Raises: ValueError: If the SimPy Environment object is not provided or if there are duplicate IDs in nodes, links, or demands. ValueError: If an invalid node type is encountered. ValueError: If an invalid source or sink node is specified in a link. ValueError: If an invalid demand node is specified in a demand. Returns: dict: A dictionary representing the supply chain network. \"\"\" if (isinstance(nodes[0],Node) or isinstance(links[0],Link) or isinstance(demands[0],Demand)) and env is None: global_logger.logger.error(\"Please provide SimPy Environment object env\") raise ValueError(\"A SimPy Environment object is required!\") if len(nodes)==0 or len(links)==0 or len(demands)==0: global_logger.logger.error(\"Nodes, links, and demands cannot be empty\") raise ValueError(\"Nodes, links, and demands cannot be empty\") if(env is None): env = simpy.Environment() supplychainnet = {\"nodes\":{},\"links\":{},\"demands\":{}} # create empty supply chain network used_ids = [] num_suppliers = 0 num_manufacturers = 0 num_distributors = 0 num_retailers = 0 for node in nodes: if isinstance(node, dict): check_duplicate_id(used_ids, node[\"ID\"], \"node ID\") node_id = node['ID'] if node[\"node_type\"].lower() in [\"supplier\", \"infinite_supplier\"]: supplychainnet[\"nodes\"][f\"{node_id}\"] = Supplier(env=env, **node) num_suppliers += 1 elif node[\"node_type\"].lower() in [\"manufacturer\", \"factory\"]: node_ex = {key: node[key] for key in node if key != 'node_type'} # excluding key 'node_type', Manufacturer do not take it supplychainnet[\"nodes\"][f\"{node_id}\"] = Manufacturer(env=env, **node_ex) num_manufacturers += 1 elif node[\"node_type\"].lower() in [\"distributor\", \"warehouse\"]: supplychainnet[\"nodes\"][f\"{node_id}\"] = InventoryNode(env=env, **node) num_distributors += 1 elif node[\"node_type\"].lower() in [\"retailer\", \"store\", \"shop\"]: supplychainnet[\"nodes\"][f\"{node_id}\"] = InventoryNode(env=env, **node) num_retailers += 1 else: used_ids.remove(node[\"ID\"]) global_logger.logger.error(f\"Invalid node type {node['node_type']}\") raise ValueError(\"Invalid node type\") elif isinstance(node, Node): if(node.ID in used_ids): global_logger.logger.error(f\"Duplicate node ID {node.ID}\") raise ValueError(\"Duplicate node ID\") used_ids.append(node.ID) node_id = node.ID supplychainnet[\"nodes\"][f\"{node_id}\"] = node if node.node_type.lower() in [\"supplier\", \"infinite_supplier\"]: num_suppliers += 1 elif node.node_type.lower() in [\"manufacturer\", \"factory\"]: num_manufacturers += 1 elif node.node_type.lower() in [\"distributor\", \"warehouse\"]: num_distributors += 1 elif node.node_type.lower() in [\"retailer\", \"store\", \"shop\"]: num_retailers += 1 else: used_ids.remove(node.ID) global_logger.logger.error(f\"Invalid node type {node.node_type}\") raise ValueError(\"Invalid node type\") for link in links: if isinstance(link, dict): check_duplicate_id(used_ids, link[\"ID\"], \"link ID\") source = None sink = None nodes = supplychainnet[\"nodes\"].keys() if(link[\"source\"] in nodes): source_id = link[\"source\"] source = supplychainnet[\"nodes\"][f\"{source_id}\"] if(link[\"sink\"] in nodes): sink_id = link[\"sink\"] sink = supplychainnet[\"nodes\"][f\"{sink_id}\"] if(source is None or sink is None): global_logger.logger.error(f\"Invalid source or sink node {link['source']} {link['sink']}\") raise ValueError(\"Invalid source or sink node\") exclude_keys = {'source', 'sink'} params = {k: v for k, v in link.items() if k not in exclude_keys} link_id = params['ID'] supplychainnet[\"links\"][f\"{link_id}\"] = Link(env=env,source=source,sink=sink,**params) elif isinstance(link, Link): if(link.ID in used_ids): global_logger.logger.error(f\"Duplicate link ID {link.ID}\") raise ValueError(\"Duplicate node ID\") used_ids.append(link.ID) supplychainnet[\"links\"][f\"{link.ID}\"] = link for d in demands: if isinstance(d, dict): check_duplicate_id(used_ids, d[\"ID\"], \"demand ID\") demand_node = None # check for which node the demand is nodes = supplychainnet[\"nodes\"].keys() if d['demand_node'] in nodes: demand_node_id = d['demand_node'] demand_node = supplychainnet[\"nodes\"][f\"{demand_node_id}\"] if(demand_node is None): global_logger.logger.error(f\"Invalid demand node {d['demand_node']}\") raise ValueError(\"Invalid demand node\") exclude_keys = {'demand_node','node_type'} params = {k: v for k, v in d.items() if k not in exclude_keys} demand_id = params['ID'] supplychainnet[\"demands\"][f\"{demand_id}\"] = Demand(env=env,demand_node=demand_node,**params) elif isinstance(d, Demand): if(d.ID in used_ids): global_logger.logger.error(f\"Duplicate demand ID {d.ID}\") raise ValueError(\"Duplicate demand ID\") used_ids.append(d.ID) supplychainnet[\"demands\"][f\"{d.ID}\"] = d supplychainnet[\"env\"] = env supplychainnet[\"num_of_nodes\"] = num_suppliers + num_manufacturers + num_distributors + num_retailers supplychainnet[\"num_of_links\"] = len(links) supplychainnet[\"num_suppliers\"] = num_suppliers supplychainnet[\"num_manufacturers\"] = num_manufacturers supplychainnet[\"num_distributors\"] = num_distributors supplychainnet[\"num_retailers\"] = num_retailers return supplychainnet","title":"create_sc_net"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.check_duplicate_id","text":"check_duplicate_id(used_ids, new_id, entity_type='ID') Checks if the new_id is already in used_ids. If it is, logs an error and raises a ValueError. Parameters: used_ids ( list ) \u2013 List of already used IDs. new_id ( str ) \u2013 The new ID to check. entity_type ( str , default: 'ID' ) \u2013 Type of the entity for which the ID is being checked (e.g., \"node ID\", \"link ID\"). Returns: \u2013 None Raises: ValueError \u2013 If the new_id is already in used_ids. Source code in src/SupplyNetPy/Components/utilities.py def check_duplicate_id(used_ids, new_id, entity_type=\"ID\"): \"\"\" Checks if the new_id is already in used_ids. If it is, logs an error and raises a ValueError. Parameters: used_ids (list): List of already used IDs. new_id (str): The new ID to check. entity_type (str): Type of the entity for which the ID is being checked (e.g., \"node ID\", \"link ID\"). Attributes: None Returns: None Raises: ValueError: If the new_id is already in used_ids. \"\"\" if new_id in used_ids: global_logger.logger.error(f\"Duplicate {entity_type} {new_id}\") raise ValueError(f\"Duplicate {entity_type}\") used_ids.append(new_id)","title":"check_duplicate_id"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.simulate_sc_net","text":"simulate_sc_net(supplychainnet, sim_time, logging=True) Simulate the supply chain network for a given time period, and calculate performance measures. Parameters: supplychainnet ( dict ) \u2013 A supply chain network. sim_time ( int ) \u2013 Simulation time. Returns: supplychainnet ( dict ) \u2013 Updated dict with listed performance measures. Source code in src/SupplyNetPy/Components/utilities.py def simulate_sc_net(supplychainnet, sim_time, logging=True): \"\"\" Simulate the supply chain network for a given time period, and calculate performance measures. Parameters: supplychainnet (dict): A supply chain network. sim_time (int): Simulation time. Returns: supplychainnet (dict): Updated dict with listed performance measures. \"\"\" logger = global_logger.logger env = supplychainnet[\"env\"] if(sim_time<=env.now): logger.warning(f\"You have already ran simulation for this network! \\n To create a new network use create_sc_net(), or specify the simulation time grater than {env.now} to run it further.\") logger.info(f\"Performance measures for the supply chain network are calculated and returned.\") elif isinstance(logging, tuple) and len(logging) == 2: assert logging[0] < logging[1], \"Start logging time should be less than stop logging time\" assert logging[0] >= 0, \"Start logging time should be greater than or equal to 0\" assert logging[1] <= sim_time, \"Stop logging time should be less than or equal to simulation time\" log_start = logging[0] log_stop = logging[1] global_logger.disable_logging() env.run(log_start) # Run the simulation global_logger.enable_logging() env.run(log_stop) # Run the simulation global_logger.disable_logging() if(sim_time > log_stop): env.run(sim_time) # Run the simulation elif isinstance(logging, bool) and logging: global_logger.enable_logging() env.run(sim_time) # Run the simulation else: global_logger.disable_logging() env.run(sim_time) # Run the simulation # Let's create some variables to store stats total_available_inv = 0 avg_available_inv = 0 total_inv_carry_cost = 0 total_inv_spend = 0 total_inv_waste = 0 total_transport_cost = 0 total_revenue = 0 total_cost = 0 total_profit = 0 total_demand_by_customers = [0, 0] # [orders, products] total_fulfillment_received_by_customers = [0, 0] # [orders, products] total_demand_by_site = [0, 0] # [orders, products] total_fulfillment_received_by_site = [0, 0] # [orders, products] total_demand_placed = [0, 0] # [orders, products] total_fulfillment_received = [0, 0] # [orders, products] total_shortage = [0, 0] # [orders, products] total_backorders = [0, 0] # [orders, products] for key, node in supplychainnet[\"nodes\"].items(): if(\"infinite\" in node.node_type.lower()): # skip infinite suppliers continue node.stats.update_stats() # update stats for the node total_available_inv += node.inventory.inventory.level if len(node.inventory.instantaneous_levels)>0: avg_available_inv += sum([x[1] for x in node.inventory.instantaneous_levels])/len(node.inventory.instantaneous_levels) total_inv_carry_cost += node.inventory.carry_cost total_inv_spend += node.stats.inventory_spend_cost total_inv_waste += node.stats.inventory_waste total_transport_cost += node.stats.transportation_cost total_cost += node.stats.node_cost total_revenue += node.stats.revenue total_demand_by_site[0] += node.stats.demand_placed[0] total_demand_by_site[1] += node.stats.demand_placed[1] total_fulfillment_received_by_site[0] += node.stats.fulfillment_received[0] total_fulfillment_received_by_site[1] += node.stats.fulfillment_received[1] total_shortage[0] += node.stats.orders_shortage[0] total_shortage[1] += node.stats.orders_shortage[1] total_backorders[0] += node.stats.backorder[0] total_backorders[1] += node.stats.backorder[1] for key, node in supplychainnet[\"demands\"].items(): node.stats.update_stats() # update stats for the node total_transport_cost += node.stats.transportation_cost total_cost += node.stats.node_cost total_revenue += node.stats.revenue total_demand_by_customers[0] += node.stats.demand_placed[0] # orders total_demand_by_customers[1] += node.stats.demand_placed[1] # products total_fulfillment_received_by_customers[0] += node.stats.fulfillment_received[0] total_fulfillment_received_by_customers[1] += node.stats.fulfillment_received[1] total_shortage[0] += node.stats.orders_shortage[0] total_shortage[1] += node.stats.orders_shortage[1] total_backorders[0] += node.stats.backorder[0] total_backorders[1] += node.stats.backorder[1] total_demand_placed[0] = total_demand_by_customers[0] + total_demand_by_site[0] total_demand_placed[1] = total_demand_by_customers[1] + total_demand_by_site[1] total_fulfillment_received[0] = total_fulfillment_received_by_customers[0] + total_fulfillment_received_by_site[0] total_fulfillment_received[1] = total_fulfillment_received_by_customers[1] + total_fulfillment_received_by_site[1] total_profit = total_revenue - total_cost supplychainnet[\"available_inv\"] = total_available_inv supplychainnet[\"avg_available_inv\"] = avg_available_inv supplychainnet[\"inventory_carry_cost\"] = total_inv_carry_cost supplychainnet[\"inventory_spend_cost\"] = total_inv_spend supplychainnet[\"inventory_waste\"] = total_inv_waste supplychainnet[\"transportation_cost\"] = total_transport_cost supplychainnet[\"revenue\"] = total_revenue supplychainnet[\"total_cost\"] = total_cost supplychainnet[\"profit\"] = total_profit supplychainnet[\"demand_by_customers\"] = total_demand_by_customers supplychainnet[\"fulfillment_received_by_customers\"] = total_fulfillment_received_by_customers supplychainnet[\"demand_by_site\"] = total_demand_by_site supplychainnet[\"fulfillment_received_by_site\"] = total_fulfillment_received_by_site supplychainnet[\"total_demand\"] = total_demand_placed supplychainnet[\"total_fulfillment_received\"] = total_fulfillment_received supplychainnet[\"shortage\"] = total_shortage supplychainnet[\"backorders\"] = total_backorders # Calculate average cost per order and per item if total_demand_placed[0] > 0: supplychainnet[\"avg_cost_per_order\"] = total_cost / total_demand_placed[0] else: supplychainnet[\"avg_cost_per_order\"] = 0 if total_demand_placed[1] > 0: supplychainnet[\"avg_cost_per_item\"] = total_cost / total_demand_placed[1] else: supplychainnet[\"avg_cost_per_item\"] = 0 if isinstance(logging, tuple): global_logger.enable_logging() max_key_length = max(len(key) for key in supplychainnet.keys()) + 1 logger.info(f\"Supply chain info:\") for key in sorted(supplychainnet.keys()): logger.info(f\"{key.ljust(max_key_length)}: {supplychainnet[key]}\") return supplychainnet","title":"simulate_sc_net"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.visualize_sc_net","text":"visualize_sc_net(supplychainnet) Visualize the supply chain network as a graph. Parameters: supplychainnet ( dict ) \u2013 The supply chain network containing nodes and edges. Returns: \u2013 None Source code in src/SupplyNetPy/Components/utilities.py def visualize_sc_net(supplychainnet): \"\"\" Visualize the supply chain network as a graph. Parameters: supplychainnet (dict): The supply chain network containing nodes and edges. Attributes: None Returns: None \"\"\" G = nx.Graph() nodes = supplychainnet[\"nodes\"] edges = supplychainnet[\"links\"] # Add nodes to the graph for node_id, node in nodes.items(): G.add_node(node_id, level=node.node_type) # Add edges to the graph for edge_id, edge in edges.items(): from_node = edge.source.ID to_node = edge.sink.ID G.add_edge(from_node, to_node, weight=round(edge.lead_time(),2)) # Generate the layout of the graph pos = nx.spectral_layout(G) # Draw the graph nx.draw(G, pos, node_color='#CCCCCC', with_labels=True) # Add edge labels labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels=labels) # Set the title and display the graph plt.title(\"Supply chain network\") plt.show()","title":"visualize_sc_net"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.print_node_wise_performance","text":"print_node_wise_performance(nodes_object_list) This function prints the performance metrics for each supply chain node provided in the nodes_object_list. Parameters: nodes_object_list ( list ) \u2013 List of supply chain node objects Returns: \u2013 None Source code in src/SupplyNetPy/Components/utilities.py def print_node_wise_performance(nodes_object_list): \"\"\" This function prints the performance metrics for each supply chain node provided in the nodes_object_list. Parameters: nodes_object_list (list): List of supply chain node objects Returns: None \"\"\" if not nodes_object_list: print(\"No nodes provided.\") return # Pre-fetch statistics from all nodes stats_per_node = {node.name: node.stats.get_statistics() for node in nodes_object_list} stat_keys = sorted(next(iter(stats_per_node.values())).keys()) # Determine column widths col_width = 25 header = \"Performance Metric\".ljust(col_width) for name in stats_per_node: header += name.ljust(col_width) print(header) # Print row-wise stats for key in stat_keys: row = key.ljust(col_width) for name in stats_per_node: value = stats_per_node[name].get(key, \"N/A\") row += str(value).ljust(col_width) print(row)","title":"print_node_wise_performance"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.get_sc_net_info","text":"get_sc_net_info(supplychainnet) Get supply chain network information. Parameters: supplychainnet ( dict ) \u2013 A dictionary representing the supply chain network. Attributes: logger ( Logger ) \u2013 The logger instance used for logging messages. sc_info ( str ) \u2013 A string to accumulate the supply chain network information. info_keys ( list ) \u2013 A list of keys to extract information from the supply chain network. keys ( set ) \u2013 A set of keys in the supply chain network regarding performance of the network. Returns: str \u2013 A string containing the supply chain network information. Source code in src/SupplyNetPy/Components/utilities.py def get_sc_net_info(supplychainnet): \"\"\" Get supply chain network information. Parameters: supplychainnet (dict): A dictionary representing the supply chain network. Attributes: logger (logging.Logger): The logger instance used for logging messages. sc_info (str): A string to accumulate the supply chain network information. info_keys (list): A list of keys to extract information from the supply chain network. keys (set): A set of keys in the supply chain network regarding performance of the network. Returns: str: A string containing the supply chain network information. \"\"\" logger = global_logger.logger global_logger.enable_logging(log_to_screen=True) sc_info = \"Supply chain configuration: \\n\" info_keys = ['num_of_nodes', 'num_of_links', 'num_suppliers','num_manufacturers', 'num_distributors', 'num_retailers'] for key in info_keys: if key in supplychainnet.keys(): sc_info += f\"{key}: {supplychainnet[key]}\\n\" logger.info(f\"{key}: {supplychainnet[key]}\") logger.info(f\"Nodes in the network: {list(supplychainnet['nodes'].keys())}\") sc_info += \"Nodes in the network:\\n\" for node_id, node in supplychainnet[\"nodes\"].items(): sc_info += process_info_dict(node.get_info(), logger) logger.info(f\"Edges in the network: {list(supplychainnet['links'].keys())}\") sc_info += \"Edges in the network:\\n\" for edge_id, edge in supplychainnet[\"links\"].items(): sc_info += process_info_dict(edge.get_info(), logger) logger.info(f\"Demands in the network: {list(supplychainnet['demands'].keys())}\") sc_info += \"Demands in the network:\\n\" for demand_id, demand in supplychainnet[\"demands\"].items(): sc_info += process_info_dict(demand.get_info(), logger) keys = supplychainnet.keys() - {'nodes', 'links', 'demands', 'env', 'num_of_nodes', 'num_of_links', 'num_suppliers','num_manufacturers', 'num_distributors', 'num_retailers'} sc_info += \"Supply chain network performance:\\n\" logger.info(\"Supply chain network performance:\") for key in sorted(keys): sc_info += f\"{key}: {supplychainnet[key]}\\n\" logger.info(f\"{key}: {supplychainnet[key]}\") return sc_info","title":"get_sc_net_info"},{"location":"api-reference/api-ref-utilities/#SupplyNetPy.Components.utilities.process_info_dict","text":"process_info_dict(info_dict, logger) Processes the dictionary and logs the key-value pairs. Parameters: info_dict ( dict ) \u2013 The information dictionary to process. logger ( Logger ) \u2013 The logger instance used for logging messages. Returns: str \u2013 A string representation of the processed information. Source code in src/SupplyNetPy/Components/utilities.py def process_info_dict(info_dict, logger): \"\"\" Processes the dictionary and logs the key-value pairs. Parameters: info_dict (dict): The information dictionary to process. logger (logging.Logger): The logger instance used for logging messages. Attributes: None Returns: str: A string representation of the processed information. \"\"\" info_string = \"\" for key, value in info_dict.items(): if isinstance(value, object): value = str(value) if callable(value): value = value.__name__ info_string += f\"{key}: {value}\\n\" logger.info(f\"{key}: {value}\") return info_string","title":"process_info_dict"}]}